\begin{center}
\includegraphics[width=0.9\textwidth]{image.png}
\end{center}

\begin{center}
\textbf{中国研究生创新实践系列大赛}\\
\textbf{“华为杯”第十七届中国研究生数学建模竞赛}
\end{center}

\title{质心平衡供油策略设计：贪心和搜索的结合}
\maketitle

\begin{abstract}
在飞行器飞行过程中，其质心变化对飞行器的控制有着重要的影响，而各个油箱内油量的分布和供油策略将对飞行器的质心变化产生重要影响。因此，为了最小化飞行过程中的实际质心和理想质心的最大偏差，本文根据计划耗油速度和理想质心对供油策略和油量分布进行求解。具体地，本文从四个角度对飞行器质心偏差算法进行说明：对飞行器存在俯仰角的情况下的质心进行建模求解，对给定初始油量，耗油速度和理想质心对供油策略进行建模求解，对给定剩余油量对初始和剩余油量分布进行建模求解，对固定理想质心为飞行器坐标系原点，且飞行器存在俯仰角的情况下对供油策略进行建模求解。

针对问题 1，对飞行器存在俯仰角的情况下的质心进行建模求解。本文依据数学几何知识，在每个油箱的中心建立坐标系，求解每个油箱各自的质心，然后进行坐标系转换得到飞行器坐标系下的油箱质心位置，再将油箱视为质点，求解得到飞行器的质心位置。

针对问题 2，对给定初始油量，耗油速度和理想质心对供油策略进行建模求解。本文利用贪心的思路设计逐时间节点的供油策略最优算法，并忽略连续供油的限制得到最优解，再通过数据分析得到规律，利用聚类的方法修正最优解，迭代得到满足所有约束的最优可行解。为了得到更少的质心偏差，本文允许飞行器耗油存在一定程度的浪费。在允许浪费 20\% 计划耗油的基础上，本文通过逐时间节点的供油策略最优算法和利用聚类方法最优解修正，得到完整的供油策略，其中飞行过程中飞行器实际质心和理想质心的欧氏距离最大值为 $6.95978 \times 10^{-5}$ 米，其最大值在第 5365 秒产生，而飞行过程的整体耗油为 6441.746226 千克，相比于计划耗油 6441.524212 千克，仅浪费 0.222014 千克。而在相同条件和算法下，不允许浪费的供油策略得到的欧氏距离最大值为 0.1246 米，其最大值在第 4159 秒产生，相较于允许浪费时的情况，增大了约 1790 倍。因此允许耗油的策略以少量的燃油浪费带来了质心偏移的大幅度降低，更值得被采用。

针对问题 3，不仅需要对给定剩余油量对初始和剩余油量分布进行建模求解，还需要根据耗油速度和理想质心进一步地对供油策略进行建模求解。本文从剩余油量的分布进行求解，反向推导完整飞行过程的供油策略，并根据最大质心偏移的油量数据修正剩余油量分布，直到得到最终的油量分布和供油策略。根据 $t=7200s$ 时刻数据，剩余油量的初始解为 $(0, 54, 137, 111, 120, 428)$ 千克，通过迭代修正为 $(0.0, 47.18759, 131.5116, 144.8741, 130.9014, 395.5253)$ 千克。通过反向推导得到油箱 1-6 初始化的油量为 $(147.50475, 1214.0329, 2019.6, 2254.2, 1560.29485, 1020)$ 千克。此时飞行整体耗油 $7298.005094 \mathrm{~kg}$，计划耗油 $6805.174669 \mathrm{~kg}$，合计浪费约 $7.2\%$。飞行器质心与理想质心距离的最大值为 $0.119036 \mathrm{~m}$，发生在第 5372 秒。

针对问题 4，对固定理想质心为飞行器坐标系原点，且飞行器存在俯仰角的情况下对供油策略进行建模求解。由于俯仰角的存在，质心计算公式从线性关系的计算中变成了分段式非线性计算，利用问题 2 的求解思路难以实现。对于不同的俯仰角，对于 $y$ 轴和 $z$ 轴的计算均使用平飞状态近似，引入最大的误差为 $1.8\%$，在误差允许的情况下能极大的简化计算，提高计算速度。另一方面，将完整的飞行过程按 60 秒为一个时间段划分，强制每一个时间段使用同样的油箱供油，其油箱使用方案有 34 种。求解采用不同方案 60 秒供油策略，选择质心偏差和最小的方案作为该 60 秒的最终供油策略，使之在可行解的基础上寻找最优解。最终得到的实际质心与理想质心的欧氏距离最大值为 0.038594 米，这一最大距离产生在第 3839 秒。其中飞行过程总消耗油量 7565.579365 千克，相比于计划耗油 7035.545163 千克，浪费 $7.53\%$。
\end{abstract}

\tableofcontents

\section{问题重述}

\subsection{背景介绍与问题描述}

资料显示，飞行器质心对飞行安全会产生很大影响，因为设备布置问题，飞行器油箱一般分散布置在机身各处 \cite{ref1,ref2}。携带有多个油箱的飞行器在飞行过程中，通过若干个油箱联合供油以同时满足飞行任务要求和发动机工作需求。各个油箱内油量的分布和供油策略将导致飞行器质心变化，进而影响对飞行器的控制。统计资料显示，大多数此类飞行器在日常工作中都存在燃油消耗不平衡的现象 \cite{ref3}，因此，需要制定利于飞行器控制的各油箱的供油策略。

飞行器的结构（如油箱的位置、形状、尺寸、供油关系、供油速度限制等）影响油箱的供油策略和飞行器的质心变化。已知飞行器净质量、油箱中心相对飞行器不载油时质心的位置、各个油箱的尺寸。本问题研究的飞行器型号一共有 6 个油箱，各油箱供油示意图如图 \ref{fig:1-1} 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{oil_tank_diagram.png}
    \caption{各油箱供油示意图}
    \label{fig:1-1}
\end{figure}

\subsection{问题提出}

基于已知信息建立数学模型，在给定的数据下，求解以下 4 个问题：

\textbf{问题 1：} 已知某次任务中飞行器的 6 个油箱的供油速度及飞行器在飞行过程中俯仰角变化数据，根据 6 个油箱的初始油量，求解飞行器在任务执行过程中的质心变化曲线，并计算其质心在飞行器坐标系下的位置数据。

\textbf{问题 2：} 已知某次飞行任务中飞行器计划耗油速度数据，与飞行器在飞行器坐标系下的理想质心位置数据。根据任务需求，在飞行器始终保持平飞的任务规划过程中，指定满足条件的 6 个油箱供油策略，使得飞行器每一时刻的质心位置 $\vec{c}_1(t)$ 与理想质心位置 $\vec{c}_2(t)$ 的欧氏距离的最大值达到最小，i.e.,

\[
\min_{t} \max \|\vec{c}_1(t) - \vec{c}_2(t)\|_2
\]

计算出飞行器飞行过程中 6 个油箱各自的供油速度和 4 个主油箱的总供油速度、以及飞行器瞬时质心与理想质心距离的最大值和 4 个主油箱的总供油量。

\textbf{问题 3：} 假定初始油量未定，已知某次任务的飞行器计划耗油速度数据，与飞行器在飞行器坐标系下的理想质心位置数据。在飞行器始终保持平飞（俯仰角为 0）的任务规划过程中，制定飞行器在该次任务满足条件的 6 个油箱初始载油量及供油策略，使得本次任务结束时 6 个油箱剩余燃油总量至少 $1 \, m^3$，并且飞行器每一时刻的质心位置 $\vec{c}_1(t)$ 与理想质心位置 $\vec{c}_2(t)$ 的欧氏距离的最大值达到最小，i.e.,

\[
\min_{t} \max \|\vec{c}_1(t) - \vec{c}_2(t)\|_2
\]

给出 6 个油箱的初始载油量、飞行器飞行过程中 6 个油箱的供油速度和 4 个主油箱的总供油速度（时间间隔为 \(1 \, \text{s}\)）、以及飞行器质心与理想质心距离的最大值和 4 个主油箱的总供油量。

\textbf{问题 4：} 在实际任务规划过程中，飞行器俯仰角随时间变化。已知飞行器俯仰角的变化数据和耗油速度数据，为本次任务制定油箱供油策略，使得飞行器瞬时质心 \(\bar{c}_1(t)\) 与飞行器（不载油）质心 \(\bar{c}_0\) 的最大距离达到最小，即
\[
\min \max_t \|\bar{c}_1(t) - \bar{c}_2(t)\|_2
\]

绘出飞行器飞行过程中 6 个油箱各自的供油速度曲线，再将 4 个主油箱的总供油速度曲线（时间间隔为 \(1 \, \text{s}\)）与计划耗油速度曲线绘于一个图中，给出飞行器瞬时质心与飞行器（不载油）质心 \(\bar{c}_0\) 的最大距离偏差以及 4 个主油箱的总供油量。

\section{模型假设}

\begin{itemize}
    \item 假设 1: 可以将油箱简化为长方体且固定在飞行器内部，油箱的长、宽、高的三个方向与飞行器坐标系的 $x, y, z$ 轴三个方向平行。
    \item 假设 2: 以飞行器不载油时的质心 $\vec{c}_0$ 为原点建立惯性坐标系、飞行器坐标系；
    \item 假设 3: 第 $i$ 个油箱的供油速度上限为 $U_i$ ($U_i > 0$)，每个油箱一次供油的持续时间不少于 60 秒。
    \item 假设 4: 主油箱 2、3、4、5 可直接向发动机供油，油箱 1 和油箱 6 作为备份油箱分别为油箱 2 和油箱 5 供油，不能直接向发动机供油。
    \item 假设 5: 由于受到飞行器结构的限制，至多 2 个油箱可同时向发动机供油，至多 3 个油箱可同时供油。
    \item 假设 6: 飞行器在执行任务过程中，各油箱联合供油的总量应至少满足发动机的对耗油量的需要，若某时刻供油量大于计划耗油量，多余的燃油可通过其它装置排出飞行器。
    \item 假设 7: 飞行器的飞行过程中只有俯仰和平飞的情况。飞行器的俯仰将导致各油箱相对地面的姿态发生偏斜，在重力作用下，油箱的燃油分布随之变化。
    \item 假设 8: 飞行器飞行过程是平稳的，加速度为 0，即油箱内燃油液面始终与水平面平行。
    \item 假设 9: 油箱中不会存在油珠飞溅、油珠挂壁等情况，且油箱内的燃油可以被完全使用。
    \item 假设 10: 燃油是完全密度均匀的。
    \item 假设 11: 假设飞行器飞行过程中，每个油箱为发动机或其他油箱供油是瞬时完成的，且输送频率为每秒 1 次（或者不输送）。
\end{itemize}

\section{符号说明}

\begin{tabular}{l l}
\hline
符号 & 意义 \\
\hline
$T$ & 油箱的集合 \\
$t_{i}$ & 油箱编号 \\
$O$ & 惯性坐标系下的原点 \\
$x, y, z$ & 惯性坐标系下的坐标轴 \\
$O(t)$ & 飞行器坐标系下的原点 \\
$x(t), y(t), z(t)$ & 飞行器坐标系下的坐标轴 \\
$a_{i}$ & 油箱$i$的长（飞行器坐标系$x$轴方向的长度） \\
$b_{i}$ & 油箱$i$的宽（飞行器坐标系$y$轴方向的长度） \\
$c_{i}$ & 油箱$i$的高（飞行器坐标系$z$轴方向的长度） \\
$\vec{c}_{0}$ & 飞行器不载油时的质心位置 \\
$\vec{c}_{1}(t)$ & 飞机时刻$t$的实际质心位置 \\
$\vec{c}_{2}(t)$ & 飞机时刻$t$的理想质心位置 \\
$M$ & 飞行器净重量 \\
$\vec{P}_{i}$ & 第$i$个空油箱的中心位置 \\
$U_{i}$ & 第$i$个油箱的供油速度上限 \\
$v_{i}(t)$ & 第$i$个油箱时刻$t$的供油速度 \\
$V(t)$ & 飞行器时刻$t$的耗油速度 \\
$\vec{p}_{i}(t)$ & 第$i$个油箱内的燃油在时刻$t$的质心位置 \\
$S_{i}(t)$ & 第$i$个油箱内的燃油在时刻$t$在$xOz$ \\
$m_{i\text{max}}$ & 第$i$个油箱能够容纳的燃油质量上限 \\
$m_{i}(t)$ & 第$i$个油箱时刻$t$的剩余油量 \\
\hline
\end{tabular}

\section{问题 1 模型的建立与求解}

\subsection{问题 1 描述与分析}

问题 1 给出了某次任务中飞行器的 6 个油箱的供油速度及飞行器在飞行过程中的俯仰角变化数据，根据飞行器的简化模型和假设条件，建立物理模型对不同情况作分类讨论即可解决问题，如图 4-1 给出了根据题中所给数据得到的油箱相对位置图。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image1.png}
    \caption{油箱三维位置示意图}
    \label{fig:oil_tanks_3d}
\end{figure}

为了分别求解每个油箱在时间 \( t \) 的质心位置，对每个油箱分别建立坐标系。以一个油箱为例，以其在中心位置为原点，建立坐标系 \( O-x'y'z' \)，如图 4-2 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image2.png}
    \caption{三维油箱坐标系示意图}
    \label{fig:oil_tank_coordinate}
\end{figure}

由于不考虑飞行器的左右偏转，故油箱内的燃油形状始终是柱体，在飞行器俯仰角不同、油箱内燃油体积不同的情况下，其形态可以分为三棱柱、四棱柱、五棱柱三种情况。由于燃油是密度均匀的，故在油箱坐标系内，无论燃油处于何种形态，$y'$方向上的坐标始终为0，可以不用考虑。另一方面，燃油棱柱质心在$x'$方向和$z'$方向上的坐标与棱柱在$x'Oz'$平面上的截面的质心在$x'$方向和$z'$方向上的坐标相同，因此，我们可以将问题进一步简化为求解燃油截面图形的质心。

因此将单一油箱的三维质心问题降维成为$xOz$平面上求解多边形二维质心问题。根据油箱中所剩余油量不同，共存在三种不同的二维图形，分别为三角形，四边形，五边形。以飞机向上仰冲时为例，示意图如图 4-3 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{image1.png}
    \caption{所剩油量为三角形示意图}
    \label{fig:triangle}
\end{figure}

当油箱中所剩余油量较少时，会在油箱的$xOz$平面形成如上图 4-3 所示的三角形，假设油是质量分布均匀且稳定的情况下。此时油箱内油的质心是三角形油面的质心。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{image2.png}
    \caption{所剩油量为四边形示意图}
    \label{fig:quadrilateral}
\end{figure}

当油箱中所剩余油量较少时，会在油箱的$xOz$平面形成如图 4-4 所示的四边形，假设油是质量分布均匀且稳定的情况下。此时油箱内油的质心是四边形油面的质心。

同时若油箱内油量继续增加，则会在油箱内形成五边形的截面，其示意图如下图 4-5 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{image1.png}
    \caption{所剩油量为五边形示意图}
    \label{fig:5-sided}
\end{figure}

根据质心定义，针对四边形及五边形的质心求解此次建模采用将多边形三角化算法。多边形三角化是对多边形的基本处理，它是指在原有图形的基础上将多边形划分成许多互不重叠的三角形[4]。三角化一般包括平面点集三角化和多边形三角化，最经典的 Delaunay 三角剖分算法采用的是平面点集三角化方法，然后根据三角形的质心求解进行加权平均，最终解得多边形的质心。

故针对问题一的整体思路是将六个油箱单独建立坐标系，以油箱不装油量时在 $x'O'z'$ 平面上的质心为坐标原点，建立与飞机坐标系平行的油箱坐标系。进而分别计算不用时刻的油箱质心变化，用质心代替油箱，将问题化简为点系统下的质心。最后解得整个系统的质心。

\subsection{多边形三角化求解质心}

在求解二维油箱截面模型质心时需要计算三角形、四边形、五边形的质心。三角形质心为其顶点坐标之和的平均值。但是四边形和五边形不能直接用顶点坐标之和的平均值求得。则其中一个求解多边形质心的方案是多边形三角化。

因为问题一中所涉及的只是规则的四边形和五边形，则三角化的方法也可以进行简化，以四边形为例，其分解示意图如图 \ref{fig:quadrilateral} 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{image2.png}
    \caption{四边形三角化示意图}
    \label{fig:quadrilateral}
\end{figure}

如上图 4-4 所示，四边形 $abcd$ 被黑色虚线部分分解成为三角形 $abc$ 和三角形 $acd$。通过三角形质心公式，分别求得三角形 $abc$ 的质心为：
\begin{align*}
x_{1} &= \left(-\frac{a_{i}}{2}, -\frac{c_{i}}{2}\right) \\
x_{2} &= \left(\frac{a_{i}}{2}, -\frac{c_{i}}{2}\right) \\
x_{3} &= \left(\frac{a_{i}}{2}, \frac{c_{i}}{2} - (a_{i} - d) * \tan \theta\right) \\
x_{4} &= \left(-\frac{a_{i}}{2} + d, \frac{c_{i}}{2}\right) \\
x_{5} &= \left(-\frac{a_{i}}{2}, \frac{c_{i}}{2}\right)
\end{align*}

三角形 $acd$ 的质心为：
\begin{align}
x_1 &= \left(-\frac{a_i}{2}, -\frac{c_i}{2}\right) \\
x_2 &= \left(\frac{a_i}{2}, -\frac{c_i}{2}\right) \\
x_3 &= \left(\frac{a_i}{2}, -\frac{c_i}{2} + d - a_i * \tan \theta\right) \\
x_4 &= \left(-\frac{a_i}{2}, d - \frac{c_i}{2}\right)
\end{align}

然后分别求得三角形 $abc$ 的面积 $S_1$ 及三角形 $acd$ 的面积 $S_2$。最终求得四边形 $abcd$ 的质心为：
\begin{align}
x_{1} &= \left( -\frac{a_{i}}{2}, -\frac{c_{i}}{2} \right) \\
x_{2} &= \left( d - \frac{a_{i}}{2}, -\frac{c_{i}}{2} \right) \\
x_{3} &= \left( -\frac{a_{i}}{2} + x - \frac{c}{\tan \theta}, \frac{c_{i}}{2} \right) \\
x_{4} &= \left( -\frac{a_{i}}{2}, \frac{c_{i}}{2} \right)
\tag{4-11}
\end{align}

五边形的质心求解同上，将五边形分成三个三角形进行质心的加权平均。

\subsection{二维油箱子模型质心求解建模}

将三维的油箱模型降维成为 $xOz$ 平面上的二维平面模型。当油箱中加入初始化的油量之后，其示意图如下所示。

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{image.png}
\caption{二维截面油箱示意图}
\end{figure}

根据油箱 $xOz$ 平面的油箱长和高的比例不同，会导致在某一相同倾斜角度下，在油箱内所剩余油相同时，进入不同的油分布情况。根据计算，阈值的倾斜角度为 $\arctan \left( \frac{l}{h} \right)$，其中 $h$ 为油箱高度，即沿 $z$ 轴方向的高度，$l$ 为油箱长度，即沿 $x$ 轴方向的长度。

同时根据飞行器的上下俯冲、直飞的不同情况。所以将二维油箱模型质心求解建模划分为三类，分别为上仰、俯冲和直飞，六种油面形状，共有 $2 \times 6 + 1 = 13$ 种模型。同时因为当飞行器姿态为上仰和俯冲时，油面形状关于 $z$ 轴对称。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{image1.png}
    \caption{上仰和俯冲坐标示意图}
    \label{fig:1}
\end{figure}

假设上图所示油箱模型长度 $l$，高度为 $h$，如上图中点 $x_{1}$ 在黑色所示坐标系下的坐标为 $\left(-\frac{l}{2}, -\frac{h}{2}\right)$，则 $x_{1}'$ 在图中红色坐标系下的坐标为 $\left(\frac{l}{2}, -\frac{h}{2}\right)$，因此飞行器为上仰时的任意顶点坐标与俯冲时的对应顶点坐标关于 $z$ 轴对称，因此在建模求解平面质心时，只需求解上仰或者俯冲中的任意情况，另一种情况下的对应质心为该情况下的质心坐标的 $z$ 轴对称坐标值。基于如上推论，以下建模只分析仰角时的模型。

根据上文中计算得到阈值的倾斜角度为 $\theta_{t} = \arctan\left(\frac{l}{h}\right)$。

当倾斜角度 $\theta \leq \arctan\left(\frac{l}{h}\right)$ 时，根据油箱中所剩余的油量不同，共存在三种平面模型：三角形、四边形、五边形。存在两种边界情况，其边界示意图 4-9 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{image2.png}
    \caption{上仰边界示意图}
    \label{fig:2}
\end{figure}

上图 4-9 中的红色线段为图形边界，包括实线与虚线，图中黄色、蓝色、紫色虚线段分别示意不同的界面情况，分别对应油箱内截面图形为五边形、四边形、三角形时。

首先根据油箱尺寸求解出两条红色线段所代表的油箱内所剩余油量的截面面积的边界值。根据图中所示倾斜角度 \(\theta\) 及图中所示油箱第 \(i\) 个油箱的尺寸为 \(a_i\) 及 \(b_i\)。可以求得三角形与四边形的面积边界值 \(S_1\) 为：
\[
S_1 = \frac{1}{2} * a_i^2 * \tan \theta
\tag{4-4}
\]

四边形与五边形的面积边界值 \(S_2\) 为：
\[
S_2 = a_i * c_i - \frac{1}{2} * a_i^2 * \tan \theta
\tag{4-5}
\]

1) 当 \(S \leq S_1\) 时，此时截面模型如图 4-10 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{triangle_cross_section.png}
    \caption{三角形截面坐标示意图}
    \label{fig:triangle_cross_section}
\end{figure}

其中 \(d = \sqrt{\frac{2 * S_i}{\tan \theta}}\)，\(S_i\) 为第 \(i\) 个油箱中所剩余油量截面面积 \(S_i = \frac{V_i}{b_i}\)，其中 \(V_i = \frac{m_{i(t)}}{\rho}\)，\(\rho\) 为油的密度 \(850 \, \text{kg/m}^3\)。根据所求 \(d\) 求解得出点 \(x_1\)、\(x_2\)、\(x_3\) 坐标。
\begin{align}
x_1 &= \left( -\frac{a_i}{2}, -\frac{c_i}{2} \right) \\
x_2 &= \left( -\frac{a_i}{2}, d * \tan \theta - \frac{c_i}{2} \right) \\
x_3 &= \left( d - \frac{a_i}{2}, -\frac{c_i}{2} \right)
\tag{4-6}
\end{align}

因此得出此时截面中三角形的质心坐标为 \(\frac{x_1 + x_2 + x_3}{3}\)。即三个点的平均坐标值。

2) 当 \(S_1 < S \leq S_2\) 时，此时截面模型如图 4-11 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{image1.png}
    \caption{四边形截面坐标示意图}
    \label{fig:4-11}
\end{figure}

其中 $d = \frac{S}{a_i} + \frac{1}{2} a_i \tan \theta$，$S_i$ 为第 $i$ 个油箱中所剩余油量截面面积 $S_i = \frac{V_i}{b_i}$，其中 $V_i = \frac{m_{i(t)}}{\rho}$，$\rho$ 为油的密度 $850 \, \text{kg}/\text{m}^3$。根据所求 $d$ 求解得出点 $x_1$、$x_2$、$x_3$、$x_4$ 坐标。

\begin{align}
x_1 &= \left(-\frac{a_i}{2}, -\frac{c_i}{2}\right) \\
x_2 &= \left(\frac{a_i}{2}, -\frac{c_i}{2}\right) \\
x_3 &= \left(\frac{a_i}{2}, -\frac{c_i}{2} + d - a_i * \tan \theta\right) \\
x_4 &= \left(-\frac{a_i}{2}, d - \frac{c_i}{2}\right)
\end{align}

因此根据上文推导四边形三角化算法得出该模型下的截面质心位置。

3) 当 $S > S_2$ 时，此时截面模型为：

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{image2.png}
    \caption{五边形截面坐标示意图}
    \label{fig:4-12}
\end{figure}

其中 $d = a_{i} - \sqrt{\frac{2(a_{i} c_{i} - S_{i})}{\tan \theta}}$，$S_{i}$ 为第 $i$ 个油箱中所剩余油量截面面积 $S_{i} = \frac{V_{i}}{b_{i}}$，其中 $V_{i} = \frac{m_{i(t)}}{\rho}$，$\rho$ 为油的密度 $850 \, kg/m^{3}$。根据所求 $d$ 求解得出点 $x_{1}$、$x_{2}$、$x_{3}$、$x_{4}$、$x_{5}$ 坐标。

\begin{align*}
x_{1} &= \left(-\frac{a_{i}}{2}, -\frac{c_{i}}{2}\right) \\
x_{2} &= \left(\frac{a_{i}}{2}, -\frac{c_{i}}{2}\right) \\
x_{3} &= \left(\frac{a_{i}}{2}, \frac{c_{i}}{2} - (a_{i} - d) * \tan \theta\right) \\
x_{4} &= \left(-\frac{a_{i}}{2} + d, \frac{c_{i}}{2}\right) \\
x_{5} &= \left(-\frac{a_{i}}{2}, \frac{c_{i}}{2}\right)
\end{align*}

因此根据上文推导五边形三角化算法得出该模型下的截面质心位置。

当倾斜角度 $\theta > \arctan\left(\frac{l}{h}\right)$ 时，根据油箱中所剩余的油量不同，同样共存在三种平面模型：三角形、四边形、五边形。存在两种边界情况，其边界示意图与 $\theta \leq \arctan\left(\frac{l}{h}\right)$ 时存在差别，如下图 4-13 所示。

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{image.png}
\caption{上仰边界示意图}
\end{figure}

上图 4-13 中的红色线段为图形边界，包括实线与虚线，图中黄色、蓝色、紫色虚线段分别示意不同的界面情况，分别对应油箱内截面图形为五边形、四边形、三角形时。

同上文分析相同，首先根据油箱尺寸求解出两条红色线段所代表的油箱内所剩余油量的截面面积的边界值。根据图中所示倾斜角度 $\theta$ 及图中所示油箱第 $i$ 个油箱的尺寸为 $a_{i}$ 及 $b_{i}$。可以求得三角形与四边形的面积边界值 $S_{1}$ 为：

\begin{equation}
S_{1} = \frac{1}{2} * \frac{c_{i}^{2}}{\tan \theta}
\tag{4-9}
\end{equation}

四边形与五边形的面积边界值 $S_{2}$ 为:

\begin{equation}
S_{2} = a_{i} * c_{i} - \frac{1}{2} * \frac{c_{i}^{2}}{\tan \theta}
\tag{4-10}
\end{equation}

4) 当 $S \leq S_{1}$ 时，同上文 1) 情况分析计算结果相同。

5) 当 $S_{1} < S \leq S_{2}$ 时，此时截面模型不同于上文 2) 所计算模型，因此需要重新建立模型，其示意图如下所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{image.png}
    \caption{四边形截面坐标示意图}
    \label{fig:4-14}
\end{figure}

其中 $d = \frac{S}{c_{i}} + \frac{c_{i}}{2 \tan \theta}$，$S_{i}$ 为第 $i$ 个油箱中所剩余油量截面面积 $S_{i} = \frac{V_{i}}{b_{i}}$，其中 $V_{i} = \frac{m_{i(t)}}{\rho}$，$\rho$ 为油的密度 $850 \, \text{kg/m}^3$。根据所求 $d$ 求解得出点 $x_{1}$、$x_{2}$、$x_{3}$、$x_{4}$ 坐标。

\begin{align}
x_{1} &= \left( -\frac{a_{i}}{2}, -\frac{c_{i}}{2} \right) \\
x_{2} &= \left( d - \frac{a_{i}}{2}, -\frac{c_{i}}{2} \right) \\
x_{3} &= \left( -\frac{a_{i}}{2} + x - \frac{c}{\tan \theta}, \frac{c_{i}}{2} \right) \\
x_{4} &= \left( -\frac{a_{i}}{2}, \frac{c_{i}}{2} \right)
\tag{4-11}
\end{align}

因此根据上文推导四边形三角化算法得出该模型下的截面质心位置。

6) 当 $S > S_{2}$ 时，同上文 3) 情况分析计算结果相同。

当飞机进行平飞时，$\theta = 0$，油箱内的油在 $xOz$ 平面呈现长方形，其示意图如下所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{image.png}
    \caption{平飞油面示意图}
    \label{fig:oil_surface}
\end{figure}

其中 $d = \frac{S}{a_i}$，$S_i$ 为第 $i$ 个油箱中所剩余油量截面面积 $S_i = \frac{V_i}{b_i}$，其中 $V_i = \frac{m_{i(t)}}{\rho}$，$\rho$ 为油的密度 $850 \, kg/m^3$。根据所求 $d$ 求解得出点 $x_1$、$x_2$、$x_3$、$x_4$ 坐标。

\begin{equation}
\begin{aligned}
x_1 &= \left(-\frac{a_i}{2}, -\frac{c_i}{2}\right) \\
x_2 &= \left(\frac{a_i}{2}, -\frac{c_i}{2}\right) \\
x_3 &= \left(\frac{a_i}{2}, d - \frac{c_i}{2}\right) \\
x_4 &= \left(-\frac{a_i}{2}, d - \frac{c_i}{2}\right)
\end{aligned}
\tag{4-12}
\end{equation}

则长方形的质心为 $\left(0, \frac{d}{2} - \frac{c_i}{2}\right)$。

\subsection{三维油箱质心坐标求解}

在 4.2 节中分析求解了二维 $xOz$ 平面的油箱模型质心，同时 $y$ 轴方向质心在自身油箱坐标系中的值为 0。至此完成了每个油箱相对于自身坐标系的建模。

\subsection{三维飞行器质心模型}

油箱相对自身的坐标系以自身中心为原点，所以其相对于飞行器坐标系的偏移量为附件 1 中的油箱中心位置。因此每个三维油箱质心在飞行器坐标系中的坐标为三维坐标加偏移量。假设第 $i$ 个油箱在自身坐标系中的质心位置为 $(x_i, y_i, z_i)$，其油箱的中心位置为 $(x_{ti}, y_{ti}, z_{ti})$，则其在飞行器系统中的位置为 $(x_i + x_{ti}, y_i + y_{ti}, z_i + z_{ti})$。

将飞行器系统分解为不加油时的整体飞机系统（包括油箱），其质心为 $(0, 0, 0)$，及六个油箱中的油模型，其质心为上节 4.3、4.4 中求解可得，第 $i$ 个油的质心设为 $(x_i, y_i, z_i)$，则飞机器（含油）整体的质心 $(x, y, z)$ 求解公式为：

\begin{equation}
(x, y, z) = \frac{\sum_{i=1}^{6} (x_i + y_i + z_i) m_{i(t)}}{M + \sum_{i=1}^{6} m_{i(t)}}
\tag{4-13}
\end{equation}

\section{问题 1 结果与分析}

此次分别在 matlab 与 Visual Studio 2019 通过 C++ 求解整体质心偏移模型。两种方式解得数据相同。解得质心在 x 轴、y 轴、z 轴的偏移情况如图 4-16 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image1.png}
    \caption{质心各方向偏移示意图}
    \label{fig:4-16}
\end{figure}

根据上图所示，发现质心在 x 轴向上的偏移量最大，x 轴向的偏移对整体的偏移影响最大。y 轴方向的质心偏移仅与各个油箱所剩油量相关，在单独计算各个油箱质心时，y 轴方向质心不变，所以 y 轴质心偏移量也较小。同时 z 轴向的质心偏移最为稳定，变化幅度变化量最小。将三个方向的偏移合成一个方向，求解整体的质心偏移量示意图如图 4-17 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image2.png}
    \caption{质心整体偏移示意图}
    \label{fig:4-17}
\end{figure}

如上图所示，质心整体偏移呈现先上升，再下降，然后再上升，最后下降的趋势。基本与 \( x \) 轴向的偏移趋势相同。同时质心整体偏移的最大值发生在第 5177 秒，最大偏移量为 1.1091。也与 \( x \) 轴的最大值出现时刻大致吻合。同样说明 \( x \) 轴向的偏移对整体的偏移影响最大。

\section{问题 2 模型的建立与求解}

\subsection{问题描述与分析}

问题 2 要求规划满足任务需求的油箱供油策略，目标是使得飞行器每一时刻的质心位置与理想质心位置 $\bar{c}_2(t)$ 的欧氏距离的最大值达到最小。题目给定了飞行器计划耗油速度及飞行器在飞行器坐标系下的理想质心位置数据。与问题 1 不同的是，问题 2 限定了飞行器俯仰角始终为 0，简化了质心求解过程，可以认为在油箱坐标系下，油箱的质心位置只会存在 $z$ 方向上的变化。由于飞行器每个油箱内的初始油量已经给定，我们需要确保油量始终足够飞行器完成本次飞行任务，在此基础上寻找问题的最优解。

问题 2 的目标在于使整体情况的质心偏移最小，但探索完整飞行过程中的质心偏移最大值最小需要求解大量的参数，例如每个时刻的油箱供油速度和油箱的选择，这使得求解十分困难。另一方面，在实际飞行器飞行过程中，后续飞行过程的油耗和质心偏移难以估测，因此通过当前油量和当前的油耗分析进行供油策略的设计是一个比较合理的可行方案。基于此，我们对模型进行简化，每个时刻仅根据当前时刻剩余油量和需求油量求解供油速度和油箱选择，即用每个时刻的局部最优解代替全局最优解，使得问题得以解决。

\subsection{模型建立}

目标函数

在问题 2 中，变量是每个油箱每一时刻的供油速度，目标是使得当前时刻的燃油被消耗后，质心位置与当前时刻质心理想位置的欧氏距离最小，依此建模，目标函数如下：

\begin{equation}
\min f = \|\bar{c}_1(t) - \bar{c}_2(t)\|_2
\end{equation}

\begin{equation}
= \sqrt{(x_{real}(t) - x_{ideal}(t))^2 + (y_{real}(t) - y_{ideal}(t))^2 + (z_{real}(t) - z_{ideal}(t))^2} \quad \forall t
\tag{5-1}
\end{equation}

其中 $(x_{ideal}(t), y_{ideal}(t), z_{ideal}(t))$ 表示时刻 $t$ 飞行器在飞行器坐标系下的理想质心坐标，$(x_{real}(t), y_{real}(t), z_{real}(t))$ 表示时刻 $t$ 飞行器在飞行器坐标系下的实际质心坐标，可以用当前时刻各个油箱的质量和质心坐标求出：

\begin{equation}
\left\{
\begin{aligned}
x_{real}(t) &= \frac{\sum\limits_{i=1}^6 m_i(t)x_i(t)}{M + \sum\limits_{i=1}^6 m_i(t)x_i(t)} \\
y_{real}(t) &= \frac{\sum\limits_{i=1}^6 m_i(t)y_i(t)}{M + \sum\limits_{i=1}^6 m_i(t)y_i(t)}, \quad \forall t \\
z_{real}(t) &= \frac{\sum\limits_{i=1}^6 m_i(t)z_i(t)}{M + \sum\limits_{i=1}^6 m_i(t)z_i(t)}
\end{aligned}
\right.
\tag{5-2}
\end{equation}

其中 $(x_i(t), y_i(t), z_i(t))$ 表示油箱 $i$ 在 $t$ 时刻时在飞行器坐标系下质心的坐标，$m_i(t)$ 表示油箱 $i$ 在时刻 $t$ 的剩余燃油质量，可以用递推式得到：

\begin{equation}
\begin{cases}
m_{i}(t)=m_{i}(t-1)-v_{i}(t), i=1,3,4,5 \\
m_{2}(t)=m_{2}(t-1)-v_{2}(t)+v_{1}(t) & \forall t \geq 1 \\
m_{5}(t)=m_{5}(t-1)-v_{5}(t)+v_{6}(t)
\end{cases}
\tag{5-3}
\end{equation}

$m_{i}(0)$ 题目中已给定。

根据问题 1 的推导，当 $m_{i}(t)$ 确定后，引入俯仰角为 0 的条件，我们即可以计算出 $(x_{i}(t), y_{i}(t), z_{i}(t))$。

至此，我们建立起了每一时刻飞行器实际质心位置、理想质心位置的欧氏距离与油箱供油速度的函数关系，并指出了模型的目标函数。

约束条件

约束 1：供油速度约束：每一时刻每个油箱的供油速度应为非负数，且不能超过油箱的供油速度上限和油箱当前的剩余油量，可以用不等式描述为：
\begin{equation}
0 \leq v_{i}(t) \leq \min(U_{i}, m_{i}(t-1) / \Delta t), \ \forall t, \ i=1,2,3,4,5,6
\tag{5-4}
\end{equation}

在本问题中，$\Delta t=1 \mathrm{~s}$。同时，这一约束也使得油箱的油量必定非负。

约束 2：耗油速度约束：每一时刻油箱 2、3、4、5 的供油速度之和应不小于当前时间的计划耗油速度；另一方面，我们允许 2、3、4、5 供油速度之和大于当前时间的计划耗油速度，即我们允许一定程度的油量浪费换取更小的实际质心和理想质心的偏差。进一步地，由于我们在计算时刻 $t$ 的油箱供油速度时没有考虑之后完成之后飞行任务需要的耗油量，为了保证后续油量始终充足，使用参数 $\alpha$ 来描述浪费的上限：
\begin{equation}
V(t) \leq \sum_{i=2}^{5} v_{i}(t) \leq \alpha V(t), \ \alpha \geq 1, \ \forall t
\tag{5-5}
\end{equation}

约束 3：油箱容量约束：由于 6 个油箱的容量限制，每个油箱中燃油体积不能超过其能容纳的燃油质量上限 $m_{i \max }$：
\begin{equation}
m_{i \max }=a_{i} b_{i} c_{i} \times 850, \ i=1,2,3,4,5,6
\tag{5-6}
\end{equation}

在本问题中，由于初始油量已经给定，油箱 1、3、4、6 只能消耗燃油，因此必定满足油量小于油箱容量。因此只需要考虑每一时刻油箱 1 给油箱 2 供油、油箱 6 给油箱 5 供油后，油箱 2、油箱 6 中的燃油体积不能超过其能容纳的燃油质量上限：
\begin{equation}
\begin{cases}
m_{2}(t-1)+v_{1}(t) \leq m_{2 \max } \\
m_{5}(t-1)+v_{6}(t) \leq m_{5 \max }
\end{cases}, \ \forall t
\tag{5-7}
\end{equation}

约束 4：供油油箱数约束：供油由于受到飞行器结构的限制，至多 2 个油箱可同时向发动机供油，至多 3 个油箱可同时供油。在每个时刻 $t, p_{i}(t)$ 表示油箱 $i$ 是否处于可以供油的状态，为 1 表示可以供油，为 0 表示不能供油，则有：
\begin{equation}
p_{i}(t)=0 \text { or } 1, \ i=1,2,3,4,5,6
\end{equation}
\begin{equation}
\begin{cases}
\sum_{i=2}^{5} p_{i}(t) \leq 2 \\
\sum_{i=1}^{6} p_{i}(t) \leq 3
\end{cases}, \ \forall t
\tag{5-8}
\end{equation}

约束 5: $p_{i}(t)$ 与 $v_{i}(t)$ 之间的约束: 当 $p_{i}(t)=0$ 时, 表示油箱 $i$ 不能被使用, $v_{i}(t)$ 必定为 0 。

约束 6: 供油持续时间约束: 每个油箱的持续供油时间不得少于 60 秒, 设油箱 $i$ 某次向发动机或其他油箱供油在 $t_{i_{1}}$ 时刻开始, 在 $t_{i_{2}}$ 时刻结束, 则有:
\begin{equation}
t_{i_{2}}-t_{i_{1}} \geq 60, \, i=1,2,3,4,5,6
\tag{5-9}
\end{equation}

综上, 我们完成了问题二模型的建立。

\subsection{模型实现与求解}

\subsubsection{算法设计}

如果每一时刻都考虑各油箱供油策略要有利于飞行器完成一次飞行任务的全局耗油需求, 情况过于复杂。因此, 我们考虑采用贪心算法的思想, 逐个时间节点考虑当前情况的最优解。另一方面, 约束 5 的引入使得需要对 60 秒的过程整体求解, 极大的增加了求解器的压力, 为了简化模型方便计算, 同样引入贪心的思想, 暂时搁置约束 5 的限制, 先求出逐个时间节点的最优解, 再对该解进行修正迭代以得到满足约束 5 的最终结果。

对于逐个时间节点的求解, 我们使用了 LINGO 数学软件进行求解。LINGO 是 Linear Interactive and General Optimizer 的缩写, 即 “交互式的线性和通用优化求解器”, 由美国 LINDO 系统公司 (Lindo System Inc.) 推出的, 为非线性规划和线性规划提供了很好的求解方案。问题二的求解模型已有前文给出, 其模型为 MINLP, 即混合整数非线性规划, 可以利用 LINGO 软件很好的求解。此外, 题目给出的精度十分高, 某些初始状态数据达到 $1 \mathrm{e}-9$ 的量级, 因此对 LINGO 的非线性求解器参数进行修改, 其中 Final Nonl Feasibility Tol 设置为 $1 \mathrm{e}-16$, Nonlinear Optimality Tol 设置为 $1 \mathrm{e}-17$, 并且开启相关策略加速求解和提高求解精度, 其设置可参考下图进行。

在得到逐个时间节点的最优解方案后, 需要对其进行修正以满足约束 5 的限制。其基于以下两个现象:

1) 数据出现 “集群” 现象: 如下表所示, 第 95-100 秒的供油决策均倾向于 2 号油箱供油, 可以认为最终方案中该时间段均由 2 号油箱供油。同时存在少数数据不完全满足该现象, 例如表中的 95 时刻的数据, 猜想其可能是求解器的精度和结果的不稳定性导致, 将其用 2 号油箱供油的方案相比于原方案带来的误差可以容忍 ($1 \mathrm{e}-4$ 级别), 并且几乎不会对整个飞行过程的实际质心与理想质心最大偏移产生影响。因此我们可以通过类似聚类的方法, 对逐个时间节点的最优解方案进行修正。

\begin{tabular}{|l|}
\hline
\textbf{问题 4 的模型实现算法} \\
\hline
输入： \\
consume：发动机耗油数据 \\
angle：飞行器俯仰角 \\
过程： \\
定义初始约束条件：等式线性约束条件 \{Aeq, Beq\}、不等式线性约束条件 \{A, B\}、变量上下界 \{LB, UB\}、搜寻起点 \{v0\} \\
定义初始油箱油量 last \\
定义优化条件 options \\
for j=1 to 7200 \% 遍历所有时间，步长为 60 \\
\quad for i=1 to 34 \% 枚举 34 种方案 \\
\quad \quad 更新剩余油量 lasttmp = last \\
\quad \quad for k=1 to 60 \% 遍历 60 秒时长 \\
\quad \quad \quad 更新不等式约束条件边界 B \\
\quad \quad \quad fmincon(@ (v) ques4sol(v, lasttmp, angle), v0, A, B, Aeq, Beq, LB, UB, '', options); \\
\quad \quad \quad 记录规划结果 vt \\
\quad \quad \quad 更新 lasttmp \\
\quad \quad \quad distmp += dis; \% 累加当前方案的质心偏差 \\
\quad \quad \quad 更新变量 v 的上界 UB \\
\quad \quad end for \\
\quad \quad dissum(i) = distmp; \% 记录当前方案的累计质心偏差 \\
\quad end for \\
\quad q = min(dissum); \% 找到累计质心偏差最小方案 \\
\quad fv(j:j+59, :) = vtmp(q, :, :); \% 将偏差最小的供油方案作为整体供油方案 \\
\hline
\end{tabular}

2) 修正带来的误差积累: 虽然现象 1 表示其单个时间节点上的修正不会带来不可容忍的偏差, 但随着时间的积累, 其误差存在积累而使得后续数据不可信, 另外修正使得油箱油量数据偏差大，进一步加剧了误差。因此在完成对一定时间段供油策略的修正后，需要对后续数据进行重新求解，保证后续逐时间节点最优解的可靠性。

基于以上两个现象，我们对供油方案进行修正，其流程如下所示。其中初始化供油策略即对所有油箱不设置约束，然后对求解逐个时间节点的最优解方案。再利用聚类的思路，对数据进行修正，此处我们设置了 1000 秒的时间段，即修正 0-1000 秒的供油策略，然后将前 1000 秒的供油策略固定，重新求解逐时间节点的最优解，再修正下一个 1000 秒的时间段，直到全部数据修正完成，输出供油策略。

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{image1.png}
\caption{问题 2 求解算法流程图}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{image2.png}
\caption{问题 2 Lingo 软件求解器参数设置}
\end{figure}

\subsubsection{问题2求解结果及分析}

根据 5.3.1 节所述的算法流程，我们得到了原始的逐个时间节点的最优解方案，如图 5-3 所示，从上到下分别展示了 1-6 油箱的供油曲线。可以看到在油箱的选择上具有不稳定性，在几组近似的解中来回震荡，显示出图中的供油策略的巨大抖动，但供油策略的整体趋势仍然存在，即 “集群” 情况的存在，这使得基于聚类的修正是可行的。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image1.png}
    \caption{修正前的供油策略}
    \label{fig:5-3}
\end{figure}

对供油策略进行分析聚类，修正得到的结果并重新多次迭代，其最终的六个油箱的供油曲线如图 5-4 所示，相比于之前的结论，其曲线变得更加光滑合理。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image2.png}
    \caption{修正后的供油策略}
    \label{fig:5-4}
\end{figure}

我们将 6 个油箱的供油速度（每秒一组）绘在一张图上，如图 5-5 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image3.png}
    \caption{6 个油箱的供油速度}
    \label{fig:5-5}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image1.png}
    \caption{问题二 6个油箱各自的供油曲线}
    \label{fig:6_tanks_supply_curve}
\end{figure}

根据上述结果，我们可以得到六个油箱的供油策略和选择方案。其中 1 号油箱在 $[387, 864]$ 时间段供油，2 号油箱在 $[95, 2056]$ 时间段供油，3 号油箱在 $[2802, 5251]$ 时间段供油，4 号油箱在 $[1422, 3328]$ 时间段供油，5 号油箱在 $[3959, 5987]$ 时间段供油，6 号油箱在 $[3959, 5365]$ 时间段供油。

将 4 个主油箱的供油速度相加，得到了 4 个主油箱的总供油速度（每秒一组），供油曲线如图 \ref{fig:4_tanks_total_supply_curve} 所示。与如图 5-7 所示的计划耗油曲线相比，二者基本可以重合。通过计算，4 个主油箱的总供油量为 6441.746226 千克，而发动机实际共耗油 6441.524212 千克，说明根据 5.3.1 所述的算法得到的供油策略，在保证实际质心与理想质心的偏移距离极小的前提下，导致的燃油浪费极少，浪费总量仅为 0.222014 千克。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image2.png}
    \caption{问题二 4 个主油箱的总供油速度曲线}
    \label{fig:4_tanks_total_supply_curve}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image1.png}
    \caption{问题2计划耗油速度}
    \label{fig:5-7}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image2.png}
    \caption{实际质心与理想质心的欧氏距离}
    \label{fig:5-8}
\end{figure}

计算每一秒钟飞行器的实际质心与理想质心的欧氏距离，作出曲线如图\ref{fig:5-8}所示。实际质心与理想质心的欧氏距离最大值为6.959780e-05米，这一最大距离产生在第5365秒。可以认定，5.3.1所述的算法求出了一种满足实际质心与理想质心的欧氏距离最大值很小的供油策略，完成了预期目标，且浪费的燃油极少。

为了进一步说明上述结论，我们设置不允许燃油浪费，即在5.2所述模型的约束2中，将$\alpha$设定为1，得到了一种新的供油策略。使用新的供油策略计算实际质心与理想质心的欧氏距离，得到的曲线如图5-9所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image.png}
    \caption{不允许浪费燃油得到的实际质心与理想质心的欧氏距离}
    \label{fig:5-9}
\end{figure}

不允许浪费燃油得到的实际质心与理想质心的欧氏距离最大值为 0.1246 米，这一最大距离产生在第 4159 秒。这一最大距离相较于允许浪费时的情况，增大了约 1790 倍。

综上，使用所建立的模型和求解算法得到了一种供油策略，完成问题 2 所要求的任务后，4 个主油箱的总供油量为 6441.746226 千克，浪费燃油仅 0.222014 千克，实际质心与理想质心的欧氏距离最大值为 6.959780e-05 米。

\section{问题 3 模型的建立与求解}

\subsection{问题描述与分析}

问题 3 相比于问题 2，同样是要求基于飞行器一次平飞任务中的耗油速度数据和理想质心数据规划飞行器在每个时刻每个油箱的供油速度，使得飞行器每一时刻的质心位置 $\bar{c}_1(t)$ 与理想质心位置 $\bar{c}_2(t)$ 的欧氏距离的最大值达到最小。不同点在于，问题 3 给定了任务结束时 6 个油箱剩余燃油总量的最小值，需要规划出每个油箱中燃油的初始量。

据此，我们将问题的解决分为两个方面，第一阶段确定任务开始时 6 个油箱的油量，第二阶段规划每个时间 6 个油箱的供油策略。

\subsection{模型建立}

第一阶段模型建立

相比于第二题的求解，第三题需要求解所有油箱的初始油量。在允许浪费的情况下，不仅要求解初始油总量，也要求解各个油箱油量分配，该问题的解空间巨大，难以在短时间内求解。因此我们从最终状态反推。

第一阶段的目标是找出任务开始时，所剩燃油在 6 个油箱中的分布情况，即已知剩余燃油总量 $m(7200)$，将其分布在 6 个油箱中，使得质心偏离最终的理想质心最小。据此，我们可以确定目标函数与约束条件。

目标函数

\begin{equation}
\begin{aligned}
\min f &= \|\bar{c}_1(7200) - \bar{c}_2(7200)\|_2 \\
&= \sqrt{(x_{real}(7200) - x_{ideal}(7200))^2 + (y_{real}(7200) - y_{ideal}(7200))^2 + (z_{real}(7200) - z_{ideal}(7200))^2}
\end{aligned}
\tag{6-1}
\end{equation}

其中 $(x_{ideal}(7200), y_{ideal}(7200), z_{ideal}(7200))$ 表示任务结束时飞行器在飞行器坐标系下的理想质心坐标，$(x_{real}(7200), y_{real}(7200), z_{real}(7200))$ 表示任务结束时飞行器在飞行器坐标系下的实际质心坐标，可以用各个油箱的质量和质心坐标求出：

\begin{equation}
\left\{
\begin{aligned}
x_{real}(7200) &= \frac{\sum\limits_{i=1}^6 m_i(7200) x_i(7200)}{M + \sum\limits_{i=1}^6 m_i(7200) x_i(7200)} \\
y_{real}(7200) &= \frac{\sum\limits_{i=1}^6 m_i(7200) y_i(7200)}{M + \sum\limits_{i=1}^6 m_i(7200) y_i(7200)} \\
z_{real}(7200) &= \frac{\sum\limits_{i=1}^6 m_i(7200) z_i(7200)}{M + \sum\limits_{i=1}^6 m_i(7200) z_i(7200)}
\end{aligned}
\right.
\tag{6-2}
\end{equation}

其中，$m_i(7200)$ 表示油箱 $i$ 在任务结束时的所载燃油质量，$(x_i(7200), y_i(7200), z_i(7200))$ 表示油箱 $i$ 在任务结束时在飞行器坐标系下的坐标，可以根据 $m_i(7200)$ 和空油箱的中心坐标求出。

综上，我们建立了实际质心与理想质心的欧氏距离关于 6 个油箱初始载油质量的目标函数。

约束条件

约束 1：与问题 2 中的约束 3 类似，问题 3 也需要满足油箱容量约束：由于 6 个油箱的容量限制，每个油箱中燃油体积不能超过其能容纳的燃油质量上限 $m_{i_{\max}}$：

\[
m_{i_{\max}} = a_i b_i c_i \times 850, \quad i = 1, 2, 3, 4, 5, 6
\]

与问题 2 不同的是，本问题中我们需要考虑 6 个油箱的容量上限：

\[
m_{i_{\text{start}}} \leq m_{i_{\max}}, \quad i = 1, 2, 3, 4, 5, 6
\]

满足上述条件后，同时也必定就满足了 6 个油箱总容量的约束。

约束 2：耗油总量及剩余油量限制：本问题中，限制了任务结束时 6 个油箱内燃油剩余总量不低于 $m(7200)_{\min} = 850$。

综上，我们建立了第一阶段的数学模型。

第二阶段模型建立：

第二阶段的模型建立与问题 2 模型建立相同。

\subsection{模型实现与求解}

\begin{figure}[h]
\centering
\begin{tikzpicture}[node distance=2cm, auto, >=latex]
    % 定义节点样式
    \tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=white]
    \tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=white]
    \tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=white]
    \tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=white]
    \tikzstyle{arrow} = [thick,->,>=stealth]

    % 绘制流程图
    \node (init) [startstop] {初始化剩余油量限制};
    \node (solve1) [process, below of=init] {求解剩余油量};
    \node (solve2) [process, below of=solve1] {求解逐时间节点的供油最优解};
    \node (decision1) [decision, below of=solve2, yshift=-1cm] {质心偏差是否达到上限};
    \node (decision2) [decision, below of=decision1, yshift=-1cm] {是否求解完全部时间节点};
    \node (output) [startstop, below of=decision2, yshift=-1cm] {输出油量分配和供油策略};
    \node (new_target) [process, right of=solve2, xshift=3cm] {根据最大质心偏差建立新的求解目标};

    % 绘制箭头
    \draw [arrow] (init) -- (solve1);
    \draw [arrow] (solve1) -- (solve2);
    \draw [arrow] (solve2) -- (decision1);
    \draw [arrow] (decision1) -- node [near start, left] {否} (solve2);
    \draw [arrow] (decision1) -- node [near start, right] {是} (new_target);
    \draw [arrow] (new_target) -- (solve1);
    \draw [arrow] (decision1) -- node [near start, left] {否} (decision2);
    \draw [arrow] (decision2) -- node [near start, right] {是} (output);
    \draw [arrow] (decision2) -- node [near start, left] {否} (solve2);
\end{tikzpicture}
\caption{图 6-1 问题 3 算法流程图}
\end{figure}

\subsubsection{算法设计}

相比于第二题，第三题需要确定初始油量，但这带来巨大的解空间和计算开销。因此

我们从最终状态开始反推飞行过程，直到得到初始状态的油量分配和供油策略。相应地，我们需要将问题拆解为两部分，第一阶段是求解最终剩余油量，第二阶段是根据最终油量反向推导飞行过程。

第一阶段我们求解剩余油量，其剩余油量的数学模型如 6.2 表示，我们利用 LINGO 进行求解。但最终状态的剩余油量的约束太少，有大量的可行解存在，因此我们采用贪心搜索的方案进行搜索，其流程如图 6-1 所示。

首先我们初始化剩余油量限制，即飞行最终阶段实际质心和理想质心偏差最小，由此可以得到剩余油量的初始解。再求解逐时间节点的供油最优解，该问题的求解与问题 2 模型求解类似，不同的是原本的油量消耗的方向取反，即变为油量供给。在逐时间节点的求解中，每一个时间节点都会计算当前实际质心与理想质心的偏差，如果超过偏差上限则不再继续计算，而根据当前节点的数据重新建立求解目标。以 \( t \) 时刻质心偏差超过上限为例，根据 \( t \) 之前时刻得到的供油策略，可以得到 \( t \) 时刻的油箱油量为

\[
m_i(t) = m_i(7200) + \sum_{i=t}^{7200} v_i(t) \Delta t
\tag{6-5}
\]

根据 \( t \) 时刻的油箱油量，可以得到 \( t \) 时刻的实际质心位置与理想质心的偏差，对两者同时进行优化，即目标函数更新为

\[
\min f = \max \left( \left\| \vec{c}_1(7200) - \vec{c}_2(7200) \right\|_2, \left\| \vec{c}_1(t) - \vec{c}_2(t) \right\|_2 \right)
\tag{6-6}
\]

根据新的目标函数得到剩余油量的更优解，重新求解逐时间节点的供油最优解，直到求解完所有时间节点，并且所有质心偏差均满足偏差上限，此处我们的偏差上限设置为 0.2 米。由此我们得到了初步的供油方案，剩余油量和初始油量，进入第二阶段。

需要注意的时，为了简化计算流程，我们没有使用的与问题 2 类似的修正，因此得到的供油方案并不可靠，需要在第二阶段进行修正。同时，没有修正会带来一定的误差，导致剩余油量求解无法达到最优。但模型本身存在一定的容错性，因此带来可以容忍的误差，并且求解速度有了巨大的提升。

第二阶段与问题 2 类似，在得知了初始油量和初步的供油方案后，正向推导，进行修正和迭代直到满足问题 2 中的约束 5，也可以通过剩余油量和初步的供油方案，反向推导，进行修正迭代直到满足问题 2 中的约束 5。两者方案类似，此处我们用正向推导的方式进行求解，得到类似的剩余油量，以进行双重核验确保结果的准确性。由此我们得到最终的供油方案和初始油量。

\subsubsection{问题 3 求解结果与分析}

根据上述所述的算法流程，我们得到了 6 个油箱的供油速度（每秒一组），各自的供油曲线如图 6-2 所示，从上到下分别表示 1-6 油箱的供油曲线。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image1.png}
    \caption{图6-2 问题36个油箱的耗油曲线}
\end{figure}

从上图中可以得出供油策略，从上往下依次是油箱1~6的供油曲线。可以看出油箱1主要在600-800时间输出，油箱2主要集中在3300-4500输出，油箱3主要在3800-5200输出，油箱4的供油时长较长，从600-2200及2500-3300是主要的输出时间段，油箱5的供油时间段主要为1800-3800，油箱6的主要输出时间段为2200-2500,3200-3800两个时间段。

将4个主油箱的供油速度相加，得到了4个主油箱的总供油速度（每秒一组），供油曲线如下图所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image2.png}
    \caption{图6-3 实际供油曲线与计划耗油曲线对比图}
\end{figure}

通过计算，4个主油箱的总供油量为7298.005094千克，而发动机实际共耗6805.174669千克。发动机油量有浪费，供油与消耗之比大约为1.072。油箱1-6初始化的油量为(0.173535, 1.428274, 2.376, 2.652, 1.835641, 1.2)立方米。飞行器质心与理想质心距离的最大值为0.119036 米，出现在第 5372 秒。其飞行器质心与理想质心的偏差曲线如图 6-4 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image.png}
    \caption{飞行器质心与理想质心偏差示意图}
    \label{fig:6-4}
\end{figure}

可以看出，虽然 5000 秒之后的计划供油速度和实际供油速度均下降，但实际质心和理想质心偏差难以恢复，其原因在于此时大部分燃油均已被消耗，而 2-5 号油箱不能进行燃油相互传递使得质心难以被平衡，最终导致质心偏差居高不下。

\section{问题 4 模型的建立与求解}

\subsection{问题 4 描述与分析}

相较于问题 2，问题 4 增加了飞行器在执行任务过程中的俯仰角的变化；相较于问题 3，问题 4 给定了 6 个油箱中油量的初始值。此外，问题 4 相较于问题 2 和问题 3 不再给定理想质心，改为要求任务执行过程中的实际质心与飞行器不载油时的质心的欧氏距离最小：

\begin{equation}
\min \max \|\vec{c}_1(t) - \vec{c}_0\|_2
\tag{7-1}
\end{equation}

综上，问题 4 的目标是根据飞行器的耗油速度和俯仰角变化，规划 6 个油箱的供油策略。

\subsection{问题 4 模型建立}

问题 4 的数学模型基本与问题 2 一致，但由于引入了俯仰角的变化，我们基于问题 1 的质心求解模型做了简化。

根据问题 1 中推导得到的计算质心方法及公式，在进行问题四中的迭代计算中，运算量急剧增大。相比于问题 2 及问题 3，问题四中引入俯仰角，所以质心计算公式从线性关系的计算中变成了分段式非线性计算，计算量变大，使得迭代时间变长。因此在保证质心偏移的相对正确性的基础上，为了减少计算量，可以对质心的求解进行简化。同时根据问题 1 中得到的质心偏移曲线中，发现系统整体质心的偏移量主要由 $x$ 轴方向的偏移引起。

验证问题 1 系统整体质心的偏移量主要由 $x$ 轴方向的偏移引起的推测。因此将问题 1 数据进行再次测试，将问题 1 中的俯仰角变成 0。得到新的质心偏移值，然后将原 $x$ 轴质心坐标数据代替新生成的不加俯仰角 $x$ 轴质心坐标，形成两组质心坐标。两种情况下的质心偏移数据曲线如下图所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{image.png}
    \caption{$z$ 轴误差导致质心偏移示意图}
    \label{fig:z_error}
\end{figure}

引入 $z$ 轴误差后，两组曲线相同，同时放在同一图中会出现完全重合，说明 $z$ 轴误差导致的质心偏移变化非常小。以下计算具体误差比例。

计算不加俯仰角时的质心位置相对原带有俯仰角的偏移比例。其由 $z$ 轴数据引入的误差数据如下图所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image.png}
    \caption{$z$ 轴误差导致实际质心与理想质心的偏移比例}
    \label{fig:z_error}
\end{figure}

由上图可以得出，由 $z$ 轴数据引入的误差所占比最大为 $1.8\%$。我们认为 $z$ 轴数据引入的误差可以接受，因此在问题 4 中计算整体的质心模型时，可以只计算 $x$ 轴向上的俯仰角变化引入的 $x$ 轴质心偏移。$Z$ 轴上质心数据按平飞时计算，采用此模型可以大幅减少计算质心所需计算量，加快迭代速度，同时误差在可接受范围内。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{image2.png}
    \caption{问题 4 的求解算法流程图}
    \label{fig:algorithm_flow}
\end{figure}

\subsection{问题 4 的模型实现与算法设计}

\subsubsection{算法设计}

问题 4 的模型与问题 2 基本一致，但由于俯仰角的变化导致了求解质心坐标的过程中包含大量的分支，而使用 Lingo 软件求解包含大量分支的函数繁琐且复杂，因此，我们选择使用 Matlab 软件实现模型。

相较于问题 2，我们改变了求解过程，不再使用（找出最优解方案 -> 根据约束 5 修正方案）的策略。我们将 60 秒时间划为一组，强制在 60 秒之内使用相同的油箱。根据供油油箱数约束，油箱使用方案共有 34 种，计算公式为：
\begin{equation}
(C_{2}^{0} + C_{2}^{1} + C_{2}^{2})C_{4}^{1} + (C_{2}^{0} + C_{2}^{1})C_{4}^{2} = 34
\tag{7-2}
\end{equation}

算法中，针对每一组 60 秒，我们求解采用不同方案的 60 秒最优供油策略，计算每种方案下 60 秒的质心偏差和，选择质心偏差和最小的方案作为该 60 秒的最终供油策略。依次循环，直到针对每组 60 秒都得到供油方案，即完成全部飞行任务。算法具体的流程图如图 7-3 所示。

求解过程的伪代码如下：

\begin{tabular}{|l|}
\hline
\textbf{问题 4 的模型实现算法} \\
\hline
输入： \\
consume：发动机耗油数据 \\
angle：飞行器俯仰角 \\
过程： \\
定义初始约束条件：等式线性约束条件 \{Aeq, Beq\}、不等式线性约束条件 \{A, B\}、变量上下界 \{LB, UB\}、搜寻起点 \{v0\} \\
定义初始油箱油量 last \\
定义优化条件 options \\
for j=1 to 7200 \% 遍历所有时间，步长为 60 \\
\quad for i=1 to 34 \% 枚举 34 种方案 \\
\quad \quad 更新剩余油量 lasttmp = last \\
\quad \quad for k=1 to 60 \% 遍历 60 秒时长 \\
\quad \quad \quad 更新不等式约束条件边界 B \\
\quad \quad \quad fmincon(@ (v) ques4sol(v, lasttmp, angle), v0, A, B, Aeq, Beq, LB, UB, '', options); \\
\quad \quad \quad 记录规划结果 vt \\
\quad \quad \quad 更新 lasttmp \\
\quad \quad \quad distmp += dis; \% 累加当前方案的质心偏差 \\
\quad \quad \quad 更新变量 v 的上界 UB \\
\quad \quad end for \\
\quad \quad dissum(i) = distmp; \% 记录当前方案的累计质心偏差 \\
\quad end for \\
\quad q = min(dissum); \% 找到累计质心偏差最小方案 \\
\quad fv(j:j+59, :) = vtmp(q, :, :); \% 将偏差最小的供油方案作为整体供油方案 \\
\hline
\end{tabular}

\begin{tabular}{|c|}
\hline 更新 last \\
\hline 更新变量 v 的上界 UB \\
\hline end for \\
\hline 输出：fv：问题 4 供油策略 \\
\hline
\end{tabular}

\subsubsection{问题 4 的求解结果与分析}

根据 7.3.1 节所述的算法流程，我们得到了 6 个油箱的供油速度（每秒一组），各自的供油曲线如图 7-4 所示。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image1.png}
    \caption{问题四 6 个油箱各自的供油曲线}
    \label{fig:7-4}
\end{figure}

将 4 个主油箱的供油速度相加，得到了 4 个主油箱的总供油速度（每秒一组），供油曲线如图 7-5 所示。与图中的计划耗油曲线相比，二者在大部分区域基本重合。通过计算，4 个主油箱的总供油量为 7565.579365 千克，而发动机实际共耗油 7035.545163 千克，说明根据 7.3.1 所述的算法得到的供油策略，在保证实际质心与理想质心的偏移距离很小的前提下，实际耗油约为计划耗油的 1.0753 倍。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image1.png}
    \caption{问题四 4个主油箱的总供油速度曲线和计划耗油曲线}
    \label{fig:7-5}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image2.png}
    \caption{实际质心与飞行器（不载油）质心的欧氏距离}
    \label{fig:7-6}
\end{figure}

计算每一秒钟飞行器的实际质心与理想质心的欧氏距离，作出曲线如图 \ref{fig:7-6} 所示。实际质心与理想质心的欧氏距离最大值为 0.038594 米，这一最大距离产生在第 3839 秒。可以认定，7.3.1 所述的算法求出了一种满足实际质心与飞行器（不载油）质心的欧氏距离最大值很小的供油策略，完成了预期目标，且浪费的燃油很少。

综上，使用所建立的模型和求解算法得到了一种供油策略，完成问题 4 所要求的任务后，4 个主油箱的总供油量为 7565.579365 千克，为计划耗油的 1.0753 倍，实际质心与理想质心的欧氏距离最大值为 0.038594 米。

\section{模型的总结与评价}

\subsection{模型的优点}

1) 在问题 1 中，我们对飞行状态下的各个油箱质心进行建模，利用数学几何知识对三种状态下油量的质心计算进行求解，根据给定的油量和无人机仰角，能快速准确地求解出相对于无人机坐标系下的质心位置。

2) 问题 2 是根据飞行过程求解供油策略，为了最小化飞行过程中最大质心偏移，全局求解的思路因大量的变量难以求解。我们利用贪心的思路对问题进行了简化，相比于基于整个飞行过程的优化求解，逐时间节点的优化求解能极大的加快求解答速度，并根据数据分布规律，参考聚类算法对数据进行修正，能准确快速地得到满足所有约束的供油方案。

3) 问题 3 需要同时确定油量分配和供油策略，我们引入了基于贪心搜索的算法求解剩余油量，相比于其他启发式算法能更快地得到一个最优解。

4) 问题 4 在理想质心不变且恒为原点的情况下，进一步简化了供油策略的求解。将整个飞行过程按照 60 秒的时间进行划分，极大的加速了求解速度，且求解不需要进行进一步的修正，能够更快速准确地得到满足所有约束的供油方案。问题 4 还对飞行器存在仰角的情况下，简化质心求解过程，在误差允许的情况下能大幅加速供油策略的求解。

\subsection{模型的改进}

1) 基于数据分布规律的供油方案修正策略依赖数据分布规律，在极端情况下可能无法得到合理的修正。

2) 基于贪心搜索求解剩余油量的算法对算法起始点的敏感度高，影响最终收敛值。较差的起始点可能使得算法收敛到局部最优。

3) 问题 4 提出的，对飞行器存在仰角的情况下，质心求解的简化过程仅在仰角较小的情况下有效，随着仰角的增大误差增大而变得难以接受。

\subsection{展望}

1) 参考其他启发式算法，改进加快基于贪心搜索求解剩余油量的算法速度，提高算法的稳定性，使其更容易收敛到全局最优点。

2) 对于复杂情况下的质心模型求解可以进行相应的优化，在可接受误差下减少贪心搜索的计算量。

3) 本题没有引入左右偏转的情况，问题考虑略简单，离真实情况还有很大的差距。在今后的工作中应当建立更完整的数学模型以得到更具有现实意义的结论。

\section{参考文献}

[1] 曾关辉, 王继亮. 受油飞机重量重心控制技术研究[J]. 河南科技, 2020(17): 41-43.

[2] 吕亚国. 飞机燃油系统计算研究[D]. 西北工业大学, 2006.

[3] 张宇庆. Cessna 172R 飞机油箱燃油消耗不平衡浅析[J]. 内燃机与配件, 2019(23): 155-157.

[4] 邹新龙, 石丹, 刘茂, 毕军建, 谭志良, ZOU Xin-long, SHI Dan, LIU Mao, BI Jun-jian, TAN Zhi-liang. 《环境技术》2014 年 z2 期

\section{附录}
40
附录
问题一：
[Centroid solution:]
1. clc;
1. clear;
1. q=zeros(6,7);
1. watch=zeros(1,6);
1. [Consume]=xlsread('C:\Users\DELL\Desktop\新建文件夹\附件2-问题1 数
据.xlsx',1,'B2:G7201');
1. Centroid_0=zeros(7200,3);
1.
1. [angles]=xlsread('C:\Users\DELL\Desktop\新建文件夹\附件2-问题1 数
据.xlsx',2,'B2:B7201');
1. centerOffset=[8.91304348 1.20652174 0.61669004;
1. 6.91304348  -1.39347826  0.21669004;
1. -1.68695652 1.20652174   -0.28330996;
1. 3.11304348  0.60652174   -0.18330996;
1. -5.28695652  -0.29347826  0.41669004;
1. -2.08695652  -1.49347826  0.21669004];
1. sizeOffset=[1.5  0.9  0.3;
1. 2.2  0.8  1.1;
1. 2.4  1.1  0.9;
1. 1.7  1.3  1.2;
1. 2.4  1.2  1;
1. 2.4  1  0.5];
1. remainingOil=[0.3 1.5 2.1 1.9 2.6 0.8];
1. %remainingOil=[0.173535 1.428274 2.376 2.652 1.835641 1.2];
1. for  i=1:7200
1. for j=1:6
1. remainingOil(j)=remainingOil(j)-Consume(i,j)/850;
1. end
1. remainingOil(2)=remainingOil(2)+(Consume(i,1)/850);
1. remainingOil(5)=remainingOil(5)+(Consume(i,6)/850);
1.
1. tmpCentroid.x=0;
1. tmpCentroid.y=0;
1. tmpCentroid.z=0;
1. tmpWeight=0;
1. for j=1:6
1. tmp.y=centerOffset(j,2);
1. a=sizeOffset(j,1);
1. c=sizeOffset(j,3);
1. radian = angles(i) * pi /180;



41
1. s = remainingOil(j) / sizeOffset(j,2);
1. angle_t = abs(radian);
1. if angle_t==0
1. x=s/a;
1. tmp.x=0;
1. tmp.z=-c/2+x/2;
1. q(j,1)=q(j,1)+1;
1. elseif  angle_t<abs(atan(c / a))
1. boundary1 = a * a * tan(angle_t) / 2;
1. boundary2 = a * c - a * a * tan(angle_t) / 2;
1. if s<=boundary1
1. x = sqrt(2 * s / tan(angle_t));
1. x1 = -a/2;
1. y1 = -c/2;
1. x2 = -a / 2;
1. y2 = x * tan(angle_t)-c/2;
1. x3 = x-a/2;
1. y3 = -c/2;
1. q(j,2)=q(j,2)+1;
1. tmp.x=(x1+x2+x3)/3;
1. tmp.z = (y1 + y2 + y3) / 3;
1. elseif s <= boundary2
1. x = s / a + a * tan(angle_t) / 2;
1. x1 = -a / 2;
1. y1 = -c / 2;
1. x2 = a / 2;
1. y2 = -c / 2;
1. x3 = a / 2;
1. y3 = -c/2 + x-a*tan(angle_t);
1. x4 = -a / 2;
1. y4 = x - c / 2;
1. q(j,3)=q(j,3)+1;
1. input=[x1 y1;x2 y2;x3 y3;x4 y4];
1.
1. [tmp.x,tmp.z]=PolygonCentroid(input);
1. else
1. x = a-sqrt(2*(a*c-s)/tan(angle_t));
1. x1 = -a / 2;
1. y1 = -c / 2;
1. x2 = a / 2;
1. y2 = -c / 2;
1. x3 = a / 2;
1. y3 = c / 2 - (a-x)* tan(angle_t);
1. x4 = -a/2 +x;



42
1. y4 =c/2;
1. x5 = -a / 2;
1. y5 = c / 2;
1. input=[x1 y1;x2 y2;x3 y3;x4 y4;x5 y5];
1. q(j,4)=q(j,4)+1;
1. [tmp.x,tmp.z]=PolygonCentroid(input);
1. end
1. else
1. boundary1 = c * c /( tan(angle_t) * 2);
1. boundary2 = a * c - c * c /( tan(angle_t) * 2);
1. if s<=boundary1
1. x = sqrt(2 * s / tan(angle_t));
1. x1 = -a/2;
1. y1 = -c/2;
1. x2 = -a / 2;
1. y2 = x * tan(angle_t)-c/2;
1. x3 = x-a/2;
1. y3 = -c/2;
1. q(j,5)=q(j,5)+1;
1. tmp.x=(x1+x2+x3)/3;
1. tmp.z = (y1 + y2 + y3) / 3;
1. elseif s <= boundary2
1. x = s / c + c/(tan(angle_t) * 2);
1. x1 = -a / 2;
1. y1 = -c / 2;
1. x2 = x-a / 2;
1. y2 = -c / 2;
1. x3 = -a/2 + x -c/tan(angle_t);
1. y3 = c/2 ;
1. x4 = -a / 2;
1. y4 = c / 2;
1. q(j,6)=q(j,6)+1;
1. input=[x1 y1;x2 y2;x3 y3;x4 y4];
1. [tmp.x,tmp.z]=PolygonCentroid(input);
1. else
1. x = a-sqrt(2*(a*c-s)/tan(angle_t));
1. x1 = -a / 2;
1. y1 = -c / 2;
1. x2 = a / 2;
1. y2 = -c / 2;
1. x3 = a / 2;
1. y3 = c / 2 - (a-x)* tan(angle_t);
1. x4 = -a/2 +x;
1. y4 =c/2;



43
1. x5 = -a / 2;
1. y5 = c / 2;
1. q(j,7)=q(j,7)+1;
1. input=[x1 y1;x2 y2;x3 y3;x4 y4;x5 y5];
1. [tmp.x,tmp.z]=PolygonCentroid(input);
1. end
1. end
1. if angles(i)<0
1. tmp.x=-tmp.x;
1. tmp.z=tmp.z;
1. end
1. tmp.x=centerOffset(j,1)+tmp.x;
1. tmp.z=centerOffset(j,3)+tmp.z;
1. if i==66
1. watch(j)=tmp.z;
1. end
1. tmpCentroid.x=tmpCentroid.x+tmp.x*remainingOil(j)*850;
1. tmpCentroid.y=tmpCentroid.y+tmp.y*remainingOil(j)*850;
1. tmpCentroid.z=tmpCentroid.z+tmp.z*remainingOil(j)*850;
1. tmpWeight=tmpWeight+remainingOil(j)*850;
1. end
1. Centroid_0(i,1)=tmpCentroid.x/(tmpWeight+3000);
1. Centroid_0(i,2)=tmpCentroid.y/(tmpWeight+3000);
1. Centroid_0(i,3)=tmpCentroid.z/(tmpWeight+3000);
1. end
1. %plot(1:7200,Centroid_0(:,1),'r','LineWidth',2);
1. %hold on
1. %plot(1:7200,Centroid_0(:,2),'b','LineWidth',2);
1. %hold on
1. %plot(1:7200,Centroid_0(:,3),'g','LineWidth',2);
1. %legend('x 方向偏移','y 方向偏移','z 方向偏移');
1. %plot(1:7200,Absolute_no,'-k','LineWidth',2);
1. %set(gca,'FontSize',20);
1. %axis([0,8000,0,8e-5])
1. %xlabel('时间t(s)','fontsize',20);
1. %ylabel('实际质心与理想质心的偏移距离(m)','fontsize',20)
1. %[m,index]=max(Centroid_0);
1. res=zeros(7200,1);
1. for i=1:7200
1. res(i)=norm(Centroid_0(i,:));
1. end
1. [m,index]=max(res);
1. an=0;
1. for i=1:7200



44
1. an=Consume(i,2)+Consume(i,3)+Consume(i,4)+Consume(i,5)+an;
1. end
1. %plot(1:7200,Consume,'-b','LineWidth',2);
1. %xlabel('时间t(s)','fontsize',16);
1. %ylabel('各个供油曲线','fontsize',16)
1. figure(6)          % define figure
1. subplot(2,3,1);     % subplot(x,y,n)x 表示显示的行数，y 表示列数，n 表示第几幅
图片
1. plot(1:7200,Consume(:,1),'b');
1. hold on
1. xlabel('时间t(s)','fontsize',16);
1. ylabel('油箱1 供油速度(kg/s)','fontsize',16);
1. subplot(2,3,2);     % subplot(x,y,n)x 表示显示的行数，y 表示列数，n 表示第几幅
图片
1. plot(1:7200,Consume(:,2),'b');
1. hold on
1. xlabel('时间t(s)','fontsize',16);
1. ylabel('油箱2 供油速度(kg/s)','fontsize',16);
1.
1. subplot(2,3,3);     % subplot(x,y,n)x 表示显示的行数，y 表示列数，n 表示第几幅
图片
1. plot(1:7200,Consume(:,3),'b');
1. hold on
1. xlabel('时间t(s)','fontsize',16);
1. ylabel('油箱3 供油速度(kg/s)','fontsize',16);
1.
1. subplot(2,3,4);     % subplot(x,y,n)x 表示显示的行数，y 表示列数，n 表示第几幅
图片
1. plot(1:7200,Consume(:,4),'b');
1. hold on
1. xlabel('时间t(s)','fontsize',16);
1. ylabel('油箱4 供油速度(kg/s)','fontsize',16);
1. %
1. subplot(2,3,5);     % subplot(x,y,n)x 表示显示的行数，y 表示列数，n 表示第几幅
图片
1. plot(1:7200,Consume(:,5),'b');
1. hold on
1. xlabel('时间t(s)','fontsize',16);
1. ylabel('油箱5 供油速度(kg/s)','fontsize',16);
1. % subplot(2,3,6);     % subplot(x,y,n)x 表示显示的行数，y 表示列数，n 表示第几
幅图片
1. % plot(1:7200,Consume(:,6),'b');
1. % hold on
1. % xlabel('时间t(s)','fontsize',16);



45
1. % ylabel('油箱6 供油速度(kg/s)','fontsize',16);
1. function [x,z]=PolygonCentroid(input)
1. [count,~]=size(input);
1. totalArea =0;
1. totalTriangleCentroid.x=0;
1. totalTriangleCentroid.z=0;
1. for i=2:count-1
1. [temp,tempCentroid.x,tempCentroid.z]=TriangleCentroid(input(1,:),
input(i,:),input(i+1,:));
1. totalTriangleCentroid.x=tempCentroid.x*temp+totalTriangleCentroid
.x;
1. totalTriangleCentroid.z=tempCentroid.z*temp+totalTriangleCentroid
.z;
1. totalArea=totalArea+temp;
1. end
1. x=totalTriangleCentroid.x/totalArea;
1. z=totalTriangleCentroid.z/totalArea;
1. end
1. function [temp,x,z]=TriangleCentroid(input1,input2,input3)
1. x1=input2(1,1)-input1(1,1);
1. y1=input2(1,2)-input1(1,2);
1. x2=input3(1,1)-input1(1,1);
1. y2=input3(1,2)-input1(1,2);
1. temp = (x1 * y2 - x2 * y1) / 2;
1. x=(input1(1,1)+input2(1,1)+input3(1,1))/3;
1. z=(input1(1,2)+input2(1,2)+input3(1,2))/3;
1. end
# [C++代码]
1. #include<iostream>
1. #include<vector>
1. #include<math.h>
1. #include<unordered_map>
1. #include <fstream>
1. #include <cassert>
1. #include<string>
1.
1. using namespace std;
1.
1. #define PI 3.141592653589793
1. #define Density (double)850
1. #define netWeight (double)3000
1.



46
1. struct Vec2d
1. {
1. double x;
1. double y;
1. Vec2d(double a, double b) { x = a; y = b; };
1. Vec2d() { x = 0; y = 0; };
1. Vec2d operator-(const Vec2d& b)
1. {
1. Vec2d vec2d(0, 0);
1. vec2d.x = this->x - b.x;
1. vec2d.y = this->y - b.y;
1. return vec2d;
1. }
1. };
1.
1. //叉乘算三角形面积(有正负)，以及算三角形质心坐标
1. void  TriangleCentroid(Vec2d P1, Vec2d P2, Vec2d P3, double& area, Vec2d&
centroid)
1. {
1. Vec2d P12 = P2 - P1;
1. Vec2d P13 = P3 - P1;
1.
1. double x1 = P12.x;
1. double y1 = P12.y;
1.
1. double x2 = P13.x;
1. double y2 = P13.y;
1.
1.
1. //向量叉乘计算三角形面积
1. area = (x1 * y2 - x2 * y1) / 2;
1.
1. //计算三角形质心
1. centroid.x = (P1.x + P2.x + P3.x) / 3;
1. centroid.y = (P1.y + P2.y + P3.y) / 3;
1.
1. return;
1. }
1.
1. //计算质心坐标，多边形的顶点按顺序排列在数组中
1. bool PolygonCentroid(vector<Vec2d> Points, Vec2d& centroid)
1. {
1. int count = Points.size();
1.



47
1. //如果不是多边形，不计算
1. if (count < 3)
1. return false;
1.
1. //多边形总面积
1. double totalArea = 0;
1.
1. //n 边形划分成n-2 个三角形，每个三角形质心坐标与该三角形面积乘积之和
1. Vec2d totalTriangleCentroid(0, 0);
1.
1. //按顶点顺序，1,2,3；1,3,4；1,4,5；如此构建三角形
1. for (int i = 1; i < count - 1; i++)
1. {
1. double temp;
1. Vec2d tempCentroid(0, 0);
1.
1. //计算每个三角形的面积与质心坐标
1. TriangleCentroid(Points[0], Points[i], Points[i + 1], temp, tempCe
ntroid);
1.
1. totalTriangleCentroid.x += tempCentroid.x * temp;
1. totalTriangleCentroid.y += tempCentroid.y * temp;
1.
1. totalArea += temp;
1. }
1.
1.
1. //计算质心坐标
1. centroid.x = totalTriangleCentroid.x / totalArea;
1. centroid.y = totalTriangleCentroid.y / totalArea;
1.
1. return true;
1. }
1.
1. struct point
1. {
1. double x;
1. double y;
1. double z;
1. point(double a, double b, double c) { x = a; y = b; z = c; };
1. point() { x = 0; y = 0; z = 0; };
1. };
1.



48
1. unordered_map<int, point> centerOffset = { {1,{8.91304348,1.20652174,0.61
669004}},
1. {2,{6.91304348,-1.39347826,0.2
1669004}},
1. {3,{-1.68695652,1.20652174,-0.
28330996}},
1. {4,{3.11304348,0.60652174,-0.1
8330996}},
1. {5,{-5.28695652,-0.29347826,0.
41669004}},
1. {6,{-2.08695652,-1.49347826,0.
21669004}} };
1. unordered_map<int, point> sizeOffset = { {1,{1.5,0.9,0.3}},
1. {2,{2.2,0.8,1.1}},
1. {3,{2.4,1.1,0.9}},
1. {4,{1.7,1.3,1.2}},
1. {5,{2.4,1.2,1}},
1. {6,{2.4,1,0.5}} };
1. unordered_map<int,double> remainingOil={{1,0.3},{2,1.5},{3,2.1},{4,1.9},{
5,2.6},{6,0.8}};
1. void addOffset(int num, point& tmp, double angle) {
1. tmp.x = centerOffset[num].x +tmp.x;
1. tmp.z = centerOffset[num].z +tmp.z;
1. }
1. Vec2d coordinate(double angle, int num, double speed){
1. double a = sizeOffset[num].x;
1. double c = sizeOffset[num].z;
1. double radian = angle * PI / (double)180;
1. double s = remainingOil[num] / sizeOffset[num].y;
1. double angle_t = fabs(radian);
1.
1. Vec2d Centroid;
1.
1. if(angle==0){
1. double x=s/a;
1. Centroid.x = 0;
1. Centroid.y = -c / 2 + x / 2;
1. return Centroid;
1. }else if (angle_t < fabs(atan(c / a))) {
1. double boundary1 = a * a * tan(angle_t) / 2;
1. double boundary2 = a * c - a * a * tan(angle_t) / 2;
1. if (s <= boundary1) {
1. double x = pow(2 * s / tan(angle_t), 0.5);
1. double x1 = -a/2;



49
1. double y1 = -c/2;
1. double x2 = -a / 2;
1. double y2 = x * tan(angle_t)-c/2;
1. double x3 = x-a/2;
1. double y3 = -c/2;
1.
1. Centroid.x = (x1 + x2 + x3) / 3;
1. Centroid.y = (y1 + y2 + y3) / 3;
1.
1. }
1. else if (s <= boundary2) {
1. double x = s / a + a * tan(angle_t) / 2;
1. double x1 = -a / 2;
1. double y1 = -c / 2;
1. double x2 = a / 2;
1. double y2 = -c / 2;
1. double x3 = a / 2;
1. double y3 = -c/2 + x-a*tan(angle_t);
1. double x4 = -a / 2;
1. double y4 = x - c / 2;
1.
1. vector<Vec2d> Points = { {x1,y1},{x2,y2},{x3,y3},{x4,y4} };
1. PolygonCentroid(Points, Centroid);
1.
1. }
1. else {
1. double x = a-pow(2*(a*c-s)/tan(angle_t),0.5);
1. double x1 = -a / 2;
1. double y1 = -c / 2;
1. double x2 = a / 2;
1. double y2 = -c / 2;
1. double x3 = a / 2;
1. double y3 = c / 2 - (a-x)* tan(angle_t);
1. double x4 = -a/2 +x;
1. double y4 =c/2;
1. double x5 = -a / 2;
1. double y5 = c / 2;
1.
1. vector<Vec2d> Points = { {x1,y1},{x2,y2},{x3,y3},{x4,y4},{x5,
y5} };
1. PolygonCentroid(Points, Centroid);
1.
1. }
1.



50
1. }else
1. {
1. double boundary1 = c * c /( tan(angle_t) * 2);
1. double boundary2 = a * c - c * c /( tan(angle_t) * 2);
1. if (s <= boundary1) {
1. double x = pow(2 * s / tan(angle_t), 0.5);
1. double x1 = -a/2;
1. double y1 = -c/2;
1. double x2 = -a / 2;
1. double y2 = x * tan(angle_t)-c/2;
1. double x3 = x-a/2;
1. double y3 = -c/2;
1.
1. Centroid.x = (x1 + x2 + x3) / 3;
1. Centroid.y = (y1 + y2 + y3) / 3;
1. }
1. else if (s <= boundary2) {
1. double x = s / c + c/(tan(angle_t) * 2);
1. double x1 = -a / 2;
1. double y1 = -c / 2;
1. double x2 = x-a / 2;
1. double y2 = -c / 2;
1. double x3 = -a/2 + x -c/tan(angle_t);
1. double y3 = c/2 ;
1. double x4 = -a / 2;
1. double y4 = c / 2;
1.
1. vector<Vec2d> Points = { {x1,y1},{x2,y2},{x3,y3},{x4,y4} };
1. PolygonCentroid(Points, Centroid);
1.
1. }
1. else {
1. double x = a-pow(2*(a*c-s)/tan(angle_t),0.5);
1. double x1 = -a / 2;
1. double y1 = -c / 2;
1. double x2 = a / 2;
1. double y2 = -c / 2;
1. double x3 = a / 2;
1. double y3 = c / 2 - (a-x)* tan(angle_t);
1. double x4 = -a/2 +x;
1. double y4 =c/2;
1. double x5 = -a / 2;
1. double y5 = c / 2;
1.



51
1. vector<Vec2d> Points = { {x1,y1},{x2,y2},{x3,y3},{x4,y4},{x5,
y5} };
1. PolygonCentroid(Points, Centroid);
1. }
1. }
1. if(angle>0){
1. return Centroid;
1. }else
1. {
1. Centroid.x=-Centroid.x;
1. Centroid.y=Centroid.y;
1. return Centroid;
1. }
1.
1. }
1.
1. int main(void) {
1. vector<double> angles;
1. ifstream infile;
1. infile.open("D:\\math_data\\angle.txt");   //将文件流对象与文件连接起
来
1. assert(infile.is_open());   //若失败,则输出错误消息,并终止程序运行
1.
1. string s;
1. while(getline(infile,s))
1. {
1. angles.push_back(atof(s.c_str()));
1. }
1. infile.close();             //关闭文件输入流
1. unordered_map<int, vector<double>> Consume;
1. for (size_t i = 1; i < 7; i++)
1. {
1. ifstream infile;
1. infile.open("D:\\math_data\\data"+to_string(i)+".txt");   //将文件
流对象与文件连接起来
1. assert(infile.is_open());   //若失败,则输出错误消息,并终止程序运
行
1.
1. string s;
1. while(getline(infile,s))
1. {
1. Consume[i].push_back(atof(s.c_str()));
1. }
1. infile.close();             //关闭文件输入流



52
1. }
1.
1. vector<point> Centroid_s;
1. for (int i = 0; i < angles.size(); i++)
1. {
1. //计算剩余油量
1. for(int j=1;j<7;++j){
1. remainingOil[j]-=(Consume[j][i]/Density);
1. }
1. remainingOil[2]=remainingOil[2]+(Consume[1][i]/Density);
1. remainingOil[5]=remainingOil[5]+(Consume[6][i]/Density);
1. //计算质心
1. point tmpCentroid;
1. double tmpWeight=0;
1. for (size_t j = 1; j < 7; j++)
1. {
1. Vec2d centroid=coordinate(angles[i],j,Consume[j][i]);
1. point tmp(centroid.x,centerOffset[j].y,centroid.y);
1.
1. addOffset(j,tmp,angles[i]);
1. /*if (j == 1) {
1. ofstream ofs;
1. ofs.open("D:\\math_data\\Centroid2.txt", ios::app);
1. ofs << tmp.x <<endl;
1. //ofs << tmp.y << "    ";
1. //ofs << tmp.z << endl;
1.
1. ofs.close();
1. }*/
1. vector<double> watch;
1. watch.resize(6);
1. if (i == 66) {
1. watch[j - 1] = tmp.z;
1. cout << tmp.z << endl;
1. }
1. tmpCentroid.x+=tmp.x*remainingOil[j]* Density;
1. tmpCentroid.y+=tmp.y*remainingOil[j]* Density;
1. tmpCentroid.z+=tmp.z*remainingOil[j]* Density;
1. tmpWeight+=remainingOil[j]* Density;
1. }
1. tmpCentroid.x=tmpCentroid.x/(tmpWeight+netWeight);
1. tmpCentroid.y=tmpCentroid.y/(tmpWeight+netWeight);
1. tmpCentroid.z=tmpCentroid.z/(tmpWeight+netWeight);
1. Centroid_s.push_back(tmpCentroid);



53
1. }
1. {
1. ofstream ofs;
1. ofs.open("D:\\math_data\\out0.txt", ios::out);
1. for (size_t i = 0; i < Centroid_s.size(); i++)
1. {
1. ofs << Centroid_s[i].x<< endl;
1. }
1. ofs.close();
1.
1. ofs.open("D:\\math_data\\out1.txt", ios::out);
1. for (size_t i = 0; i < Centroid_s.size(); i++)
1. {
1. ofs << Centroid_s[i].y << endl;
1. }
1. ofs.close();
1.
1. ofs.open("D:\\math_data\\out2.txt", ios::out);
1. for (size_t i = 0; i < Centroid_s.size(); i++)
1. {
1. ofs << Centroid_s[i].z << endl;
1. }
1. ofs.close();
1. }
1. return 0;
1. }
问题二：
## [求解逐时间节点供油最优解的python 控制代码]
1. ## for dt = 1 without constrain of 60s
1.
1. import os
1. from glob import glob
1. import subprocess as sp
1. import sys
1. import openpyxl
1. import time
1. from tqdm import tqdm
1. class PowerShell:
1. # from scapy
1. def __init__(self, coding, ):
1. cmd = [self._where('PowerShell.exe'),
1. "-NoLogo", "-NonInteractive",  # Do not print headers
1. "-Command", "-"]  # Listen commands from stdin



54
1. startupinfo = sp.STARTUPINFO()
1. startupinfo.dwFlags |= sp.STARTF_USESHOWWINDOW
1. self.popen = sp.Popen(cmd, stdout=sp.PIPE, stdin=sp.PIPE, stderr=sp.STDOUT, sta
rtupinfo=startupinfo)
1. self.coding = coding
1.
1. def __enter__(self):
1. return self
1.
1. def __exit__(self, a, b, c):
1. self.popen.kill()
1.
1. def run(self, cmd, timeout=15):
1. b_cmd = cmd.encode(encoding=self.coding)
1. try:
1. b_outs, errs = self.popen.communicate(b_cmd, timeout=timeout)
1. except sp.TimeoutExpired:
1. self.popen.kill()
1. b_outs, errs = self.popen.communicate()
1. outs = b_outs.decode(encoding=self.coding)
1. return outs, errs
1.
1. @staticmethod
1. def _where(filename, dirs=None, env="PATH"):
1. """Find file in current dir, in deep_lookup cache or in system path"""
1. if dirs is None:
1. dirs = []
1. if not isinstance(dirs, list):
1. dirs = [dirs]
1. if glob(filename):
1. return filename
1. paths = [os.curdir] + os.environ[env].split(os.path.pathsep) + dirs
1. try:
1. return next(os.path.normpath(match)
1. for path in paths
1. for match in glob(os.path.join(path, filename))
1. if match)
1. except (StopIteration, RuntimeError):
1. raise IOError("File not found: %s" % filename)
1. class Fly:
1. def __init__(self):
1. self.tanks_location = [[8.91304348,1.20652174,0.61669004],
1. [6.91304348,-1.39347826,0.21669004],
1. [-1.68695652,1.20652174,-0.28330996],



55
1. [3.11304348,0.60652174,-0.18330996],
1. [-5.28695652,-0.29347826,0.41669004],
1. [-2.08695652,-1.49347826,0.21669004]]
1. self.tanks_size     = [[1.5, 0.9, 0.3],
1. [2.2, 0.8, 1.1],
1. [2.4,1.1,0.9],
1. [1.7,1.3,1.2],
1. [2.4,1.2,1],
1. [2.4,1,0.5]]
1. self.tanks_rest     = [0.3,1.5,2.1,1.9,2.6,0.8]
1. self.speed = [1.1, 1.8, 1.7, 1.5, 1.6, 1.1]
1. self.mess = 3000
1. self.density = 850
1.
1. def calEcomsume(self, comsume):
1. ecomsume = [0] * 6
1. for i in range(6):
1. ecomsume[i] = comsume[i]
1. ecomsume[1] -= comsume[0]
1. ecomsume[4] -= comsume[5]
1. return ecomsume
1.
1. def UpdateComsume(self,ecomsume,time):
1. for i in range(len(ecomsume)):
1. self.tanks_rest[i] -= ecomsume[i]*time / self.density
1. if self.tanks_rest[i] < 0 :
1. if abs(self.tanks_rest[i]) > 1e-5:
1. print("something wrong")
1. else:
1. self.tanks_rest[i] = 0
1.
1. def calC(self):
1. local = [0,0,0]
1. for i in range(6):
1. for j in range(2):
1. local[j] += self.tanks_rest[i] * self.density * self.tanks_location[i][
j]
1. for i in range(6):
1. j = 2
1. local[j] += self.tanks_rest[i] * self.density * (self.tanks_location[i][j]
- self.tanks_size[i][j]/2 +
1. self.tanks_rest[i] / (self.tanks_s
ize[i][0]*self.tanks_size[i][1]*2))
1. all_mess = self.mess



56
1. for i in range(6):
1. all_mess += self.tanks_rest[i] * self.density
1. return [x / all_mess for x in local]
1.
1. def writefile(location_t, last, demand, pnums=None):
1. reference = open('reference.lg4','r')
1. file_t = open('2.lg4', 'w')
1. ref_lines = reference.readlines()
1. for ref_line in ref_lines:
1. if len(ref_line.split()) == 0:
1. pass
1. elif ref_line.split()[0] ==  'LOCATION':
1. # print(location_t[0])
1. print('LOCATION = %s, %s, %s;' %(format(location_t[0],'.10e'),format(locat
ion_t[1],'.10e'),format(location_t[2],'.10e')), file=file_t)
1. elif ref_line.split()[0] == 'LAST':
1. print('LAST = %s, %s, %s, %s, %s, %s;' %(format(last[0],'.10e'),format(las
t[1],'.10e'),format(last[2],'.10e'),format(last[3],'.10e'),format(last[4],'.10e'),forma
t(last[5],'.10e')), file=file_t)
1. elif ref_line.split()[0] == 'DEMAND':
1. print('DEMAND = %s;' %(format(demand,'.10e')), file=file_t)
1. elif ref_line.split()[0] == 'enddata':
1. # for i in range(len(pnums)):
1. #     if pnums[i] != 0 and pnums[i] < 60:
1. #         print('PICKUP(%d) = 1;' %(i+1), file=file_t)
1. if pnums:
1. print('PICKUP ='+' '.join([str(pnum) for pnum in pnums])+';',file=file
_t)
1. print(ref_line,file=file_t)
1. else:
1. print(ref_line,file=file_t)
1. file_t.close()
1. reference.close()
1.
1. def readfile():
1. file = open('result_2.txt','r')
1. filelines = file.readlines()
1. comsume = []
1. for fileline in filelines:
1. if fileline.find('COMSUME') != -1:
1. if fileline.find('ECOMSUME') == -1:
1. comsume.append(float(fileline.split()[2]))
1. pickup = []
1. for fileline in filelines:



57
1. if fileline.find('PICKUP') != -1:
1. pickup.append(int(float(fileline.split()[2])))
1. return comsume, pickup
1.
1. def readexcel():
1. path = 'C:/Users/PaUlGuO/Desktop/model/team'
1. wb = openpyxl.load_workbook(path + '/附件3-问题2 数据.xlsx')
1. ws1 = wb[wb.sheetnames[0]]
1. ws2 = wb[wb.sheetnames[1]]
1. all_comsume = []
1. all_location = []
1. for v in ws1['B2':'B7201']:
1. all_comsume.append(v[0].value)
1. for i in range(2,7202):
1. tmp = []
1. for j in range(2,5):
1. tmp.append(ws2.cell(row=i, column=j).value)
1. all_location.append(tmp)
1. return all_comsume, all_location
1.
1. def process_bar(percent, start_str='', end_str='', total_length=0):
1. bar = ''.join(["\033[31m%s\033[0m"%'   '] * int(percent * total_length)) + ''
1. bar = '\r' + start_str + bar.ljust(total_length) + ' {:0>4.1f}%|'.format(percent*1
00) + end_str
1. print(bar, end='', flush=True)
1.
1. def opt():
1.
1. fly = Fly()
1.
1. all_comsume, all_location = readexcel()
1.
1. results = openpyxl.Workbook()
1. result = results.active
1.
1. for i in tqdm(range(len(all_location))):
1. # v1.0
1. # if i<=90:
1. #     pnums = None
1. # elif i <= 750:
1. #     pnums = [1,1,1,0,0,0]
1. # elif i <= 1000:
1. #     pnums = [1,1,0,0,1,0]
1. # elif i <= 1500:



58
1. #     pnums = [1,1,1,0,0,0]
1. # elif i <= 1904:
1. #     pnums = None
1. # elif i <= 3400:
1. #     pnums = [0,0,1,1,0,0]
1. # # elif i <= 4000:
1. # #     pnums = [0,0,1,0,1,0]
1. # else:
1. #     pnums = None
1.
1. # v2.0
1. if i <= 90:
1. pnums = None
1. elif i <= 380:
1. pnums = [0,1,0,0,0,0]
1. elif i <= 870:
1. pnums = [1,1,0,0,0,0]
1. elif i <= 1420:
1. pnums = [0,1,0,0,0,0]
1. elif i <= 2100:
1. pnums = [0,1,0,1,0,0]
1. elif i <= 2800:
1. pnums = [0,0,0,1,0,0]
1. elif i <= 3340:
1. pnums = [0,0,1,1,0,0]
1. elif i <= 3950:
1. pnums = [0,0,1,0,0,0]
1. elif i <= 5250:
1. pnums = [0,0,1,0,1,1]
1. else :
1. pnums = [0,0,0,0,1,1]
1.
1. if i > 6000:
1. continue
1.
1. writefile(all_location[i], [rest * fly.density for rest in fly.tanks_rest], al
l_comsume[i], pnums)
1.
1. with PowerShell('GBK') as ps:
1. outs, errs = ps.run('runlingo 2.ltf')
1.
1. comsume, pickup = readfile()
1.
1. for j in range(len(comsume)):



59
1. comsume[j] *= pickup[j]
1.
1. fly.UpdateComsume(fly.calEcomsume(comsume),1)
1.
1. result.append(comsume + all_location[i] + fly.calC())
1.
1. if i % 1000 == 0:
1. results.save('result2_%d.xlsx' %(i))
1.
1. results.save('result2.xlsx')
1.
1. if __name__ == '__main__':
1. # Example：
1.
1. opt()
1.
1. # print()
## [求解逐时间节点的供油最优解的LINGO 代码(样例)]
1. MODEL:
1. sets:
1. locations/1..3/:LOCATION;
1. comsumer/1..6/:COMSUME,PICKUP,SPEED,ECOMSUME,LAST,SUM,SUM_C;
1. shape/1..3/:SIZE;
1. links_1(comsumer,locations):BOXS_L,BOXS_C;
1. links_2(comsumer,shape):BOXS_S;
1. delta/1..3/:DL;
1. endsets
1.
1. MIN = @SUM(delta(I):DL(I)^2);
1. DL(1) = LOCATION(1) - @SUM(comsumer(I):(LAST(I)-ECOMSUME(I))*BOXS_L(I,1)/(@SUM(coms
umer(J):LAST(J)-ECOMSUME(J)) + MESS));
1. DL(2) = LOCATION(2) - @SUM(comsumer(I):(LAST(I)-ECOMSUME(I))*BOXS_L(I,2)/(@SUM(coms
umer(J):LAST(J)-ECOMSUME(J)) + MESS));
1. DL(3) = LOCATION(3) - @SUM(comsumer(I):(LAST(I)-ECOMSUME(I))*(BOXS_L(I,3) - BOXS_S(
I,3)/2 + (LAST(I)-ECOMSUME(I))/(DENSITY*BOXS_S(I,1)*BOXS_S(I,2)*2)))/(@SUM(comsumer(I):
LAST(I)-ECOMSUME(I))+MESS);
1.
1. @FOR(comsumer(I):LAST(I) >= ECOMSUME(I));
1. !DL(1) = LOCATION(1) - @SUM(comsumer(I):(LAST(I)-ECOMSUME(I))*BOXS_L(I,1)/(@SUM(com
sumer(J):LAST(J)) + MESS));
1. !DL(2) = LOCATION(2) - @SUM(comsumer(I):(LAST(I)-ECOMSUME(I))*BOXS_L(I,2)/(@SUM(com
sumer(J):LAST(J)) + MESS));



60
1. !DL(3) = LOCATION(3) - @SUM(comsumer(I):(LAST(I)-ECOMSUME(I))*(BOXS_L(I,3) - BOXS_S
(I,3)/2 + (LAST(I)-ECOMSUME(I))/(DENSITY*BOXS_S(I,1)*BOXS_S(I,2)*2)))/(@SUM(comsumer(I)
:LAST(I))+MESS);
1.
1. @FOR(comsumer(I)|I#NE#2 #AND# I#NE#5:
1. ECOMSUME(I) = COMSUME(I)*PICKUP(I));
1. ECOMSUME(2) = COMSUME(2)*PICKUP(2) - COMSUME(1)*PICKUP(1);
1. ECOMSUME(5) = COMSUME(5)*PICKUP(5) - COMSUME(6)*PICKUP(6);
1. @SUM(comsumer(I):PICKUP(I)) <= 3;
1. @SUM(comsumer(I)|I#GT#1 #AND# I#LT#6:PICKUP(I)) <= 2;
1. @FOR(comsumer(I):COMSUME(I)<=SPEED(I));
1. !@FOR(comsumer(I):COMSUME(I) = COMSUME(I)*PICKUP(I));
1. @SUM(comsumer(I)|I#GT#1 #AND# I#LT#6:COMSUME(I) * PICKUP(I)) >= DEMAND;
1. @SUM(comsumer(I)|I#GT#1 #AND# I#LT#6:COMSUME(I) * PICKUP(I)) <= 1.2 * DEMAND;
1. @FOR(comsumer(I):@BIN(PICKUP(I)));
1. @FOR(comsumer(I):@free(ECOMSUME(I)));
1. @FOR(delta(I):@free(DL(I)));
1.
1. data:
1. LOCATION = -0.000006423592, 0.0000012957, -0.000000478744;
1. SPEED = 1.1, 1.8, 1.7, 1.5, 1.6, 1.1;
1. DENSITY = 850;
1. BOXS_L =    8.91304348  1.20652174  0.61669004
1. 6.91304348 -1.39347826  0.21669004
1. -1.68695652  1.20652174 -0.28330996
1. 3.11304348  0.60652174 -0.18330996
1. -5.28695652 -0.29347826  0.41669004
1. -2.08695652 -1.49347826  0.21669004;
## 45.         BOXS_S =    1.5 0.9 0.3
1. 2.2 0.8 1.1
1. 2.4 1.1 0.9
1. 1.7 1.3 1.2
1. 2.4 1.2 1
1. 2.4 1   0.5;
1. LAST = 255, 1275, 1785, 1615, 2210, 680;
1. MESS = 3000;
1. DEMAND = 0.0100558899754559;
1. enddata
1. end
问题3：
## [剩余油量求解的LINGO 代码(样例)]
1. MODEL:
1.



61
1. sets:
1.
1. locations/1..3/:LOCATION2,LOCATION0,LOCATION1;
1.
1. comsumer/1..6/:CAPACITY,VOLUME,VOLUME_C1,VOLUME_C2,CHARGE1,CHARGE2;
1.
1. shape/1..3/:SIZE;
1.
1. links_1(comsumer,locations):BOXS_L,BOXS_C;
1.
1. links_2(comsumer,shape):BOXS_S;
1.
1. delta/1..3/:DL2,DL0,DL1;
1.
1. endsets
1.
1. !MIN = @SUM(delta(I):DL2(I)^2 + DL0(I)^2 + DL1(I)^2);
1. MIN = @SMAX(@SUM(delta(I):DL1(I)^2),@SUM(delta(I):DL0(I)^2),@SUM(delta(I):DL2(I)^2)
);
1.
1. DL2(1) = LOCATION2(1) - @SUM(comsumer(I):VOLUME_C2(I)*BOXS_L(I,1))/(MESS + @SUM(com
sumer(I)|I#GT#1 #AND# I#LT#6:CHARGE2(I)));
1. DL2(2) = LOCATION2(2) - @SUM(comsumer(I):VOLUME_C2(I)*BOXS_L(I,2))/(MESS + @SUM(com
sumer(I)|I#GT#1 #AND# I#LT#6:CHARGE2(I)));
1. DL2(3) = LOCATION2(3) - @SUM(comsumer(I):VOLUME_C2(I)*(BOXS_L(I,3) - BOXS_S(I,3)/2
+ VOLUME_C2(I)/(DENSITY*BOXS_S(I,1)*BOXS_S(I,2)*2)))/(MESS + @SUM(comsumer(I)|I#GT#1 #A
ND# I#LT#6:CHARGE2(I)));
1.
1. DL0(1) = LOCATION0(1) - @SUM(comsumer(I):VOLUME(I)*BOXS_L(I,1))/MESS;
1. DL0(2) = LOCATION0(2) - @SUM(comsumer(I):VOLUME(I)*BOXS_L(I,2))/MESS;
1. DL0(3) = LOCATION0(3) - @SUM(comsumer(I):VOLUME(I)*(BOXS_L(I,3) - BOXS_S(I,3)/2 + V
OLUME(I)/(DENSITY*BOXS_S(I,1)*BOXS_S(I,2)*2)))/MESS;
1.
1. DL1(1) = LOCATION1(1) - @SUM(comsumer(I):VOLUME_C1(I)*BOXS_L(I,1))/(MESS + @SUM(com
sumer(I)|I#GT#1 #AND# I#LT#6:CHARGE1(I)));
1. DL1(2) = LOCATION1(2) - @SUM(comsumer(I):VOLUME_C1(I)*BOXS_L(I,2))/(MESS + @SUM(com
sumer(I)|I#GT#1 #AND# I#LT#6:CHARGE1(I)));
1. DL1(3) = LOCATION1(3) - @SUM(comsumer(I):VOLUME_C1(I)*(BOXS_L(I,3) - BOXS_S(I,3)/2
+ VOLUME_C1(I)/(DENSITY*BOXS_S(I,1)*BOXS_S(I,2)*2)))/(MESS + @SUM(comsumer(I)|I#GT#1 #A
ND# I#LT#6:CHARGE1(I)));
1.
1. @FOR(comsumer(I):VOLUME_C1(I) <= CAPACITY(I));
1. @FOR(comsumer(I):VOLUME_C2(I) <= CAPACITY(I));
1. @FOR(comsumer(I):CAPACITY(I) = DENSITY*BOXS_S(I,1)*BOXS_S(I,2)*BOXS_S(I,3));



62
1. @SUM(comsumer(I):VOLUME(I)) = 850 ;
1. @FOR(comsumer(I):VOLUME_C1(I) = VOLUME(I) + CHARGE1(I));
1. @FOR(comsumer(I):VOLUME_C2(I) = VOLUME(I) + CHARGE2(I));
1.
1. @FOR(delta(I):@free(DL1(I)));
1. @FOR(delta(I):@free(DL0(I)));
1. @FOR(delta(I):@free(DL2(I)));
1.
1. data:
1.
1. LOCATION0  = -0.269845557421, -0.134439076516, -0.08153096928;
1. LOCATION1 = -0.269842576744, -0.134441897023, -0.081529893624;
1. LOCATION2 = -0.284694621466, -0.120387944621, -0.120387944621;
1.
1. DENSITY = 850;
1.
1. BOXS_L =    8.91304348  1.20652174  0.61669004
1.
1. 6.91304348 -1.39347826  0.21669004
1.
1. -1.68695652  1.20652174 -0.28330996
1.
1. 3.11304348  0.60652174 -0.18330996
1.
1. -5.28695652 -0.29347826  0.41669004
1.
1. -2.08695652 -1.49347826  0.21669004;
1.
## 65.         BOXS_S =    1.5 0.9 0.3
1.
1. 2.2 0.8 1.1
1.
1. 2.4 1.1 0.9
1.
1. 1.7 1.3 1.2
1.
1. 2.4 1.2 1
1.
1. 2.4 1   0.5;
1.
1. MESS = 3850;
1. CHARGE1 = 0,0,0,0,0.01,0;
1. CHARGE2 = 0,0,59.1289426,0,1.29753213,15.7803228;
1. enddata



63
1.
1. end

## [反向求解逐时间节点供油最优解的LINGO 代码]
1. MODEL:
1. sets:
1. locations/1..3/:LOCATION;
1. comsumer/1..6/:COMSUME,PICKUP,SPEED,ECOMSUME,LAST,SUM,SUM_C;
1. shape/1..3/:SIZE;
1. links_1(comsumer,locations):BOXS_L,BOXS_C;
1. links_2(comsumer,shape):BOXS_S;
1. delta/1..3/:DL;
1. endsets
1.
1. MIN = @SUM(delta(I):DL(I)^2);
1. DL(1) = LOCATION(1) - @SUM(comsumer(I):(LAST(I)+ECOMSUME(I))*BOXS_L(I,1)/(@SUM(coms
umer(J):LAST(J)+ECOMSUME(J)) + MESS));
1. DL(2) = LOCATION(2) - @SUM(comsumer(I):(LAST(I)+ECOMSUME(I))*BOXS_L(I,2)/(@SUM(coms
umer(J):LAST(J)+ECOMSUME(J)) + MESS));
1. DL(3) = LOCATION(3) - @SUM(comsumer(I):(LAST(I)+ECOMSUME(I))*(BOXS_L(I,3) - BOXS_S(
I,3)/2 + (LAST(I)+ECOMSUME(I))/(DENSITY*BOXS_S(I,1)*BOXS_S(I,2)*2)))/(@SUM(comsumer(I):
LAST(I)+ECOMSUME(I))+MESS);
1.
1. @FOR(comsumer(I)|I#NE#2 #AND# I#NE#5:
1. ECOMSUME(I) = COMSUME(I)*PICKUP(I));
1. ECOMSUME(2) = COMSUME(2)*PICKUP(2) - COMSUME(1)*PICKUP(1);
1. ECOMSUME(5) = COMSUME(5)*PICKUP(5) - COMSUME(6)*PICKUP(6);
1. @SUM(comsumer(I):PICKUP(I)) <= 3;
1. @SUM(comsumer(I)|I#GT#1 #AND# I#LT#6:PICKUP(I)) <= 2;
1. @FOR(comsumer(I):COMSUME(I)<=SPEED(I));
1. @FOR(comsumer(I):COMSUME(I) = COMSUME(I)*PICKUP(I));
1. @SUM(comsumer(I)|I#GT#1 #AND# I#LT#6:COMSUME(I) * PICKUP(I)) >= DEMAND;
1. @SUM(comsumer(I)|I#GT#1 #AND# I#LT#6:COMSUME(I) * PICKUP(I)) <= DEMAND;
1. @FOR(comsumer(I):@BIN(PICKUP(I)));
1. @FOR(comsumer(I):@free(ECOMSUME(I)));
1. @FOR(delta(I):@free(DL(I)));
1. @FOR(comsumer(I):LAST(I) + ECOMSUME(I) >=0);
1. @FOR(comsumer(I):LAST(I) + ECOMSUME(I) <= DENSITY*BOXS_S(I,1)*BOXS_S(I,2)*BOXS_S(I,
3));
1. data:
1. LOCATION = -0.000006423592, 0.0000012957, -0.000000478744;
1. SPEED = 1.1, 1.8, 1.7, 1.5, 1.6, 1.1;
1. DENSITY = 850;



64
1. BOXS_L =    8.91304348  1.20652174  0.61669004
1. 6.91304348 -1.39347826  0.21669004
1. -1.68695652  1.20652174 -0.28330996
1. 3.11304348  0.60652174 -0.18330996
1. -5.28695652 -0.29347826  0.41669004
1. -2.08695652 -1.49347826  0.21669004;
## 41.         BOXS_S =    1.5 0.9 0.3
1. 2.2 0.8 1.1
1. 2.4 1.1 0.9
1. 1.7 1.3 1.2
1. 2.4 1.2 1
1. 2.4 1   0.5;
1. LAST = 255, 1275, 1785, 1615, 2210, 680;
1. MESS = 3000;
1. DEMAND = 0.0100558899754559;
1. enddata
1. end
## [反向求解逐时间节点供油最优解的python 控制代码]
1. ## for dt = 1 without constrain of 60s
1.
1. import os
1. from glob import glob
1. import subprocess as sp
1. import sys
1. import openpyxl
1. import time
1. from tqdm import tqdm
1. class PowerShell:
1. # from scapy
1. def __init__(self, coding, ):
1. cmd = [self._where('PowerShell.exe'),
1. "-NoLogo", "-NonInteractive",  # Do not print headers
1. "-Command", "-"]  # Listen commands from stdin
1. startupinfo = sp.STARTUPINFO()
1. startupinfo.dwFlags |= sp.STARTF_USESHOWWINDOW
1. self.popen = sp.Popen(cmd, stdout=sp.PIPE, stdin=sp.PIPE, stderr=sp.STDOUT, sta
rtupinfo=startupinfo)
1. self.coding = coding
1.
1. def __enter__(self):
1. return self
1.
1. def __exit__(self, a, b, c):



65
1. self.popen.kill()
1.
1. def run(self, cmd, timeout=15):
1. b_cmd = cmd.encode(encoding=self.coding)
1. try:
1. b_outs, errs = self.popen.communicate(b_cmd, timeout=timeout)
1. except sp.TimeoutExpired:
1. self.popen.kill()
1. b_outs, errs = self.popen.communicate()
1. outs = b_outs.decode(encoding=self.coding)
1. return outs, errs
1.
1. @staticmethod
1. def _where(filename, dirs=None, env="PATH"):
1. """Find file in current dir, in deep_lookup cache or in system path"""
1. if dirs is None:
1. dirs = []
1. if not isinstance(dirs, list):
1. dirs = [dirs]
1. if glob(filename):
1. return filename
1. paths = [os.curdir] + os.environ[env].split(os.path.pathsep) + dirs
1. try:
1. return next(os.path.normpath(match)
1. for path in paths
1. for match in glob(os.path.join(path, filename))
1. if match)
1. except (StopIteration, RuntimeError):
1. raise IOError("File not found: %s" % filename)
1. class Fly:
1. def __init__(self):
1. self.tanks_location = [[8.91304348,1.20652174,0.61669004],
1. [6.91304348,-1.39347826,0.21669004],
1. [-1.68695652,1.20652174,-0.28330996],
1. [3.11304348,0.60652174,-0.18330996],
1. [-5.28695652,-0.29347826,0.41669004],
1. [-2.08695652,-1.49347826,0.21669004]]
1. self.tanks_size     = [[1.5, 0.9, 0.3],
1. [2.2, 0.8, 1.1],
1. [2.4,1.1,0.9],
1. [1.7,1.3,1.2],
1. [2.4,1.2,1],
1. [2.4,1,0.5]]
1. self.tanks_rest     = [0.3,1.5,2.1,1.9,2.6,0.8]



66
1. self.speed = [1.1, 1.8, 1.7, 1.5, 1.6, 1.1]
1. self.mess = 3000
1. self.density = 850
1. self.volume = []
1. for i in range(6):
1. v = 1
1. for j in range(3):
1. v *= self.tanks_size[i][j]
1. self.volume.append(v)
1.
1. def calEcomsume(self, comsume):
1. ecomsume = [0] * 6
1. for i in range(6):
1. ecomsume[i] = comsume[i]
1. ecomsume[1] -= comsume[0]
1. ecomsume[4] -= comsume[5]
1. return ecomsume
1.
1. def UpdateComsume(self,ecomsume,time):
1. rets = [False] * 6
1. for i in range(len(ecomsume)):
1. self.tanks_rest[i] -= ecomsume[i]*time / self.density
1. if self.tanks_rest[i] < 0 :
1. if abs(self.tanks_rest[i]) > 1e-5:
1. # print("something wrong")
1. self.tanks_rest[i] = 0
1. rets[i] = True
1. else:
1. self.tanks_rest[i] = 0
1. return rets
1.
1. def UpdataCharge(self,ecomsume,time):
1. rets = [False] * 6
1. for i in range(len(ecomsume)):
1. self.tanks_rest[i] += ecomsume[i] * time / self.density
1. if self.tanks_rest[i] > self.volume[i]:
1. rets[i] = True
1. return rets
1.
1. def UpdateRest(self,init_r):
1. for i in range(len(init_r)):
1. self.tanks_rest[i] = init_r[i] / self.density
1. # self.tanks_rest[i] = init_r[i]
1.



67
1. def calC(self):
1. local = [0,0,0]
1. for i in range(6):
1. for j in range(2):
1. local[j] += self.tanks_rest[i] * self.density * self.tanks_location[i]
[j]
1. for i in range(6):
1. j = 2
1. local[j] += self.tanks_rest[i] * self.density * (self.tanks_location[i][j]
- self.tanks_size[i][j]/2 +
1. self.tanks_rest[i] / (self.tanks_
size[i][0]*self.tanks_size[i][1]*2))
1. all_mess = self.mess
1. for i in range(6):
1. all_mess += self.tanks_rest[i] * self.density
1. return [x / all_mess for x in local]
1.
1. def writefile(location_t, last, demand, pnums=None):
1. reference = open('reference3.lg4','r')
1. file_t = open('3.lg4', 'w')
1. ref_lines = reference.readlines()
1. for ref_line in ref_lines:
1. if len(ref_line.split()) == 0:
1. pass
1. elif ref_line.split()[0] ==  'LOCATION':
1. # print(location_t[0])
1. print('LOCATION = %s, %s, %s;' %(format(location_t[0],'.10e'),format(locat
ion_t[1],'.10e'),format(location_t[2],'.10e')), file=file_t)
1. elif ref_line.split()[0] == 'LAST':
1. print('LAST = %s, %s, %s, %s, %s, %s;' %(format(last[0],'.10e'),format(las
t[1],'.10e'),format(last[2],'.10e'),format(last[3],'.10e'),format(last[4],'.10e'),forma
t(last[5],'.10e')), file=file_t)
1. elif ref_line.split()[0] == 'DEMAND':
1. print('DEMAND = %s;' %(format(demand,'.10e')), file=file_t)
1. elif ref_line.split()[0] == 'enddata':
1. # for i in range(len(pnums)):
1. #     if pnums[i] != 0 and pnums[i] < 60:
1. #         print('PICKUP(%d) = 1;' %(i+1), file=file_t)
1. if pnums:
1. print('PICKUP ='+' '.join([str(pnum) for pnum in pnums])+';',file=file
_t)
1. print(ref_line,file=file_t)
1. # elif ref_line.split()[0] == '@FOR(delta(I):@free(DL(I)));':
1. #     print(ref_line,file=file_t)



68
1. #     for i in range(len(present)):
1. #         if present[i] == init_l[i]:
1. #             print('LAST(%d) >= ECOMSUME(%d);'%(i+1,i+1),file = file_t)
1. else:
1. print(ref_line,file=file_t)
1. file_t.close()
1. reference.close()
1.
1. def writeref(present):
1. reference = open('initial_3_ref.lg4','r')
1. file_t = open('initial_3.lg4', 'w')
1. ref_lines = reference.readlines()
1. for ref_line in ref_lines:
1. if len(ref_line.split()) == 0:
1. pass
1. elif ref_line.split()[0] == '@FOR(comsumer(I):VOLUME(I)':
1. print(ref_line,file=file_t)
1. for i in range(1,7):
1. print('VOLUME(%d) >= %f * CAPACITY(%d);'%(i,present[i-1],i),file=file_
*
1. else:
1. print(ref_line,file=file_t)
1. reference.close()
1. file_t.close()
1.
1. def readfile():
1. file = open('result_3.txt','r')
1. filelines = file.readlines()
1. comsume = []
1. for fileline in filelines:
1. if fileline.find('COMSUME') != -1:
1. if fileline.find('ECOMSUME') == -1:
1. comsume.append(float(fileline.split()[2]))
1. pickup = []
1. for fileline in filelines:
1. if fileline.find('PICKUP') != -1:
1. pickup.append(int(float(fileline.split()[2])))
1. return comsume, pickup
1.
1. def readref():
1. file = open('initial_3.txt','r')
1. filelines = file.readlines()
1. volume = []
1. for fileline in filelines:



69
1. if fileline.find('VOLUME') != -1:
1. volume.append(float(fileline.split()[2]))
1. return volume
1.
1. def readexcel():
1. path = 'C:/Users/PaUlGuO/Desktop/model/team'
1. wb = openpyxl.load_workbook(path + '/附件4-问题3 数据.xlsx')
1. ws1 = wb[wb.sheetnames[0]]
1. ws2 = wb[wb.sheetnames[1]]
1. all_comsume = []
1. all_location = []
1. for v in ws1['B2':'B7201']:
1. all_comsume.append(v[0].value)
1. for i in range(2,7202):
1. tmp = []
1. for j in range(2,5):
1. tmp.append(ws2.cell(row=i, column=j).value)
1. all_location.append(tmp)
1. return all_comsume, all_location
1.
1. def process_bar(percent, start_str='', end_str='', total_length=0):
1. bar = ''.join(["\033[31m%s\033[0m"%'   '] * int(percent * total_length)) + ''
1. bar = '\r' + start_str + bar.ljust(total_length) + ' {:0>4.1f}%|'.format(percent*1
00) + end_str
1. print(bar, end='', flush=True)
1.
1. def opt():
1.
1. fly = Fly()
1.
1. all_comsume, all_location = readexcel()
1.
1. all_comsume.reverse()
1. all_location.reverse()
1.
1. # holdon = [False] * 6
1. init_l = [0.0] * 6
1. # init_r = [1.0] * 6
1.
1. for iter in range(1):
1.
1. # present = [(init_r[i] + init_l[i]) / 2 if holdon[i] else 0.0 for i in range(
len(init_l))]
1.



70
1. # for i in range(1,len(present)-1):
1. #     if present[i] >= 0.97:
1. #         present[i] = 1.0
1. #         init_l[i] = 1.0
1. #         init_r[i] = 1.0
1.
1. print('********iter %d*********' %(iter+1))
1.
1. # print(init_l)
1. # print(init_r)
1. # print(present)
1.
1. # present_r = solve_init(holdon, init_r)
1. # f = open('init_3.txt','a')
1. # print('********iter %d*********' %(i+1),file = f)
1. # print(' '.join([str(r) for r in present_r]), file = f)
1. # f.close()
1.
1. results = openpyxl.Workbook()
1. result = results.active
1.
1. # init_r = [0,54,137,111,120,428]
1. # init_r = [0,0.063975118,0.188441394,0.133738096,0.1428346,0.503529412]
1. # init_r = [287.0330, 1159.560, 1077.014, 2253.213, 2194.129, 684.0513]
1. # init_r = [344.2500, 1640.684, 1911.173, 1156.975, 2066.856, 535.0624]
1. # writeref(init_l) ##
1. # with PowerShell('GBK') as ps:
1. #     outs, errs = ps.run('runlingo 3_ref.ltf')
1. # init_rest = readref()
1. # init_rest = [0.0,48.09765,147.5565,118.8232,115.1304,420.3923]
1. # init_rest = [0.0,48.62045,149.6112,119.3313,109.5266,422.9104]
1. init_rest = [0.0,47.18759,131.5116,144.8741,130.9014,395.5253]
1. fly.UpdateRest(init_rest)
1.
1. maxx = 0
1. # print(present)
1. for i in tqdm(range(len(all_location)-1)):
1.
1. if all_comsume[i] == 0:
1. result.append([i+1])
1. continue
1.
1. else:
1. pnums = None



71
1. # print('halo')
1. # pnums = None
1. # writefile(all_location[94], [rest * fly.density for rest in fly.tanks_re
st], all_comsume[94], [0]*6 )
1. writefile(all_location[i+1], [rest * fly.density for rest in fly.tanks_res
t], all_comsume[i], pnums)
1.
1. # print(i + 1)
1.
1. with PowerShell('GBK') as ps:
1. outs, errs = ps.run('runlingo 3.ltf')
1.
1. comsume, pickup = readfile()
1.
1. if len(comsume) == 0:
1. break
1.
1. for j in range(len(comsume)):
1. comsume[j] *= pickup[j]
1.
1. rets = fly.UpdataCharge(fly.calEcomsume(comsume),1)
1.
1. result.append([i+1] + comsume + all_location[i+1] + fly.calC() + fly.tanks
_rest)
1.
1. C1 = fly.calC()
1. C0 = all_location[i+1]
1. tmp = 0
1.
1. for k in range(len(C1)):
1. tmp += (C1[k] - C0[k]) ** 2
1.
1. maxx = max(tmp,maxx)
1. # if tmp > 0.05 : ## 质心偏移上限
1. #     break
1.
1. # if True in rets:
1.
1. #     break
1.
1. results.save('result3_%d_last.xlsx' %(iter+1))
1. # log = open('log.txt','a')
1. # print('********* iter %d *********' %(iter+1), file = log)
1. # print(rets, file= log)



72
1. # print('present constraint', file = log)
1. # print(present, file = log)
1. # log.close()
1. # if True not in rets: ## 二分思路
1. #     for i in range(len(present)):
1. #         init_r[i] = (init_r[i] + present[i]) / 2.0
1. # else:
1. #     for i in range(len(rets)):
1. #         if rets[i]:
1. #             if init_l[i] == 1.0 :
1. #                 print('there is something wrong')
1. #                 break
1. #             init_l[i] = present[i]
1. #             used[i] = True
1. #         else:
1. #             if used[i]:
1. #                 init_l[i] = (present[i] + init_l[i]) - init_r[i]
1. #                 used[i] = False
1. # for i in range(len(init_r)):
1. #     if abs(init_r[i] - init_l[i]) < 0.001:
1. #         init_r[i] = init_l[i]
1. print(i)
1.
1. print(maxx)
1.
1. if __name__ == '__main__':
1. # Example：
1.
1. opt()
1.
1. # print()
问题4：
[基于60s 时间段的供油最优策略matlab 代码]
1. clc
1. clear
1. warning off
1. [consume]=xlsread('C:\Users\PaUlGuO\Desktop\model\team\附件5-问题4 数
据.xlsx',1,'B2:B7201');
1. [angle]=xlsread('C:\Users\PaUlGuO\Desktop\model\team\附件5-问题4 数
据.xlsx',2,'B2:B7201');
1. %final = ones(7200,1);
1. fv = zeros(7200,6);
1. At = [1e20,1e20,0,1e20,1e20,1e20;



73
1. 1e20,1e20,1e20,0,1e20,1e20;
1. 1e20,1e20,1e20,1e20,0,1e20;
1. 1e20,0,1e20,1e20,1e20,1e20;
1. 0,0,1e20,1e20,1e20,1e20;
1. 1e20,0,1e20,1e20,1e20,0;
1. 0,0,1e20,1e20,1e20,0;
1. 0,1e20,0,1e20,1e20,1e20;
1. 0,1e20,0,1e20,1e20,0;
1. 1e20,1e20,0,1e20,1e20,0;
1. 1e20,1e20,1e20,0,1e20,0;
1. 0,1e20,1e20,0,1e20,0;
1. 0,1e20,1e20,0,1e20,1e20;
1. 1e20,1e20,1e20,1e20,0,0;
1. 0,1e20,1e20,1e20,0,1e20;
1. 0,1e20,1e20,1e20,0,0;
1. 1e20,0,0,1e20,1e20,1e20;
1. 1e20,0,1e20,0,1e20,1e20;
1. 1e20,0,1e20,1e20,0,1e20;
1. 1e20,1e20,0,0,1e20,1e20;
1. 1e20,1e20,0,1e20,0,1e20;
1. 1e20,1e20,1e20,0,0,1e20;
1. 0,0,0,1e20,1e20,1e20;
1. 0,0,1e20,0,1e20,1e20;
1. 0,0,1e20,1e20,0,1e20;
1. 0,1e20,0,0,1e20,1e20;
1. 0,1e20,0,1e20,0,1e20;
1. 0,1e20,1e20,0,0,1e20;
1. 1e20,0,0,1e20,1e20,0;
1. 1e20,0,1e20,0,1e20,0;
1. 1e20,0,1e20,1e20,0,0;
1. 1e20,1e20,0,0,1e20,0;
1. 1e20,1e20,0,1e20,0,0;
1. 1e20,1e20,1e20,0,0,0;
1. ];
1. %last = [255, 1275, 1785, 1615, 2210, 680];
1. %last = [255,1275,1.522511111320173e+03,1.428100874944118e+03,2.281296163866746e+03,3.7
53451648073769e+02];
1. %last = [2.206478555793609e+02,1.036794773504075e+03,1.214321966570699e+03,19.219643564
536412,1.353997304699008e+03,1.914292078186719e-07];
1. %last = [2.206478555793609e+02,5.278026909538892e+02,6.217837833712356e+02,19.219643564
536412,9.947898160819083e+02,1.914292078186719e-07];
1. %last = [2.206478555793609e+02,2.356128425237355e+02,2.018039531832358e+02,19.219643564
536412,6.789007305804507e+02,1.914292078186719e-07];



74
1. last = [1.768987624794272e+02,1.350202177198442e+02,40.453142352864720,19.2196435645364
12,4.976543986285903e+02,1.914292078186719e-07];
1. Beq = 0;
1. v0 = [0,0,0,0,0,0];
1. LB = [0,0,0,0,0,0];
1. UB0 = [1.1,1.8,1.7,1.5,1.6,1.1];
1. UB = [1.1,1.8,1.7,1.5,1.6,1.1];
1. for n=1:6
1. UB(n) = min(last(n),UB0(n));
1. end
1. A = [0,-1,-1,-1,-1,0;0,1,1,1,1,0];
1. options = optimset('TolX',1e-8,'TolFun',1e-8, 'MaxIter', 100, 'MaxFunEvals',1000,'diffm
inchange', 1e-10);
1. for j=0:60:6000
1. dissum = zeros(34:1);%用来记录每种方案的距离和
1. vtmp = zeros(34,60,6);%用来记录每种方案每秒6 个油箱的供油速度
1. for i=1:1:34
1. lasttmp = last;
1. Aeq = At(i,:);
1. distmp = zeros(60,1);%用来记录每种情况60 秒的距离
1. for k=1:60
1. B = [-1*consume(k+j-1);consume(k+j-1)*1];
1. [vt, dis] = fmincon(@(v)ques4sol(v,lasttmp,angle(k+j-1)),v0,A,B,Aeq,Beq,LB,
UB,'ques2cons',options);
1. %             if sum(vt)<consume(k+j-1)
1. %                 dissum(i) = 100;
1. %                 break;
1. %             end
1. for m=1:6
1. if vt(m)<1e-7
1. vt(m) = 0;
1. end
1. end
1. vtmp(i,k,:)=vt;
1. distmp(k,1)=dis;
1. lasttmp = lasttmp - vt;
1. lasttmp(2) = lasttmp(2) + vt(1);
1. lasttmp(5) = lasttmp(5) + vt(6);
1. for n=1:6
1. UB(n) = min(lasttmp(n),UB0(n));
1. end
1. end
1. dissum(i,1) = sum(sum(distmp));
1. end



75
1. [p,q] = min(dissum);
1. %final(j:j+59) = ;
1. fv(j:j+59,:) = vtmp(q,:,:);
1. last = last - sum(fv(j:j+59,:));
1. last(2) = last(2) + sum(fv(j:j+59,1));
1. last(5) = last(5) + sum(fv(j:j+59,6));
1. for n=1:6
1. UB(n) = min(last(n),UB0(n));
1. end
1. end
[目标函数]
1. function f4 = ques4sol(v,last,theta)
1. last(2) = last(2)+v(1);
1. last(5) = last(5)+v(6);
1. last = last - v;
1. x = qiuzhixin(last/850, theta);
1. f4 = x(1,1)^2 + x(1,2)^2 + x(1,3)^2;
1. end

