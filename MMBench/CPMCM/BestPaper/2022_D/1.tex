\begin{center}
\includegraphics[width=0.2\textwidth]{image1.png} \quad
\includegraphics[width=0.2\textwidth]{image2.png} \quad
\includegraphics[width=0.2\textwidth]{image3.png} \quad
\includegraphics[width=0.2\textwidth]{image4.png}
\end{center}

\begin{center}
\textbf{中国研究生创新实践系列大赛} \\
\textbf{中国光谷·“华为杯”第十九届中国研究生} \\
\textbf{数学建模竞赛}
\end{center}

\begin{table}[h]
\centering
\begin{tabular}{ll}
学 校 & 南京邮电大学 \\
\hline
参赛队号 & 22102930009 \\
\hline
队员姓名 & 1. 缪如洋 \\
& 2. 徐声健 \\
& 3. 陈凯伦 \\
\end{tabular}
\end{table}

\begin{center}
\textbf{中国研究生创新实践系列大赛}\\
\textbf{中国光谷·“华为杯”第十九届中国研究生}\\
\textbf{数学建模竞赛}
\end{center}

\begin{flushleft}
题目 \quad PISA 架构芯片资源排布问题
\end{flushleft}

\begin{center}
\textbf{摘 \quad 要：}
\end{center}

可编程的交换芯片架构 PISA（Protocol Independent Switch Architecture）相较于传统固定性能的交换芯片，其大大提高了研发效率，同时性能不输传统固定性能的交换芯片，有广阔的应用前景。本文针对 PISA 架构的多级报文流水线处理部分提出优化方案，首先对数据进行预处理，得到数据依赖、控制依赖及资源约束查询表，基于贪婪—遗传算法的思想，建立基本块排布优化模型，并针对这一多约束的组合优化问题设计出对应的求解算法，结果表明所设计的算法是有效的，具体问题的解决方案如下所述。

对于问题一，基于贪婪的思想，在最大化本级资源利用率以及最小化整体排布总级数的情况下，考虑数据依赖约束、控制依赖约束及资源约束建立 0-1 整数规划模型，送入遗传算法进行求解，求解出的最优基本块排布级数为 40 级，因为基于贪婪的思想，每一步只考虑当前情况的最优解，故总体的基本块排布从第 0 级到第 39 级呈现逐级递减的态势。另外求解结果也给出了每一级的 4 种资源占用情况并计算每一级的资源利用率，其分布态势与前者类似，各级资源利用率的累加和除以总级数得到总体资源利用率为 39.5\%。

对于问题二，在问题一其余情况不变的情况下，另考虑在同一执行流程上的基本块资源占用约束情况，建立 0-1 整数规划模型，送入遗传算法进行求解。最后的结果表明基本块排布级数为 23 级，总体资源利用率为 65.52\%。

针对 PISA 架构基本块排布优化的两个问题，我们建立了两个 0-1 整数规划模型，并采用基于启发式算法的贪婪—遗传算法进行模型求解。第一个问题求得了最优解，第二个问题在一定时间内求得了满意解。模型有较大的实际应用价值，问题二模型求解的时间复杂度问题还需要进一步研究解决。

\textbf{关键字：} 芯片资源排布；0-1 整数规划；贪婪算法；遗传算法

\section*{目录}
\begin{itemize}
    \item 一、问题重述 \dotfill 3
    \begin{itemize}
        \item 1.1 问题背景 \dotfill 3
        \item 1.2 待解决的问题 \dotfill 3
    \end{itemize}
    \item 二、模型假设 \dotfill 4
    \item 三、符号说明 \dotfill 5
    \item 四、问题分析与数据处理 \dotfill 6
    \begin{itemize}
        \item 4.1 邻接基本块信息表的处理 \dotfill 6
        \item 4.2 控制依赖关系的计算 \dotfill 7
        \item 4.3 数据依赖关系的计算 \dotfill 8
    \end{itemize}
    \item 五、问题的建模与求解 \dotfill 10
    \begin{itemize}
        \item 5.1 问题一的建模与求解 \dotfill 10
        \begin{itemize}
            \item 5.1.1 建模准备 \dotfill 10
            \item 5.1.2 问题一模型的建立 \dotfill 10
            \item 5.1.3 模型求解 \dotfill 12
            \item 5.1.4 求解结果与分析 \dotfill 14
        \end{itemize}
        \item 5.2 问题二的建模与求解 \dotfill 17
        \begin{itemize}
            \item 5.2.1 问题二模型的建立 \dotfill 17
            \item 5.2.2 模型求解 \dotfill 19
            \item 5.2.3 结果分析 \dotfill 19
        \end{itemize}
    \end{itemize}
    \item 六、总结 \dotfill 23
    \item 七、参考文献 \dotfill 24
    \item 八、附录 \dotfill 25
\end{itemize}

\section{问题重述}

\subsection{问题背景}

芯片是现代电子产品不可或缺的核心部件，遍布我们衣食住行的每个角落，而在当前日益复杂的国际形势下，“芯片荒”问题日益凸显，芯片成了各个大国必争的高科技技术。PISA（Protocol Independent Switch Architecture）是当前主流的可编程交换芯片架构之一，其有着和固定功能交换芯片相当的处理速率，同时兼具了可编程性，在未来网络中具有广阔的应用场景[1-2]。本题主要关注 PISA 架构中多级的报文处理流水线部分，在 PISA 架构编程模型中，用户使用 P4 语言描述报文处理行为得到 P4 程序，再由编译器编译 P4 程序，进而生成芯片上可以执行的机器码。编译器在编译 P4 程序时，会首先将 P4 程序划分为一系列的基本块，再将各基本块排布到流水线各级当中。各个基本块会占用一定的资源，而为了减少 PISA 架构芯片设计的复杂度，各流水线级和流水线级之间的资源都有一定的限制，这一系列复杂的资源约束条件使得资源排布问题尤为困难。

PISA 架构芯片资源排布问题指的是将各基本块的资源排布到流水线各级当中，即需要确定每个基本块排布到流水线哪一级使得芯片的资源利用率最高。越高的资源利用率意味着能够越好的发挥芯片的能力，让芯片支持更多的业务，因此，高资源利用率的资源排布算法对于编译器设计至关重要。在芯片资源排布过程中，除了需要考虑各流水线级的资源约束外还需要考虑各基本块之间的数据依赖和控制依赖约束。P4 程序每个基本块均会写一部分变量和读一部分变量，变量的读写使得基本块之间存在数据依赖，同时，基本块执行完后可能跳转到多个基本块执行，从而使得基本块之间也存在着控制依赖，数据依赖和控制依赖约束了基本块排布的流水线级数的大小关系。本问题要解决的就是在满足上述数据依赖、控制依赖、以及各具体子问题的资源约束条件下进行资源排布，使得芯片的资源利用率最大。

\subsection{待解决的问题}

本题需要根据给定的数据建立芯片资源排布问题的数学模型，并解决以下两个问题：

问题一：给定流水线各级、流水线级与级之间的资源约束条件，以占用的流水线级数尽量短为优化目标，请给出资源排布算法，输出基本块排布结果。

问题二：对于不在一条执行流程上的基本块，可以共享 HASH 资源和 ALU 资源，只要两个基本块中任意一个的 HASH 资源与 ALU 资源均不超过每级资源限制，则两个基本块即可排布到同一级。据此，更改问题一的部分资源约束条件后重新考虑问题 1，给出排布算法，输出基本块排布结果。

\section{模型假设}

(1) 假设基本块的划分是合理的；

(2) 假设基本块可以被抽象成一个节点，抽象后基本块中执行的具体指令被屏蔽，只保留读写的变量信息；

(3) 假设优化目标占用的流水线级数最短等效于芯片的资源利用率最大；

(4) PISA 架构包括报文解析 (parser)、多级的报文处理流水线 (Pipeline Pocket Process)、以及报文重组 (Deparser) 三个组成部分。本题只关注其中的多级报文处理流水线部分，报文解析、报文重组不考虑。

(5) 本题已在考虑基本块存在先后执行顺序的基础上对基本块的排布进行数据依赖约束、控制依赖约束及资源依赖约束，故问题 1 中的约束 7：每个基本块只能排布到一级，这一约束条件已然成立。

\section*{三、符号说明}

\begin{table}[h]
\centering
\caption{符号说明}
\begin{tabular}{l l}
\hline
符号 & 说明 \\
\hline
$i$ & 表示基本块的编号 \\
$k$ & 表示流水线的级数 \\
$P_i$ & 表示$i$基本块所在的流水线级数 \\
$A_k$ & 表示位于$k$级流水线的基本块编号的集合 \\
$D_1(i,j)$ & 表示$i$与$j$是否存在写后读或写后写依赖 \\
$D_2(i,j)$ & 表示$i$与$j$是否存在读后写依赖 \\
$C(i,j)$ & 表示$i$与$j$是否存在控制依赖 \\
$T_i$ & 表示$i$基本块使用的TCAM资源 \\
$H_i$ & 表示$i$基本块使用的HASH资源 \\
$A_i$ & 表示$i$基本块使用的ALU资源 \\
$Q_i$ & 表示$i$基本块使用的QUALIFY资源 \\
$Z$ & 表示所有基本块占用的最大流水线级数 \\
$N_k$ & 表示偶数级流水线是否占用TCAM资源 \\
$L_k$ & 表示在$k$级流水线上所有的执行流程 \\
$l$ & 表示在一条执行流程上的所有基本块编号 \\
\hline
\end{tabular}
\end{table}

\section*{四、问题分析与数据处理}

本赛题要求在满足数据依赖、控制依赖和流水线各级资源约束的条件下对基本块进行排布，使其占用的流水线级数最少，从而最大化芯片资源的利用率，提高芯片性能。针对芯片资源排布这一问题，首先需要解决的就是各基本块之间的数据依赖和控制依赖问题，这两种依赖限制了基本块在流水线上级数的先后顺序，只有在满足这两种依赖的情况下，基本块的排布才被视为是有效的。因此，理清各基本块之间的数据依赖和控制依赖关系对于解决问题一和问题二是至关重要的。赛题总共提供了3张基本块信息的表，它们分别是各基本块使用的资源信息表、各基本块读写的变量信息表、各基本块在流程图中的邻接基本块信息表，表中共有607个基本块的信息，在提取基本块之间的数据依赖和控制依赖关系时，主要关注后两张表，第一张表则用作计算流水线级基本块总的资源占用量是否满足子问题的资源约束限制。

\subsection*{4.1 邻接基本块信息表的处理}

邻接基本块信息表给出了各基本块与具有有向边连接的其他基本块信息，即一个基本块执行结束后跳转的基本块，通过该表可以得到各基本块的所有后向基本块信息表，也即得到了基本块的执行顺序。表4-1给出了得到的基本块之间的执行顺序信息，其中第一列为基本块编号，后续为执行顺序在第一列基本块之后的所有基本块编号。

\textbf{表4-1 执行顺序表（部分）}

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Block & \multicolumn{6}{c|}{后续基本块编号} \\
\hline
23 & 24 & 25 & 26 & 57 & 86 & $\cdots$ \\
\hline
24 & 25 & 26 & 57 & 86 & 87 & $\cdots$ \\
\hline
25 & 26 & 86 & 87 & 88 & 89 & $\cdots$ \\
\hline
26 & 86 & 87 & 88 & 89 & 90 & $\cdots$ \\
\hline
\end{tabular}
\end{table}

图4-1展示了23号基本块所有的后向连接，图中圆圈里的数字代表基本块编号，由此可以得到23号基本块与所有在它执行顺序之后的基本块的控制依赖关系，相关计算方法在下一小节中给出。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{image1.png}
    \caption{23号基本块的所有后向连接图}
    \label{fig:1}
\end{figure}

\subsection{控制依赖关系的计算}

控制依赖是程序控制流导致的一种约束。而控制依赖分析是用来确定一条程序语句的变化是否会影响其他程序语句的执行，是程序并行化的基础[3]。

控制依赖定义为：当从某个基本块出发的路径，只有部分路径通过下游某个基本块时，两基本块构成控制依赖。其在程序中的典型表现是条件判断语句，条件判断语句中判断值的真假来决定下一步执行的程序语句。所以存在控制依赖的两个基本块必须要满足先执行的基本块排布的流水线级数小于或等于后执行的基本块排布的流水线级数。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{image2.png}
    \caption{控制依赖关系计算}
    \label{fig:2}
\end{figure}

通过上一节得到的基本块执行顺序表和流程图可以计算出基本块之间的控制依赖关系。由控制依赖定义可知，当一个基本块没有下一步执行的基本块或只有一个邻接基本块时则它与后续所有基本块均无控制依赖关系，所以在 attachment3 表中可以先筛选掉这一部分基本块。而对于有多条有向边连接的基本块则采取标记法来计算后续基本块是否与其有控制依赖关系。其基本思路如图 \ref{fig:2} 所示，对于 1 号基本块来说，其后向邻

接基本块有2号和3号两个，则对于这两条有向边分别赋予标记“Mark1”和“Mark2”，分别传递给2号基本块和3号基本块，2号和3号再将它们收到的标记传递到后续基本块，则4号得到的标记即为“Mark1+Mark2”包含了1号基本块所有出发路径带有的标记，这意味着从1号基本块开始的所有路径最后都经过了4号基本块，所以1号基本块与4号基本块之间没有控制依赖。而2号和3号基本块只含有1号所有出发路径标记的一部分，表示从1号基本块出发只有部分路径到达2号和3号，所以存在控制依赖关系，符合控制依赖的定义。

\begin{figure}[h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,semithick]
  \tikzstyle{every state}=[fill=white,draw=black,text=black]

  \node[state] (B1) {$B_1$};
  \node[state] (B2) [below left of=B1] {$B_2$};
  \node[state] (B3) [below right of=B2] {$B_3$};
  \node[state] (B4) [below right of=B3] {$B_4$};
  \node[state] (B5) [below right of=B1] {$B_5$};
  \node[state] (B6) [below left of=B5] {$B_6$};
  \node[state] (B7) [below right of=B6] {$B_7$};
  \node[state] (B8) [below right of=B5] {$B_8$};

  \path (B1) edge node [above left] {M1} (B2)
        (B1) edge node [above right] {M2} (B5)
        (B2) edge node [above left] {M1} (B3)
        (B5) edge node [above left] {M2} (B6)
        (B5) edge node [above right] {M2} (B8)
        (B6) edge node [above left] {M2} (B3)
        (B6) edge node [above right] {M2} (B7)
        (B3) edge node [above] {M1+M2} (B4);
\end{tikzpicture}
\caption{控制依赖关系计算}
\label{fig:control_dependency}
\end{figure}

上图展示了使用标记法计算赛题示例的控制依赖关系，可以看出$B_3$与$B_4$带有所有$B_1$出发路径的标记，所以判定为与$B_1$无控制依赖关系。而$B_2$、$B_5$、$B_6$、$B_7$、$B_8$均只带有一种标记，所以判定为与$B_1$有控制依赖关系，符合赛题描述。

使用该方法对607个基本块都进行计算，便可得出每一个基本块与所有后续基本块是否具有控制依赖关系。通过上一节得到的执行顺序表可以快速地得出控制依赖关系表，如下表所示。

\begin{table}[h]
\centering
\caption{控制依赖关系表（部分）}
\label{tab:control_dependency_table}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
Block & 5 & 6 & 7 & 8 & 9 & $\cdots$ \\ \hline
233 & 5 & 6 & 7 & 8 & 9 & $\cdots$ \\ \hline
234 & 5 & 6 & 7 & 8 & 9 & $\cdots$ \\ \hline
235 & 5 & 6 & 7 & 8 & 9 & $\cdots$ \\ \hline
236 & 0 & 1 & 2 & 5 & 6 & $\cdots$ \\ \hline
\end{tabular}
\end{table}

\subsection{数据依赖关系的计算}

根据表4-1提供的各基本块之间的执行顺序，结合提供的数据：attachment2.csv文件，可以确定出已存在先后顺序的两个基本块之间是否满足数据依赖，具体流程如下：

1. 确定任意两个block之间的执行顺序，生成先后顺序的查询表：先后顺序.csv。
2. 在存在先后执行顺序的两个block之间判定是否存在数据依赖：
   - 前一个block存在写操作的变量集合与后一个block存在写操作的变量集合存在交集，判定为存在写后写依赖，记为A；
   - 前一个block存在写操作的变量集合与后一个block存在读操作的变量集合

\begin{table}[h]
\centering
\caption{表4-3 数据依赖关系表（部分）}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline
 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ \hline
27 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
28 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
29 & 0 & 0 & 0 &  &  & -1 & 0 & -1 & -1 \\ \hline
30 & 0 & 0 & 0 &  &  &  & 0 & 0 & 0 \\ \hline
31 & 0 & 0 & 0 &  & -1 &  &  &  &  \\ \hline
32 & 0 & 0 & 0 &  &  & 0 &  &  &  \\ \hline
\end{tabular}
\end{table}

\section{问题的建模与求解}

\subsection{问题一的建模与求解}

\subsubsection{建模准备}

问题一要求在给定的资源约束条件下，并且满足控制依赖和数据依赖关系的情况下排布 607 个基本块使得占用的流水线级数数量最小。其中资源约束条件主要包括每一级四种资源的最大数目、0 到 31 级里折叠级数的资源数量限制和含有 TCAM 资源的级数数量限制。在建立模型之前，需要先将各基本块之间的读写数据依赖和控制依赖整理好，可以简化模型的表达，便于后续的求解。

\subsubsection{问题一模型的建立}

基于问题一的要求，本文建立了一个单目标多约束的芯片资源排布模型。

\subsubsection*{(1) 建立目标函数}

本文首先定义以下符号：

- $i$ 表示基本块的编号，$i \in [0, 606]$；
- $k$ 表示流水线的级数；
- $P_i$ 表示 $i$ 基本块所在的流水线级数；
- $A_k$ 表示位于 $k$ 级流水线的基本块编号的集合：
  \begin{equation}
  A_k = \{i | P_i = k\}, i \in [0, 606]
  \tag{5-1}
  \end{equation}
- $D_1(i, j)$ 表示 $i$ 号基本块与 $j$ 号基本块是否存在写后读依赖或写后写依赖：
  \begin{equation}
  D_1(i, j) =
  \begin{cases}
  1, & i \text{ 与 } j \text{ 存在写后读或写后写依赖} \\
  0, & i \text{ 与 } j \text{ 不存在写后读或写后写依赖}
  \end{cases}
  \tag{5-2}
  \end{equation}
- $D_2(i, j)$ 表示 $i$ 号基本块与 $j$ 号基本块是否存在读后写依赖：
  \begin{equation}
  D_2(i, j) =
  \begin{cases}
  1, & i \text{ 与 } j \text{ 存在读后写依赖} \\
  0, & i \text{ 与 } j \text{ 不存在读后写依赖}
  \end{cases}
  \tag{5-3}
  \end{equation}
- $C(i, j)$ 表示 $i$ 号基本块与 $j$ 号基本块是否存在控制依赖：
  \begin{equation}
  C(i, j) =
  \begin{cases}
  1, & i \text{ 与 } j \text{ 存在控制依赖} \\
  0, & i \text{ 与 } j \text{ 不存在控制依赖}
  \end{cases}
  \tag{5-4}
  \end{equation}
- $T_i$ 表示 $i$ 基本块使用的 TCAM 资源；
- $H_i$ 表示 $i$ 基本块使用的 HASH 资源；
- $A_i$ 表示 $i$ 基本块使用的 ALU 资源；
- $Q_i$ 表示 $i$ 基本块使用的 QUALIFY 资源；
- $Z$ 表示所有基本块所占用的最大流水线级数：
  \begin{equation}
  Z = \max\{P_i | i \in [0, 606]\}
  \tag{5-5}
  \end{equation}
- $N_k$ 表示偶数级流水线是否使用了 TCAM 资源：

\begin{equation}
N_k =
\begin{cases}
1, & \sum_{i \in A_k} T_i > 0 \\
0, & \sum_{i \in A_k} T_i = 0
\end{cases}, \quad k \in [0, Z] \text{且为偶数}
\tag{5-6}
\end{equation}

结合上述符号，按照问题一的要求，需要使得所有基本块占用的流水线级数尽可能短，可以得出如下目标函数：

\begin{equation}
\min Z = \max \{ P_i | i \in [0, 606] \}
\tag{5-7}
\end{equation}

本题的目标是找到 607 个基本块的最优排布方案，使得占用的流水线级数最短，而 \( Z \) 为所有基本块中占用流水线级数的最大值，该目标函数是去寻找该值的最小值，符合本题的要求。

(2) 约束条件

根据题目要求，模型需要满足以下约束条件：

- 数据依赖约束：在程序运行时，各个基本块之间可能需要读写同一个变量，而这就会导致基本块之间形成数据依赖，存在数据依赖的基本块在流水线上的顺序有一定的要求。具体而言，当基本块 \( i \) 和 \( j \) 存在写后读数据依赖或写后写数据依赖时，基本块 \( i \) 排布的流水线级数需要小于基本块 \( j \) 排布的级数，可得如下约束

\begin{equation}
P_i * D_1(i, j) < P_j, \quad i, j \in [0, 606]
\tag{5-8}
\end{equation}

当基本块 \( i \) 和 \( j \) 存在读后写数据依赖时，基本块 \( i \) 排布的流水线级数需要小于或等于基本块 \( j \) 排布的级数，可得如下约束

\begin{equation}
P_i * D_2(i, j) \leq P_j, \quad i, j \in [0, 606]
\tag{5-9}
\end{equation}

当两个基本块都需要读取一个变量时，不视为存在数据依赖关系。

- 控制依赖约束：在程序运行中，部分基本块的执行受到其他基本块的影响，对于这类基本块，其流水线级数也会受到约束。如果基本块 \( i \) 与基本块 \( j \) 存在控制依赖，则 \( i \) 排布的流水线级数需要小于或等于 \( j \) 排布的流水线级数，因此可得如下约束

\begin{equation}
P_i * C(i, j) \leq P_j, \quad i, j \in [0, 606]
\tag{5-10}
\end{equation}

- 每一级流水线的资源约束条件：

\begin{equation}
\sum_{i \in A_k} T_i \leq 1, \quad k \in [0, Z]
\tag{5-11}
\end{equation}

\begin{equation}
\sum_{i \in A_k} H_i \leq 2, \quad k \in [0, Z]
\tag{5-12}
\end{equation}

\begin{equation}
\sum_{i \in A_k} A_i \leq 56, \quad k \in [0, Z]
\tag{5-13}
\end{equation}

\begin{equation}
\sum_{i \in A_k} Q_i \leq 64, \quad k \in [0, Z]
\tag{5-14}
\end{equation}

- 折叠级数资源约束：按照题目要求，流水线第 0 级与第 16 级，第 1 级与第 17 级，...，第 15 级与第 31 级为折叠级数，折叠的两级 TCAM 资源加起来最大为 1，HASH 资源加起来最大为 3，于是可得如下约束

\begin{equation}
\sum_{i \in A_k} T_i + \sum_{i \in A_{k+16}} T_i \leq 1, \quad k \in [0, 16]
\tag{5-15}
\end{equation}

\begin{equation}
\sum_{i \in A_k} H_i + \sum_{i \in A_{k+16}} H_i \leq 3, \quad k \in [0, 16]
\tag{5-16}
\end{equation}

- 偶数级数资源约束：使用 TCAM 资源的偶数流水线级数量不超过 5，可得如下约束

\begin{equation}
\sum_{k=0}^{Z} N_k \leq 5, \, k \text{为偶数}
\tag{5-17}
\end{equation}

在本模型中，基本块编号、流水线级数均为非负整数。

综上所述，针对问题一可以建立如下的芯片资源排布优化模型：

\begin{equation}
\begin{aligned}
& \min Z = \max \{P_i | i \in [0, 606]\} \\
& \text{s.t.} \\
& P_i * D_1(i, j) < P_j, \quad \forall \, i, j \in [0, 606] \\
& P_i * D_2(i, j) \leq P_j, \quad \forall \, i, j \in [0, 606] \\
& P_i * C(i, j) \leq P_j, \quad \forall \, i, j \in [0, 606] \\
& \sum_{i \in A_k} T_i \leq 1, \, \forall k \in [0, Z] \\
& \sum_{i \in A_k} H_i \leq 2, \, \forall k \in [0, Z] \\
& \sum_{i \in A_k} A_i \leq 56, \, \forall k \in [0, Z] \\
& \sum_{i \in A_k} Q_i \leq 64, \, \forall k \in [0, Z] \\
& \sum_{i \in A_k} T_i + \sum_{i \in A_{k+16}} T_i \leq 1, \, \forall k \in [0, 16) \\
& \sum_{i \in A_k} H_i + \sum_{i \in A_{k+16}} H_i \leq 3, \, \forall k \in [0, 16) \\
& \sum_{k=0}^{Z} N_k \leq 5, \, k \text{为偶数}
\end{aligned}
\end{equation}

\subsection{5.1.3 模型求解}

对于芯片资源排布模型的求解，考虑到该模型复杂度高、计算量大、约束条件多，使用求解器求解无法满足问题需求，所以本文首先尝试采用遗传算法进行求解。

遗传算法是一种现代优化算法，其原理是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。该算法不需要目标函数满足可导或连续等限定条件，适用范围广，寻优能力好，已经广泛应用于各大领域中。

在遗传算法的优化求解过程中，本文将 607 个基本块的流水线级数对应为算法的基因位点，将每一个基本块先随机放置在一个流水线级上，然后依次判断是否满足资源约束条件、数据依赖约束条件、控制依赖约束条件，将满足所有约束条件的个体放入初始种群开始迭代优化。在迭代过程中，我们发现迭代优化的效率很低，并且收敛性差、收敛速度慢。分析算法发现原因有以下两点：

（1）在初始个体随机生成的情况下，能够满足所有约束条件的个体数量较少，导致初始种群的生成较为困难，需要改进算法的种群生成方式。

（2）每一次迭代都需要判断约束条件是否满足，而每一个基本块的判断都会耗费大量资源，这导致了迭代优化的效率很低。并且在判断控制依赖和数据依赖约束时，需要反复进行判断是否满足了约束条件。例如，在判断控制依赖约束时，基本块 \(i\) 与基本块 \(j\) 有控制依赖，则 \(i\) 的流水线级数需要小于等于 \(j\) 的流水线级数，而 \(j\) 又有可能与其他基本块有控制依赖关系，这就使得需要不断更新 \(i\) 的流水线级数约束，这大大增加了判

断约束条件的复杂性，导致了迭代优化的效率很差且收敛性差。

基于上述存在的问题，我们提出了结合贪婪算法的改进遗传算法来进行求解。贪婪算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。通过引入贪婪算法，可以大幅降低算法的复杂度。

在改进算法中，会首先从 0 级流水线开始寻找目前的最佳选择，即只考虑 0 级，使得 0 级的资源利用率最高并且排布尽可能多的基本块。算法首先通过遗传算法的方式寻找 0 级流水线所有满足约束条件需要同时排布在一级的基本块，将这些需要同时排布在一级的基本块划分为一组。例如假定 \( i \) 基本块排布在 0 级，则所有流水线级数需要小于等于 \( i \) 的基本块也都需要排布在 0 级。

在进行约束判断时，改进算法通过将资源约束和控制依赖、数据依赖结合起来的方式简化了约束的判断。基于贪婪算法的思想，将不满足资源约束条件的基本块组直接剔除，这可以大幅降低约束判断的计算量，算法程序运行显示计算每一级的基本块编号平均只需要数十秒。

改进算法设置适应度函数为各种资源占用量与排布的基本块数量的加权和，从而得到能够最大化 0 级的资源利用率和排布基本块数量的基本块编号，将这些基本块去除之后再从 1 级流水线寻找目前的最优选择，不断重复直至排布完所有的基本块。

改进算法的求解步骤如下所示：

- Step1. 初始化种群，调整种群个体基因生成 1 的概率为基因长度的倒数，这样可以使得基本块的排布尽可能靠前，而不是纯随机生成，便于遗传算法的迭代优化，提高迭代效率；
- Step2. 将资源约束和控制依赖、数据依赖结合起来判断是否满足约束条件，输出满足约束条件且需要同时排布在一级的基本块组；
- Step3. 求出适应度值最大的基本块组；
- Step4. 去除已经排布好的基本块，若还有未排布的基本块则跳转至 Step1 计算下一级流水线的排布。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{algorithm_flowchart.png}
    \caption{算法流程图}
    \label{fig:algorithm_flowchart}
\end{figure}

改进算法的流程图如图 \ref{fig:algorithm_flowchart} 所示。改进算法基于贪婪思想进行改进，大幅降低了计算复杂度，并且可以得到一个满意解。

\subsection{求解结果与分析}

\subsubsection{基本块排布情况}

采用改进算法进行求解，最后得到问题一的所有基本块在满足约束条件的前提下需要占用 0 级到 39 级共 40 级流水线，每一级流水线的排布情况如图 \ref{fig:algorithm_flowchart} 所示。

从图中可以看出，由于采用的是基于贪婪思想的改进遗传算法，所以级数靠前的流水线会被安排更多的符合约束条件的基本块，从而得到级数靠前的流水线最高的适应度得分。对于级数靠后的流水线来说，它们被分配到的基本块数量并不多，可以看到后 10 级流水线大部分一级只排布了一个基本块，这些基本块更多地是因为约束关系而必须排布到新一级的流水线上。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image.png}
    \caption{基本块排布情况}
    \label{fig:basic_block_layout}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image.png}
    \caption{各流水线级资源利用率}
    \label{fig:resource_utilization}
\end{figure}

上图展示了各流水线级的资源利用率，从图中可以看出级数靠前的流水线资源利用率明显高于级数靠后的流水线资源利用率，这主要是由于适应度函数设置为四种资源的资源利用率和基本块数的加权和，基于贪婪思想的改进算法会从第 0 级开始选择能使当前级适应度函数值最大的基本块组。而第 1 级至第 3 级资源利用率比第 0 级高是因为有很多基本块不能放在第 0 级，这些基本块需要其他的基本块级数小于它的级数，而这将无法做到，所以会被排除掉，当第 0 级放入一些基本块后，很多模块的限制就会解除，资源利用率就会变高一些。

从图中还可以观察到级数在 16 之后的流水线资源利用率会出现一次下降，并在 32 级之后又有一次小幅上升，这主要是由于折叠级数间的约束限制了基本块的排布，在 32 级之后去除掉折叠级数约束资源利用率上升符合题目预期。

(3) 整个流水线的资源利用率情况

由于算法基于贪婪思想，每个流水线级的资源利用率呈现出由高到低的趋势，图 5-3 计算了整个流水线的总体资源占用率，其占用率为 39.5%。这主要是由于贪婪算法会将基本块尽可能的塞满级数靠前的流水线，导致级数靠后的流水线资源利用率普遍偏低。

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{image.png}
\caption{总体资源利用率}
\end{figure}

图 5-3 整体资源利用率

本题最后得出的占用级数为 40 级，而从每个基本块所需的 HASH 资源来看，607 个基本块总共需要 63 的 HASH 资源。而对于问题一来说，考虑到折叠级数资源约束，仅分配 HASH 资源就需要 40 级流水线，也就是说最优解的流水线级数也应大于等于 40。因此改进算法得出的排布方式是能使占用级数最短的一种排布方式。

\subsection{5.2 问题二的建模与求解}

\subsubsection{5.2.1 问题二模型的建立}

问题二与问题一相比需要多考虑两个基本块是否在同一条执行流程上。如果由一个

基本块出发可以到达另一个基本块则两基本块在一条执行流程上，反之不在一条执行流程上。对于这种不在一条执行流程上的基本块，可以共享 HASH 资源和 ALU 资源。据此，需要修改问题一的部分约束条件，重新建立模型。

(1) 目标函数

问题二相比问题一没有增加新的优化目标，仍以流水线占用级数最短为优化目标：
\begin{equation}
min \, Z = max\{P_i | i \in [0, 606]\}
\tag{5-18}
\end{equation}

(2) 确定约束条件

在给出约束条件前首先给定如下符号定义：

- $L_k$ 表示在 $k$ 级流水线上所有的执行流程；
- $l$ 表示一个集合，其中存储了所有在一条执行流程上的基本块编号。

由题意可得，本题的数据依赖和控制依赖约束条件与问题一相同，不作更改，主要改变流水线的资源约束条件。

对于资源约束条件，不在一条执行流程上的基本块可以共享 HASH 资源和 ALU 资源，而对于 TCAM 资源与 QUALIFY 资源的约束条件也同问题一。于是根据问题二约束条件 2、3 可得：

\begin{equation}
\max_{l \in L_k} \sum_{i \in l} H_i \leq 2, \, k \in [0, Z]
\tag{5-19}
\end{equation}

\begin{equation}
\max_{l \in L_k} \sum_{i \in l} A_i \leq 56, \, k \in [0, Z]
\tag{5-20}
\end{equation}

对于折叠级数的 HASH 资源约束也需要进行修改：

\begin{equation}
\max_{l \in L_k} \sum_{i \in l} H_i + \max_{l \in L_{k+16}} \sum_{i \in l} H_i \leq 3, \, k \in [0, 16)
\tag{5-21}
\end{equation}

对于偶数级数资源约束不需要修改，最后可以建立如下模型：

\begin{equation}
min \, Z = max\{P_i | i \in [0, 606]\}
\end{equation}

s.t.

\begin{align*}
P_i * D_1(i, j) &< P_j, \quad \forall \, i, j \in [0, 606] \\
P_i * D_2(i, j) &\leq P_j, \quad \forall \, i, j \in [0, 606] \\
P_i * C(i, j) &\leq P_j, \quad \forall \, i, j \in [0, 606] \\
\sum_{i \in A_k} T_i &\leq 1, \, \forall k \in [0, Z] \\
\max_{l \in L_k} \sum_{i \in l} H_i &\leq 2, \, k \in [0, Z] \\
\max_{l \in L_k} \sum_{i \in l} A_i &\leq 56, \, k \in [0, Z] \\
\sum_{i \in A_k} Q_i &\leq 64, \, \forall k \in [0, Z] \\
\sum_{i \in A_k} T_i + \sum_{i \in A_{k+16}} T_i &\leq 1, \, \forall k \in [0, 16) \\
\max_{l \in L_k} \sum_{i \in l} H_i + \max_{l \in L_{k+16}} \sum_{i \in l} H_i &\leq 3, \, k \in [0, 16) \\
\sum_{k=0}^Z N_k &\leq 5, \, k \text{为偶数}
\end{align*}

\subsection{5.2.2 模型求解}

由于问题二的模型与问题一的模型类似，所以问题二的模型求解我们仍然采用基于贪婪思想的改进遗传算法进行求解，求解思路与问题一一致。

考虑问题二的假设修改对 HASH 和 ALU 资源进行了限制，因此我们只需对在不满足 HASH 和 ALU 资源限制的种群进行进一步求解。当 HASH 和 ALU 资源不满足限制时候，对该种群个体进行路径搜索，之后对重复路径进行筛选，可以得出不重复路径。对那些不重复路径求解 HASH 和 ALU 资源，找出最大值与限制进行比较，如果满足限制则通过。

问题二的求解步骤如下：

- Step1. 初始化种群，调整种群个体基因生成 1 的概率为基因长度的倒数，这样可以使得基本块的排布尽可能靠前，而不是纯随机生成，便于遗传算法的迭代优化，提高迭代效率；
- Step2. 判断控制依赖、数据依赖是否满足约束条件，对在同一条执行流程上的基本块判断资源约束条件，输出满足约束条件且需要同时排布在一级的基本块组；
- Step3. 求出适应度值最大的基本块组；
- Step4. 去除已经排布好的基本块，若还有未排布的基本块则跳转至 Step1 计算下一级流水线的排布。

\subsection{5.2.3 结果分析}

(1) 基本块排布情况

采用改进算法进行求解，最后得到问题二的所有基本块在满足修改后约束条件的前提下需要占用共 23 级流水线，每一级流水线的排布情况如图 5-4 所示。

从图中可以看出，由于采用的是基于贪婪思想的改进遗传算法，所以与问题一相似，级数靠前的流水线会被安排更多的符合约束条件的基本块，从而得到级数靠前的流水线最高的适应度得分。对于级数靠后的流水线来说，它们被分配到的基本块数量会相对较少，但相比问题一得益于不同执行流程可以共享资源，所以可以多分配一些基本块。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image.png}
    \caption{基本块排布情况}
    \label{fig:basic_block_layout}
\end{figure}

(2) 各流水线级资源利用情况

上图展示了各流水线级的资源利用率，从图中可以看出级数靠前的流水线资源利用率相对高于级数靠后的流水线资源利用率，这与问题一是相似的。与问题一相比，问题二的流水线各级资源利用率分布更加均匀。

从图中还可以观察到级数在 16 之后的流水线资源利用率会与问题一类似出现一次下降，这主要是由于折叠级数间的约束限制了基本块的排布，符合题目预期。

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{image.png}
    \caption{各流水线级资源利用情况}
    \label{fig:5-5}
\end{figure}

(3) 整个流水线的资源利用率情况

图 5-6 展示了整个流水线的资源利用率，其值为 65.52%。可以发现流水线整体的资源利用率相比问题一提升了许多，这主要是由于在不同执行流程可以共享资源。

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{image.png}
    \caption{总体资源利用率}
    \label{fig:5-6}
\end{figure}

图5-6 总体资源占用率

\newpage
22

\section*{六、总结}

本题以使占用的流水线级数最短为优化目标，针对问题一和问题二分别建立了两个多约束组合优化模型。

1. 问题一的模型是以流水线级数最短为优化目标，在满足控制依赖、数据依赖和资源约束的条件下进行基本块的排布，建立 0-1 整数规划模型，送入遗传算法进行求解。在求解过程中，遇到了约束条件判断复杂、收敛性差的问题，于是提出了基于贪婪思想的改进遗传算法，通过改进算法大大降低计算的复杂度，在较短的时间内给出了模型的局部最优解。

2. 问题二在问题一的基础上更改了部分约束条件，对于资源约束条件需要进行重新规划。本文对 HASH 和 ALU 资源不满足限制的情况下，对该种群个体进行路径搜索，之后对重复路径进行筛选，可以得出不重复路径。通过对不重复路径求解 HASH 和 ALU 资源，找出最大值与限制进行比较，求得满足约束条件的基本块。求解思路与问题一一致。

本文采取的基于贪婪思想的改进遗传算法模型加快了模型的求解，最后得出问题一的解为 40 级数，问题二的解为 23 级数，总体的基本块排布从前往后呈现逐级递减的态势，符合贪婪算法的思想。另外求解结果也给出了每一级的 4 种资源占用情况并计算每一级的资源利用率，各级资源利用率的累加和除以总级数得到总体资源利用率分别为 39.5\%、65.52\%，总体的排布结果满足题目要求。

\section*{七、参考文献}

1. Bosshart P, Daly D, Gibb G, et al. P4: Programming protocol-independent packet processors[J]. ACM SIGCOMM Computer Communication Review, 2014, 44(3): 87-95.

2. Bosshart P, Gibb G, Kim H S, et al. Forwarding metamorphosis: Fast programmable match-action processing in hardware for SDN[J]. ACM SIGCOMM Computer Communication Review, 2013, 43(4): 99-110.

3. 姚辉萍;赵雷;李莹;杨季文.一种改进的计算控制依赖的算法[J].计算机应用与软件,2010,v.27,19-21+40.

4. 刘力贞. 遗传算法在分布式约束优化问题中的应用研究[D].重庆大学,2020.

5. 杨子兰,朱娟萍,李睿.资源受限最小赋权树形图的一种贪婪分解启发式算法[J].西南师范大学学报(自然科学版),2017,42(08):18-24.

6. 丁可,徐言民,关宏旭,李诗杰,李柏苇.基于贪心-遗传优化算法的中长期船舶进出港调度优化[J/OL].武汉理工大学学报(交通科学与工程版):1-10[2022-10-09].