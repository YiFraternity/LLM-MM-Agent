{
  "tasks": [],
  "problem_str": "问题背景：\n芯片是电子行业的基础，在当前日益复杂的国际形势下，芯片成了各个大国必争的高科技技术。本课题关注网络通信领域的交换芯片，传统的交换芯片功能固定，当出现新的网络协议时，必须重新设计芯片，而芯片从设计到使用，往往需要几年的时间，因此固定功能的交换芯片大大降低了研发效率，为了解决此问题，诞生了可编程的交换芯片。PISA（Protocol Independent Switch Architecture）是当前主流的可编程交换芯片架构之一，其有着和固定功能交换芯片相当的处理速率，同时兼具了可编程性，在未来网络中具有广阔的应用场景[1-2]。\n\n在对PISA架构作进一步说明之前我们首先澄清几个基本概念：\n\n1. 报文：报文即网络通信中传输的数据包，在网络通信中，用户传输的数据被封装成一个个的数据包进行传输。\n\n2. 基本块：基本块是源程序的一个程序片段，对源程序进行基本块划分会将源程序划分为一个个的基本块。至于基本块如何划分本身也是一个值得探讨的问题，但超出了本问题的范围，在此不再多加赘述。\n\n3. 流水线：流水线为一系列处理单元串联构成，报文在流水线中按次序依次通过每个处理单元，最终完成处理。流水线各级即是指流水线中各处理单元。\n\nPISA架构如图1所示，其包括报文解析（parser）、多级的报文处理流水线（Pipeline Pocket Process）、以及报文重组（Deparser）三个组成部分。报文解析用于识别报文种类；多级的报文处理流水线用于修改报文数据，在实际的PISA架构芯片中，不同的芯片流水线的级数可能不同；报文重组用于报文重新组装。本课题只关注其中多级的报文处理流水线部分。在PISA架构编程模型中，用户使用P4语言描述报文处理行为得到P4程序，再由编译器编译P4程序，进而生成芯片上可以执行的机器码。编译器在编译P4程序时，会首先将P4程序划分为一系列的基本块，再将各基本块排布到流水线各级当中。由于各基本块均会占用一定的芯片资源，将基本块排布到流水线各级即是将各基本块的资源排布到流水线各级当中（即需要确定每个基本块排布到流水线哪一级），因此我们将基本块的排布问题称作 PISA 架构芯片资源排布问题。在实际的 PISA 架构芯片的设计中，为了减少连线的复杂度，往往对流水线各级的资源、以及流水线各级之间的资源有着多种多样的约束条件，这一系列复杂的资源约束条件使得资源排布问题尤为困难。然而，芯片的各类资源均有限，越高的资源利用率意味着能够越好的发挥芯片的能力，让芯片支持更多的业务，因此，高资源利用率的资源排布算法对于编译器设计至关重要。\n\n问题要求：\n由基本块定义可知基本块为源程序的片段，基本块中会执行指令来完成计算，指令执行时会读取指令源操作数（即读源操作数对应的变量）进行计算，再将计算结果赋值给目的操作数（即写目的操作数对应的变量）。对于划分好的基本块，每个基本块中的指令并行执行，执行时按照先读后写的顺序（由芯片底层实现所决定），即先同时读出所有的目的操作数，再并行执行所有指令的计算，最后同时将计算结果赋值给目的操作数。由于并行向同一个变量写多次时存在冲突，因此每个基本块只会写同一个变量一次（即基本块中不存在多条指令对相同变量赋值）。\n\n基本块可以被抽象成一个节点，抽象后基本块中执行的具体指令被屏蔽，只保留读写的变量信息。当基本块 A 执行完可以跳转到基本块 B 执行时，在 A 和 B 之间增加一条有向边，这样 P4 程序即可表示为一个有向无环图（P4 程序不存在循环），称作 P4 程序流程图，如图 2 左图所示。PISA 架构资源排布即是将 P4 程序流程图中的各节点（即各基本块）在满足约束条件下排布到流水线各级当中。约束条件来自于两方面，一方面来自于 P4 程序本身，P4 程序每个基本块均会写一部分变量（即对变量赋值）和读一部分变量，变量的读写使得基本块之间存在数据依赖，同时，基本块执行完后可能跳转到多个基本块执行，从而使得基本块之间也存在着控制依赖，数据依赖和控制依赖约束了基本块排布的流水线级数的大小关系，关于数据依赖和控制依赖的详细说明参见附录A；另一方面的约束条件来自于芯片的资源约束，芯片中的资源包括TCAM、HASH、ALU、QUALIFY四类（附录B中解释了四类资源的作用以供感兴趣的同学进一步了解，不了解并不影响问题作答）。流水线中针对于这四类资源有着严格的限制（具体的资源限制在赛题中进行说明），资源排布时不能违反芯片的资源限制。\n\n本问题中，输入数据给出了各基本块在P4程序流程图中的邻接关系，各基本块占用的四类资源的数量，以及各基本块读写的变量信息，本问题的赛题总共包括两个子问题，需要同学们在满足上述数据依赖、控制依赖、以及各具体子问题的资源约束条件下进行资源排布，并充分考虑各子问题的优化目标，以求最大化芯片资源利用率。\n\n图2  PISA架构资源排布示意图\n\n\\section{输入数据说明}\n\n输入数据包含三个附件，分别给出了各基本块资源使用情况、各基本块读写的变量信息，以及各基本块在流图中的邻接基本块。各附件格式如下：\n\n\\subsection{(1) attachment1.csv: 各基本块使用的资源信息}\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & TCAM & HASH & ALU & QUALIFY \\\\\n\\hline\n0 & 0 & 0 & 2 & 0 \\\\\n1 & 0 & 0 & 0 & 0 \\\\\n2 & 0 & 0 & 0 & 0 \\\\\n3 & 0 & 0 & 0 & 0 \\\\\n4 & 0 & 0 & 10 & 3 \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列为基本块编号，第2列到第5列为各基本块使用的四种资源的数目。资源总共分为四种（TCAM, HASH, ALU, QUALIFY）。例如，0号基本块需要占用2个ALU资源，4号基本块需要占用10个ALU资源和3个Qualify资源。\n\n\\subsection{(2) attachment2.csv: 各基本块读写的变量信息}\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & W/R & Var1 & Var2 & Var3 \\\\\n\\hline\n0 & W & X0 & X1 &  \\\\\n0 & R &  &  &  \\\\\n1 & W &  &  &  \\\\\n1 & R &  &  &  \\\\\n2 & W &  &  &  \\\\\n2 & R &  &  &  \\\\\n3 & W &  &  &  \\\\\n3 & R &  &  &  \\\\\n4 & W & X5 & X6 &  \\\\\n4 & R & X23 & X24 &  \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列表示基本块编号，第二列中“W”表示写，“R”表示读，后续列表示基本块写或者读的变量。当某一行从第三列及以后没有任何元素时，说明此编号的基本块没有写（或读）任何变量（此时该基本块仅作为连接其他基本块的中间基本块，没有执行任何计算）。例如：0号基本块写了变量X0、X1，但没有读任何变量；1号基本块既没有写任何变量，也没有读任何变量。\\subsection{(3) attachment3.csv: 各基本块在流程图中的邻接基本块信息}\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n0 & 1 & 2 & ... \\\\\n\\hline\n1 & 2 &   & ... \\\\\n\\hline\n2 &   &   & ... \\\\\n\\hline\n3 & 31 &   & ... \\\\\n\\hline\n4 & 0 & 586 & ... \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列为基本块编号，后续列为与当前基本块在流程图中邻接的基本块编号，即在流程图中，本基本块到后续列中的基本块之间存在有向边连接。例如，由上表第一行可知，0号基本块到1号基本块和2号基本块之间存在有向边连接（即0号基本块执行结束后可以跳转到1号基本块或2号基本块执行）；由第三行可知从2号基本块出发没有边（即基本块2执行后程序结束，不会再跳转到其它基本块执行）。通过此文件可以确定基本块在源程序的执行顺序，确定每个基本块执行后跳转的目的基本块，进而构建起基本块的流程图。\\section{问题}\n\n本题需要建立资源排布问题的数学模型，并在此基础上处理如下两个问题：\n\n\\subsection{问题1} 给定资源约束条件如下：\n\n\\begin{enumerate}\n  \\item 流水线每级的 TCAM 资源最大为 1；\n  \\item 流水线每级的 HASH 资源最大为 2；\n  \\item 流水线每级的 ALU 资源最大为 56；\n  \\item 流水线每级的 QUALIFY 资源最大为 64；\n  \\item 约定流水线第 0 级与第 16 级，第 1 级与第 17 级，…，第 15 级与第 31 级为折叠级数，折叠的两级 TCAM 资源加起来最大为 1，HASH 资源加起来最大为 3。注：如果需要的流水线级数超过 32 级，则从第 32 开始的级数不考虑折叠资源限制；\n  \\item 有 TCAM 资源的偶数级数量不超过 5；\n  \\item 每个基本块只能排布到一级。\n\\end{enumerate}\n\n在上述资源约束条件下进行资源排布，并以占用的流水线级数尽量最少为优化目标。请给出资源排布算法，输出基本块排布结果，输出的结果格式如下：\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\n流水线级数 & 分配的基本块编号 &  &  &  \\\\\n\\hline\n0 & xxx & xxx & xxx & xxx \\\\\n1 & xxx & xxx & xxx & xxx \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n\\subsection{问题2} 考虑图 3 所示的流程图，基本块 2 和基本块 3 不在一条执行流程上（因为基本块 1 执行完后要么执行基本块 2，要么执行基本块 3，基本块 2 和基本块 3 不可能都执行）。准确来说，在 P4 程序流程图中，由一个基本块出发可以到达另一个基本块则说明两基本块在一条执行流程上，反之不在一条执行流程上。对于这种不在一条执行流程上的基本块，可以共享 HASH 资源和 ALU 资源，基本块 2 和 3 任意一个的 HASH 资源与 ALU 资源均不超过每级资源限制，基本块 2 和 3 即可排布到同一级。根据问题1中的约束条件 (2)、(3)、(5) 作如下更改：\n\n\\begin{enumerate}\n  \\item (2) 流水线每级中同一条执行流程上的基本块的 HASH 资源之和最大为 2；\n  \\item (3)流水线每级中同一条执行流程上的基本块的 ALU 资源之和最大为 56；\n  \\item (5)折叠的两级，对于 TCAM 资源约束不变，对于 HASH 资源，每级分别计算同一条执行流程上的基本块占用的 HASH 资源，再将两级的计算结果相加，结果不超过 3。\n\\end{enumerate}\n\n其它约束条件同问题 1。更改资源约束条件后重新考虑问题 1，给出排布算法，输出基本块排布结果。输出格式同问题 1。\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.4\\textwidth]{flow_example.png}\n\\caption{流程图示例}\n\\end{figure}\nAddendum: \n参考文献\nBosshart P, Daly D, Gibb G, et al. P4: Programming protocol-independent packet processors[J]. ACM SIGCOMM Computer Communication Review, 2014, 44(3): 87-95.\nBosshart P, Gibb G, Kim H S, et al. Forwarding metamorphosis: Fast programmable match-action processing in hardware for SDN[J]. ACM SIGCOMM Computer Communication Review, 2013, 43(4): 99-110.\n\n附录A\n1、数据依赖\n数据依赖是语句或代码块间数据流造成的一种约束。具体来说包含3种依赖方式：\n（1）S1在S2之前执行，当S1写某个变量而S2读该变量时，S1和S2存在写后读数据依赖。例如图A-1中，S1写了变量a，而S2读了变量a（使用a作条件判断），则S1和S2存在写后读依赖；S3写了变量d，而S4读了变量d（使用d作为指令的源），则S3和S4也存在写后读依赖。\n（2）S1在S2之前执行，当S1读某个变量而S2写该变量时，S1和S2存在读后写数据依赖。例如图A-1中，S3读了变量e（使用e作指令的源），而S4写了变量e，则S3和S4存在读后写依赖。\n（3）S1在S2之前执行，当S1和S2均写某个变量时，S1和S2存在写后写数据依赖。例如图A-1中，S3和S5均写了变量d，则S3和S5存在写后写依赖。\n\n\n图A-1  数据依赖示例\n\n在PISA架构中，当基本块A和B存在写后读数据依赖或写后写数据依赖时，基本块A排布的流水线级数需要小于基本块B排布的级数，比如基本块B被排到了流水线第10级，则基本块A只能排到流水线第0级到第9级；当基本块A和B存在读后写数据依赖时，基本块A排布的流水线级数需要小于或等于基本块B排布的级数，比如基本块B被排到流水线第10级，则基本块A只能排到第0级到第10级。\n2、控制依赖\n控制依赖是程序控制流导致的一种约束。控制依赖定义为：当从某个基本块出发的路径，只有部分路径通过下游某个基本块时，两基本块构成控制依赖。如图A-2所示的控制流图，B1与B2、B5、B6、B7、B8之间存在控制依赖，B5与B6、B8之间存在控制依赖，但B5和B7不构成控制依赖，因为从B5出发的两条路径下游都会经过B7。在PISA架构中，如果基本块A与基本块B存在控制依赖，则A排布的流水线级数需要小于或等于B排布的流水线级数。\n\n\n图A-2  控制依赖示例\n\n附录B\n为了说明TCAM、HASH、ALU、QUALIFY四类资源的作用，我们需要对P4语言有一个简单的了解。表项是P4程序的基本元素之一，P4程序中的表项包括key和action两个基本属性，表项在芯片底层由一条条的条目构成，P4程序执行表项时会使用key去条目中查找，命中一个条目后会从条目中取出源数据，再将取出的数据放到action的指令中去执行。关于表项的详细说明可参见如下网址的P4语言标准文档：https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html.\n在简单了解P4语言后，我们进一步说明四类资源的具体作用。\nTCAM和HASH：TCAM和HASH都是芯片中的表项资源，P4程序中可定义类型为TCAM或HASH的表项，类型为TCAM的表项需要占据芯片TCAM资源，类型为HASH的表项需要占用芯片HASH资源；\nALU：如上所述，表项执行时需要从条目中取出源数据放到action的指令中执行，指令的执行在芯片中需要放到ALU中进行，因此action中的指令需要占用ALU资源；\nQUALIFY：在P4程序中有做条件判断的if-else语句（含义同其它高级语言），if-else语句中的条件判断在执行时需要放到芯片QUALIFY中进行，需要占用QUALIFY资源。\n附录C\n资源约束以赛题中问题1的资源约束为准，假设输入数据如下：\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & TCAM & HASH & ALU & QUALIFY \\\\\n\\hline\n0 & 0 & 0 & 2 & 0 \\\\\n\\hline\n1 & 1 & 0 & 0 & 0 \\\\\n\\hline\n2 & 0 & 0 & 0 & 0 \\\\\n\\hline\n3 & 1 & 0 & 0 & 0 \\\\\n\\hline\n\\end{tabular}\n\\caption{(1) attachment1.csv: 各基本块使用的资源信息}\n\\end{table}\n\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\n0 & W & X0 & & \\\\\n\\hline\n0 & R & & & \\\\\n\\hline\n1 & W & X1 & & \\\\\n\\hline\n1 & R & X0 & & \\\\\n\\hline\n2 & W & X2 & & \\\\\n\\hline\n2 & R & X0 & & \\\\\n\\hline\n\\end{tabular}\n\\caption{(2) attachment2.csv: 各基本块读写的变量信息}\n\\end{table}\n\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n0 & 1 & 2 & \\dots \\\\\n\\hline\n1 & 3 & & \\dots \\\\\n\\hline\n2 & 3 & & \\dots \\\\\n\\hline\n3 & & & \\dots \\\\\n\\hline\n\\end{tabular}\n\\caption{(3) attachment3.csv: 各基本块在流程图中的邻接基本块信息}\n\\end{table}\n\n依据attachment3.csv，可以构建起基本块执行的流程图，如图C-1所示。依据基本块流程图和控制依赖的定义可以知道：基本块0和基本块1存在控制依赖，基本块0和基本块2也存在控制依赖。在流程图中，1号基本块和2号基本块位于0号基本块下游，由于0号基本块写了变量X0，1号基本块和2号基本块均读了变量X0，因此0号基本块和1号基本块存在写后读数据依赖，0号基本块和2号基本块也存在数据依赖。综合依赖关系来看，1号基本块和2号基本块排布的级数需要大于0号基本块排布的级数。\n\n\\begin{figure}[h]\n    \\centering\n    \\begin{tikzpicture}[node distance=2cm]\n        \\node (0) {0};\n        \\node (1) [below left of=0] {1};\n        \\node (2) [below right of=0] {2};\n        \\node (3) [below of=1, right of=2] {3};\n        \n        \\draw[->] (0) -- (1);\n        \\draw[->] (0) -- (2);\n        \\draw[->] (1) -- (3);\n        \\draw[->] (2) -- (3);\n    \\end{tikzpicture}\n    \\caption{基本块流程图示例}\n    \\label{fig:C-1}\n\\end{figure}\n\n在资源排布时，假设0号基本块排布到流水线第0级，则1号基本块和2号基本快排布的级数需要大于等于1，由于1号基本块和2号基本块放到一级时满足资源约束，因此1号基本块和2号基本块可以同时放到第1级。3号基本块放到第1级时超过资源约束（1号基本块和3号基本块均需要占据1个TCAM资源，而资源约束中一级流水线TCAM资源最多为1），因此3号基本块不能放到流水线第1级。将3号基本块放到第0级和第2级均可以满足依赖关系和资源约束，放到第0级时总共占用流水线2级，而放到第2级时总共占用流水线3级，因此将基本块3放到第0级更优。因此最优排布结果如下：\n\n\\begin{table}[h]\n    \\centering\n    \\begin{tabular}{|c|c|c|}\n        \\hline\n        流水线级数 & 分配的基本块编号 & \\\\\n        \\hline\n        0 & 0 & 3 \\\\\n        \\hline\n        1 & 1 & 2 \\\\\n        \\hline\n    \\end{tabular}\n    \\caption{最优排布结果}\n    \\label{tab:optimal_scheduling}\n\\end{table}\n\n事实上，最优排布结果更改了基本块在芯片底层执行的流程图，实际在芯片底层执行的流程图如图C-2所示。其中0号基本块和3号基本块均在芯片流水线第0级执行，1号基本块和2号基本块均在芯片流水线第1级执行。由于资源排布时考虑到了数据依赖和控制依赖，因此虽然最终执行的基本块流程图发生了变化，但程序原本的逻辑并没有被更改。更改流程图后占用的流水线级数更少，有利于充分利用芯片流水线资源。\n\n\\begin{figure}[h]\n    \\centering\n    \\begin{tikzpicture}[scale=1.5]\n        \\node[circle, draw] (0) at (0,0) {0};\n        \\node[circle, draw] (1) at (-1,-1) {1};\n        \\node[circle, draw] (2) at (1,-1) {2};\n        \\node[circle, draw] (3) at (0,1) {3};\n        \n        \\draw[->] (3) -- (0);\n        \\draw[->] (0) -- (1);\n        \\draw[->] (0) -- (2);\n        \n        \\draw[dashed] (-1.5,1.5) -- (1.5,1.5);\n        \\draw[dashed] (-1.5,-1.5) -- (1.5,-1.5);\n        \\draw[dashed] (-1.5,0.5) -- (1.5,0.5);\n        \\draw[dashed] (-1.5,-0.5) -- (1.5,-0.5);\n        \n        \\node[right] at (1.75,0.5) {流水线第0级执行};\n        \\node[right] at (1.75,-0.5) {流水线第1级执行};\n    \\end{tikzpicture}\n    \\caption{芯片底层实际执行的流程图}\n    \\label{fig:chip_flowchart}\n\\end{figure}\nDataset Path:\n['attachment1.csv', 'attachment2.csv', 'attachment3.csv']\n\nData Description:\n该数据集由三部分文件组成：attachment1（按基本块汇总的资源使用情况）、attachment2（基本块的读写变量信息）和attachment3.csv（基本块之间的跳转关系）。attachment1 为每个基本块提供了四类硬件/逻辑资源的使用量字段 TCAM、HASH、ALU 和 QUALIFY，并以基本块编号（BLOCK）为索引，数值类型表示各类资源的占用数量；attachment2 每行表示一个基本块，格式为“基本块编号,写入的变量,读取的变量”，其中写入或读取项可为空，变量以逗号分隔，便于进行数据依赖、活性分析和定义-使用链构建；attachment3.csv 每行列出对应基本块可以跳转到的目标基本块索引（例如“0,1,2”表示基本块0可跳转至1和2），用于构建控制流图（CFG）。结合三部分数据可以将控制流（来自 attachment3）、数据流（来自 attachment2）和资源分布（来自 attachment1）关联起来，用于识别资源热点、检测并行/串行依赖、进行寄存器或表资源分配优化、基本块合并或分割建议、死代码检测和性能瓶颈分析；字段类型为整数编号与逗号分隔的变量列表，文件格式为逐行记录的文本/CSV 结构，适合静态分析、可视化和自动化优化工具输入。",
  "problem": {
    "background": "芯片是电子行业的基础，在当前日益复杂的国际形势下，芯片成了各个大国必争的高科技技术。本课题关注网络通信领域的交换芯片，传统的交换芯片功能固定，当出现新的网络协议时，必须重新设计芯片，而芯片从设计到使用，往往需要几年的时间，因此固定功能的交换芯片大大降低了研发效率，为了解决此问题，诞生了可编程的交换芯片。PISA（Protocol Independent Switch Architecture）是当前主流的可编程交换芯片架构之一，其有着和固定功能交换芯片相当的处理速率，同时兼具了可编程性，在未来网络中具有广阔的应用场景[1-2]。\n\n在对PISA架构作进一步说明之前我们首先澄清几个基本概念：\n\n1. 报文：报文即网络通信中传输的数据包，在网络通信中，用户传输的数据被封装成一个个的数据包进行传输。\n\n2. 基本块：基本块是源程序的一个程序片段，对源程序进行基本块划分会将源程序划分为一个个的基本块。至于基本块如何划分本身也是一个值得探讨的问题，但超出了本问题的范围，在此不再多加赘述。\n\n3. 流水线：流水线为一系列处理单元串联构成，报文在流水线中按次序依次通过每个处理单元，最终完成处理。流水线各级即是指流水线中各处理单元。\n\nPISA架构如图1所示，其包括报文解析（parser）、多级的报文处理流水线（Pipeline Pocket Process）、以及报文重组（Deparser）三个组成部分。报文解析用于识别报文种类；多级的报文处理流水线用于修改报文数据，在实际的PISA架构芯片中，不同的芯片流水线的级数可能不同；报文重组用于报文重新组装。本课题只关注其中多级的报文处理流水线部分。在PISA架构编程模型中，用户使用P4语言描述报文处理行为得到P4程序，再由编译器编译P4程序，进而生成芯片上可以执行的机器码。编译器在编译P4程序时，会首先将P4程序划分为一系列的基本块，再将各基本块排布到流水线各级当中。由于各基本块均会占用一定的芯片资源，将基本块排布到流水线各级即是将各基本块的资源排布到流水线各级当中（即需要确定每个基本块排布到流水线哪一级），因此我们将基本块的排布问题称作 PISA 架构芯片资源排布问题。在实际的 PISA 架构芯片的设计中，为了减少连线的复杂度，往往对流水线各级的资源、以及流水线各级之间的资源有着多种多样的约束条件，这一系列复杂的资源约束条件使得资源排布问题尤为困难。然而，芯片的各类资源均有限，越高的资源利用率意味着能够越好的发挥芯片的能力，让芯片支持更多的业务，因此，高资源利用率的资源排布算法对于编译器设计至关重要。",
    "problem_requirement": "由基本块定义可知基本块为源程序的片段，基本块中会执行指令来完成计算，指令执行时会读取指令源操作数（即读源操作数对应的变量）进行计算，再将计算结果赋值给目的操作数（即写目的操作数对应的变量）。对于划分好的基本块，每个基本块中的指令并行执行，执行时按照先读后写的顺序（由芯片底层实现所决定），即先同时读出所有的目的操作数，再并行执行所有指令的计算，最后同时将计算结果赋值给目的操作数。由于并行向同一个变量写多次时存在冲突，因此每个基本块只会写同一个变量一次（即基本块中不存在多条指令对相同变量赋值）。\n\n基本块可以被抽象成一个节点，抽象后基本块中执行的具体指令被屏蔽，只保留读写的变量信息。当基本块 A 执行完可以跳转到基本块 B 执行时，在 A 和 B 之间增加一条有向边，这样 P4 程序即可表示为一个有向无环图（P4 程序不存在循环），称作 P4 程序流程图，如图 2 左图所示。PISA 架构资源排布即是将 P4 程序流程图中的各节点（即各基本块）在满足约束条件下排布到流水线各级当中。约束条件来自于两方面，一方面来自于 P4 程序本身，P4 程序每个基本块均会写一部分变量（即对变量赋值）和读一部分变量，变量的读写使得基本块之间存在数据依赖，同时，基本块执行完后可能跳转到多个基本块执行，从而使得基本块之间也存在着控制依赖，数据依赖和控制依赖约束了基本块排布的流水线级数的大小关系，关于数据依赖和控制依赖的详细说明参见附录A；另一方面的约束条件来自于芯片的资源约束，芯片中的资源包括TCAM、HASH、ALU、QUALIFY四类（附录B中解释了四类资源的作用以供感兴趣的同学进一步了解，不了解并不影响问题作答）。流水线中针对于这四类资源有着严格的限制（具体的资源限制在赛题中进行说明），资源排布时不能违反芯片的资源限制。\n\n本问题中，输入数据给出了各基本块在P4程序流程图中的邻接关系，各基本块占用的四类资源的数量，以及各基本块读写的变量信息，本问题的赛题总共包括两个子问题，需要同学们在满足上述数据依赖、控制依赖、以及各具体子问题的资源约束条件下进行资源排布，并充分考虑各子问题的优化目标，以求最大化芯片资源利用率。\n\n图2  PISA架构资源排布示意图\n\n\\section{输入数据说明}\n\n输入数据包含三个附件，分别给出了各基本块资源使用情况、各基本块读写的变量信息，以及各基本块在流图中的邻接基本块。各附件格式如下：\n\n\\subsection{(1) attachment1.csv: 各基本块使用的资源信息}\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & TCAM & HASH & ALU & QUALIFY \\\\\n\\hline\n0 & 0 & 0 & 2 & 0 \\\\\n1 & 0 & 0 & 0 & 0 \\\\\n2 & 0 & 0 & 0 & 0 \\\\\n3 & 0 & 0 & 0 & 0 \\\\\n4 & 0 & 0 & 10 & 3 \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列为基本块编号，第2列到第5列为各基本块使用的四种资源的数目。资源总共分为四种（TCAM, HASH, ALU, QUALIFY）。例如，0号基本块需要占用2个ALU资源，4号基本块需要占用10个ALU资源和3个Qualify资源。\n\n\\subsection{(2) attachment2.csv: 各基本块读写的变量信息}\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & W/R & Var1 & Var2 & Var3 \\\\\n\\hline\n0 & W & X0 & X1 &  \\\\\n0 & R &  &  &  \\\\\n1 & W &  &  &  \\\\\n1 & R &  &  &  \\\\\n2 & W &  &  &  \\\\\n2 & R &  &  &  \\\\\n3 & W &  &  &  \\\\\n3 & R &  &  &  \\\\\n4 & W & X5 & X6 &  \\\\\n4 & R & X23 & X24 &  \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列表示基本块编号，第二列中“W”表示写，“R”表示读，后续列表示基本块写或者读的变量。当某一行从第三列及以后没有任何元素时，说明此编号的基本块没有写（或读）任何变量（此时该基本块仅作为连接其他基本块的中间基本块，没有执行任何计算）。例如：0号基本块写了变量X0、X1，但没有读任何变量；1号基本块既没有写任何变量，也没有读任何变量。\\subsection{(3) attachment3.csv: 各基本块在流程图中的邻接基本块信息}\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n0 & 1 & 2 & ... \\\\\n\\hline\n1 & 2 &   & ... \\\\\n\\hline\n2 &   &   & ... \\\\\n\\hline\n3 & 31 &   & ... \\\\\n\\hline\n4 & 0 & 586 & ... \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列为基本块编号，后续列为与当前基本块在流程图中邻接的基本块编号，即在流程图中，本基本块到后续列中的基本块之间存在有向边连接。例如，由上表第一行可知，0号基本块到1号基本块和2号基本块之间存在有向边连接（即0号基本块执行结束后可以跳转到1号基本块或2号基本块执行）；由第三行可知从2号基本块出发没有边（即基本块2执行后程序结束，不会再跳转到其它基本块执行）。通过此文件可以确定基本块在源程序的执行顺序，确定每个基本块执行后跳转的目的基本块，进而构建起基本块的流程图。\\section{问题}\n\n本题需要建立资源排布问题的数学模型，并在此基础上处理如下两个问题：\n\n\\subsection{问题1} 给定资源约束条件如下：\n\n\\begin{enumerate}\n  \\item 流水线每级的 TCAM 资源最大为 1；\n  \\item 流水线每级的 HASH 资源最大为 2；\n  \\item 流水线每级的 ALU 资源最大为 56；\n  \\item 流水线每级的 QUALIFY 资源最大为 64；\n  \\item 约定流水线第 0 级与第 16 级，第 1 级与第 17 级，…，第 15 级与第 31 级为折叠级数，折叠的两级 TCAM 资源加起来最大为 1，HASH 资源加起来最大为 3。注：如果需要的流水线级数超过 32 级，则从第 32 开始的级数不考虑折叠资源限制；\n  \\item 有 TCAM 资源的偶数级数量不超过 5；\n  \\item 每个基本块只能排布到一级。\n\\end{enumerate}\n\n在上述资源约束条件下进行资源排布，并以占用的流水线级数尽量最少为优化目标。请给出资源排布算法，输出基本块排布结果，输出的结果格式如下：\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\n流水线级数 & 分配的基本块编号 &  &  &  \\\\\n\\hline\n0 & xxx & xxx & xxx & xxx \\\\\n1 & xxx & xxx & xxx & xxx \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n\\subsection{问题2} 考虑图 3 所示的流程图，基本块 2 和基本块 3 不在一条执行流程上（因为基本块 1 执行完后要么执行基本块 2，要么执行基本块 3，基本块 2 和基本块 3 不可能都执行）。准确来说，在 P4 程序流程图中，由一个基本块出发可以到达另一个基本块则说明两基本块在一条执行流程上，反之不在一条执行流程上。对于这种不在一条执行流程上的基本块，可以共享 HASH 资源和 ALU 资源，基本块 2 和 3 任意一个的 HASH 资源与 ALU 资源均不超过每级资源限制，基本块 2 和 3 即可排布到同一级。根据问题1中的约束条件 (2)、(3)、(5) 作如下更改：\n\n\\begin{enumerate}\n  \\item (2) 流水线每级中同一条执行流程上的基本块的 HASH 资源之和最大为 2；\n  \\item (3)流水线每级中同一条执行流程上的基本块的 ALU 资源之和最大为 56；\n  \\item (5)折叠的两级，对于 TCAM 资源约束不变，对于 HASH 资源，每级分别计算同一条执行流程上的基本块占用的 HASH 资源，再将两级的计算结果相加，结果不超过 3。\n\\end{enumerate}\n\n其它约束条件同问题 1。更改资源约束条件后重新考虑问题 1，给出排布算法，输出基本块排布结果。输出格式同问题 1。\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.4\\textwidth]{flow_example.png}\n\\caption{流程图示例}\n\\end{figure}",
    "dataset_path": [
      "attachment1.csv",
      "attachment2.csv",
      "attachment3.csv"
    ],
    "dataset_description": {
      "attachment1": "attachment1包含了不同基本块在P4程序中的资源使用情况。每个基本块的资源使用情况由TCAM、HASH、ALU和QUALIFY四个字段表示。",
      "attachment2": "attachment2包含了基本块的读写信息，每个条目表示一个基本块，其中包含基本块的编号、读取的变量和写入的变量。文件中的每一行代表一个基本块，格式为：基本块编号,写入的变量,读取的变量。如果基本块没有写入或读取操作，则相应位置为空。",
      "attachment3": "attachment3.csv包含了基本块之间的跳转关系。每一行代表一个基本块，其内容表示该基本块可以跳转到的其他基本块的索引。例如，第一行 '0,1,2' 表示基本块0可以跳转到基本块1和基本块2。"
    },
    "variable_description": [
      {
        "BLOCK": "基本块的编号",
        "TCAM": "基本块中使用的TCAM资源数量",
        "HASH": "基本块中使用的HASH资源数量",
        "ALU": "基本块中使用的ALU资源数量",
        "QUALIFY": "基本块中使用的QUALIFY资源数量"
      },
      {
        "基本块编号": "表示基本块的唯一标识符，整数类型。",
        "写入的变量": "表示基本块中写入的变量列表，多个变量用逗号分隔。",
        "读取的变量": "表示基本块中读取的变量列表，多个变量用逗号分隔。"
      },
      {}
    ],
    "addendum": "参考文献\nBosshart P, Daly D, Gibb G, et al. P4: Programming protocol-independent packet processors[J]. ACM SIGCOMM Computer Communication Review, 2014, 44(3): 87-95.\nBosshart P, Gibb G, Kim H S, et al. Forwarding metamorphosis: Fast programmable match-action processing in hardware for SDN[J]. ACM SIGCOMM Computer Communication Review, 2013, 43(4): 99-110.\n\n附录A\n1、数据依赖\n数据依赖是语句或代码块间数据流造成的一种约束。具体来说包含3种依赖方式：\n（1）S1在S2之前执行，当S1写某个变量而S2读该变量时，S1和S2存在写后读数据依赖。例如图A-1中，S1写了变量a，而S2读了变量a（使用a作条件判断），则S1和S2存在写后读依赖；S3写了变量d，而S4读了变量d（使用d作为指令的源），则S3和S4也存在写后读依赖。\n（2）S1在S2之前执行，当S1读某个变量而S2写该变量时，S1和S2存在读后写数据依赖。例如图A-1中，S3读了变量e（使用e作指令的源），而S4写了变量e，则S3和S4存在读后写依赖。\n（3）S1在S2之前执行，当S1和S2均写某个变量时，S1和S2存在写后写数据依赖。例如图A-1中，S3和S5均写了变量d，则S3和S5存在写后写依赖。\n\n\n图A-1  数据依赖示例\n\n在PISA架构中，当基本块A和B存在写后读数据依赖或写后写数据依赖时，基本块A排布的流水线级数需要小于基本块B排布的级数，比如基本块B被排到了流水线第10级，则基本块A只能排到流水线第0级到第9级；当基本块A和B存在读后写数据依赖时，基本块A排布的流水线级数需要小于或等于基本块B排布的级数，比如基本块B被排到流水线第10级，则基本块A只能排到第0级到第10级。\n2、控制依赖\n控制依赖是程序控制流导致的一种约束。控制依赖定义为：当从某个基本块出发的路径，只有部分路径通过下游某个基本块时，两基本块构成控制依赖。如图A-2所示的控制流图，B1与B2、B5、B6、B7、B8之间存在控制依赖，B5与B6、B8之间存在控制依赖，但B5和B7不构成控制依赖，因为从B5出发的两条路径下游都会经过B7。在PISA架构中，如果基本块A与基本块B存在控制依赖，则A排布的流水线级数需要小于或等于B排布的流水线级数。\n\n\n图A-2  控制依赖示例\n\n附录B\n为了说明TCAM、HASH、ALU、QUALIFY四类资源的作用，我们需要对P4语言有一个简单的了解。表项是P4程序的基本元素之一，P4程序中的表项包括key和action两个基本属性，表项在芯片底层由一条条的条目构成，P4程序执行表项时会使用key去条目中查找，命中一个条目后会从条目中取出源数据，再将取出的数据放到action的指令中去执行。关于表项的详细说明可参见如下网址的P4语言标准文档：https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html.\n在简单了解P4语言后，我们进一步说明四类资源的具体作用。\nTCAM和HASH：TCAM和HASH都是芯片中的表项资源，P4程序中可定义类型为TCAM或HASH的表项，类型为TCAM的表项需要占据芯片TCAM资源，类型为HASH的表项需要占用芯片HASH资源；\nALU：如上所述，表项执行时需要从条目中取出源数据放到action的指令中执行，指令的执行在芯片中需要放到ALU中进行，因此action中的指令需要占用ALU资源；\nQUALIFY：在P4程序中有做条件判断的if-else语句（含义同其它高级语言），if-else语句中的条件判断在执行时需要放到芯片QUALIFY中进行，需要占用QUALIFY资源。\n附录C\n资源约束以赛题中问题1的资源约束为准，假设输入数据如下：\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & TCAM & HASH & ALU & QUALIFY \\\\\n\\hline\n0 & 0 & 0 & 2 & 0 \\\\\n\\hline\n1 & 1 & 0 & 0 & 0 \\\\\n\\hline\n2 & 0 & 0 & 0 & 0 \\\\\n\\hline\n3 & 1 & 0 & 0 & 0 \\\\\n\\hline\n\\end{tabular}\n\\caption{(1) attachment1.csv: 各基本块使用的资源信息}\n\\end{table}\n\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\n0 & W & X0 & & \\\\\n\\hline\n0 & R & & & \\\\\n\\hline\n1 & W & X1 & & \\\\\n\\hline\n1 & R & X0 & & \\\\\n\\hline\n2 & W & X2 & & \\\\\n\\hline\n2 & R & X0 & & \\\\\n\\hline\n\\end{tabular}\n\\caption{(2) attachment2.csv: 各基本块读写的变量信息}\n\\end{table}\n\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n0 & 1 & 2 & \\dots \\\\\n\\hline\n1 & 3 & & \\dots \\\\\n\\hline\n2 & 3 & & \\dots \\\\\n\\hline\n3 & & & \\dots \\\\\n\\hline\n\\end{tabular}\n\\caption{(3) attachment3.csv: 各基本块在流程图中的邻接基本块信息}\n\\end{table}\n\n依据attachment3.csv，可以构建起基本块执行的流程图，如图C-1所示。依据基本块流程图和控制依赖的定义可以知道：基本块0和基本块1存在控制依赖，基本块0和基本块2也存在控制依赖。在流程图中，1号基本块和2号基本块位于0号基本块下游，由于0号基本块写了变量X0，1号基本块和2号基本块均读了变量X0，因此0号基本块和1号基本块存在写后读数据依赖，0号基本块和2号基本块也存在数据依赖。综合依赖关系来看，1号基本块和2号基本块排布的级数需要大于0号基本块排布的级数。\n\n\\begin{figure}[h]\n    \\centering\n    \\begin{tikzpicture}[node distance=2cm]\n        \\node (0) {0};\n        \\node (1) [below left of=0] {1};\n        \\node (2) [below right of=0] {2};\n        \\node (3) [below of=1, right of=2] {3};\n        \n        \\draw[->] (0) -- (1);\n        \\draw[->] (0) -- (2);\n        \\draw[->] (1) -- (3);\n        \\draw[->] (2) -- (3);\n    \\end{tikzpicture}\n    \\caption{基本块流程图示例}\n    \\label{fig:C-1}\n\\end{figure}\n\n在资源排布时，假设0号基本块排布到流水线第0级，则1号基本块和2号基本快排布的级数需要大于等于1，由于1号基本块和2号基本块放到一级时满足资源约束，因此1号基本块和2号基本块可以同时放到第1级。3号基本块放到第1级时超过资源约束（1号基本块和3号基本块均需要占据1个TCAM资源，而资源约束中一级流水线TCAM资源最多为1），因此3号基本块不能放到流水线第1级。将3号基本块放到第0级和第2级均可以满足依赖关系和资源约束，放到第0级时总共占用流水线2级，而放到第2级时总共占用流水线3级，因此将基本块3放到第0级更优。因此最优排布结果如下：\n\n\\begin{table}[h]\n    \\centering\n    \\begin{tabular}{|c|c|c|}\n        \\hline\n        流水线级数 & 分配的基本块编号 & \\\\\n        \\hline\n        0 & 0 & 3 \\\\\n        \\hline\n        1 & 1 & 2 \\\\\n        \\hline\n    \\end{tabular}\n    \\caption{最优排布结果}\n    \\label{tab:optimal_scheduling}\n\\end{table}\n\n事实上，最优排布结果更改了基本块在芯片底层执行的流程图，实际在芯片底层执行的流程图如图C-2所示。其中0号基本块和3号基本块均在芯片流水线第0级执行，1号基本块和2号基本块均在芯片流水线第1级执行。由于资源排布时考虑到了数据依赖和控制依赖，因此虽然最终执行的基本块流程图发生了变化，但程序原本的逻辑并没有被更改。更改流程图后占用的流水线级数更少，有利于充分利用芯片流水线资源。\n\n\\begin{figure}[h]\n    \\centering\n    \\begin{tikzpicture}[scale=1.5]\n        \\node[circle, draw] (0) at (0,0) {0};\n        \\node[circle, draw] (1) at (-1,-1) {1};\n        \\node[circle, draw] (2) at (1,-1) {2};\n        \\node[circle, draw] (3) at (0,1) {3};\n        \n        \\draw[->] (3) -- (0);\n        \\draw[->] (0) -- (1);\n        \\draw[->] (0) -- (2);\n        \n        \\draw[dashed] (-1.5,1.5) -- (1.5,1.5);\n        \\draw[dashed] (-1.5,-1.5) -- (1.5,-1.5);\n        \\draw[dashed] (-1.5,0.5) -- (1.5,0.5);\n        \\draw[dashed] (-1.5,-0.5) -- (1.5,-0.5);\n        \n        \\node[right] at (1.75,0.5) {流水线第0级执行};\n        \\node[right] at (1.75,-0.5) {流水线第1级执行};\n    \\end{tikzpicture}\n    \\caption{芯片底层实际执行的流程图}\n    \\label{fig:chip_flowchart}\n\\end{figure}",
    "data_summary": "Dataset Path:\n['attachment1.csv', 'attachment2.csv', 'attachment3.csv']\n\nData Description:\n该数据集由三部分文件组成：attachment1（按基本块汇总的资源使用情况）、attachment2（基本块的读写变量信息）和attachment3.csv（基本块之间的跳转关系）。attachment1 为每个基本块提供了四类硬件/逻辑资源的使用量字段 TCAM、HASH、ALU 和 QUALIFY，并以基本块编号（BLOCK）为索引，数值类型表示各类资源的占用数量；attachment2 每行表示一个基本块，格式为“基本块编号,写入的变量,读取的变量”，其中写入或读取项可为空，变量以逗号分隔，便于进行数据依赖、活性分析和定义-使用链构建；attachment3.csv 每行列出对应基本块可以跳转到的目标基本块索引（例如“0,1,2”表示基本块0可跳转至1和2），用于构建控制流图（CFG）。结合三部分数据可以将控制流（来自 attachment3）、数据流（来自 attachment2）和资源分布（来自 attachment1）关联起来，用于识别资源热点、检测并行/串行依赖、进行寄存器或表资源分配优化、基本块合并或分割建议、死代码检测和性能瓶颈分析；字段类型为整数编号与逗号分隔的变量列表，文件格式为逐行记录的文本/CSV 结构，适合静态分析、可视化和自动化优化工具输入。",
    "data_description": {
      "attachment1": "attachment1包含了不同基本块在P4程序中的资源使用情况。每个基本块的资源使用情况由TCAM、HASH、ALU和QUALIFY四个字段表示。",
      "attachment2": "attachment2包含了基本块的读写信息，每个条目表示一个基本块，其中包含基本块的编号、读取的变量和写入的变量。文件中的每一行代表一个基本块，格式为：基本块编号,写入的变量,读取的变量。如果基本块没有写入或读取操作，则相应位置为空。",
      "attachment3": "attachment3.csv包含了基本块之间的跳转关系。每一行代表一个基本块，其内容表示该基本块可以跳转到的其他基本块的索引。例如，第一行 '0,1,2' 表示基本块0可以跳转到基本块1和基本块2。"
    },
    "problem_str": "问题背景：\n芯片是电子行业的基础，在当前日益复杂的国际形势下，芯片成了各个大国必争的高科技技术。本课题关注网络通信领域的交换芯片，传统的交换芯片功能固定，当出现新的网络协议时，必须重新设计芯片，而芯片从设计到使用，往往需要几年的时间，因此固定功能的交换芯片大大降低了研发效率，为了解决此问题，诞生了可编程的交换芯片。PISA（Protocol Independent Switch Architecture）是当前主流的可编程交换芯片架构之一，其有着和固定功能交换芯片相当的处理速率，同时兼具了可编程性，在未来网络中具有广阔的应用场景[1-2]。\n\n在对PISA架构作进一步说明之前我们首先澄清几个基本概念：\n\n1. 报文：报文即网络通信中传输的数据包，在网络通信中，用户传输的数据被封装成一个个的数据包进行传输。\n\n2. 基本块：基本块是源程序的一个程序片段，对源程序进行基本块划分会将源程序划分为一个个的基本块。至于基本块如何划分本身也是一个值得探讨的问题，但超出了本问题的范围，在此不再多加赘述。\n\n3. 流水线：流水线为一系列处理单元串联构成，报文在流水线中按次序依次通过每个处理单元，最终完成处理。流水线各级即是指流水线中各处理单元。\n\nPISA架构如图1所示，其包括报文解析（parser）、多级的报文处理流水线（Pipeline Pocket Process）、以及报文重组（Deparser）三个组成部分。报文解析用于识别报文种类；多级的报文处理流水线用于修改报文数据，在实际的PISA架构芯片中，不同的芯片流水线的级数可能不同；报文重组用于报文重新组装。本课题只关注其中多级的报文处理流水线部分。在PISA架构编程模型中，用户使用P4语言描述报文处理行为得到P4程序，再由编译器编译P4程序，进而生成芯片上可以执行的机器码。编译器在编译P4程序时，会首先将P4程序划分为一系列的基本块，再将各基本块排布到流水线各级当中。由于各基本块均会占用一定的芯片资源，将基本块排布到流水线各级即是将各基本块的资源排布到流水线各级当中（即需要确定每个基本块排布到流水线哪一级），因此我们将基本块的排布问题称作 PISA 架构芯片资源排布问题。在实际的 PISA 架构芯片的设计中，为了减少连线的复杂度，往往对流水线各级的资源、以及流水线各级之间的资源有着多种多样的约束条件，这一系列复杂的资源约束条件使得资源排布问题尤为困难。然而，芯片的各类资源均有限，越高的资源利用率意味着能够越好的发挥芯片的能力，让芯片支持更多的业务，因此，高资源利用率的资源排布算法对于编译器设计至关重要。\n\n问题要求：\n由基本块定义可知基本块为源程序的片段，基本块中会执行指令来完成计算，指令执行时会读取指令源操作数（即读源操作数对应的变量）进行计算，再将计算结果赋值给目的操作数（即写目的操作数对应的变量）。对于划分好的基本块，每个基本块中的指令并行执行，执行时按照先读后写的顺序（由芯片底层实现所决定），即先同时读出所有的目的操作数，再并行执行所有指令的计算，最后同时将计算结果赋值给目的操作数。由于并行向同一个变量写多次时存在冲突，因此每个基本块只会写同一个变量一次（即基本块中不存在多条指令对相同变量赋值）。\n\n基本块可以被抽象成一个节点，抽象后基本块中执行的具体指令被屏蔽，只保留读写的变量信息。当基本块 A 执行完可以跳转到基本块 B 执行时，在 A 和 B 之间增加一条有向边，这样 P4 程序即可表示为一个有向无环图（P4 程序不存在循环），称作 P4 程序流程图，如图 2 左图所示。PISA 架构资源排布即是将 P4 程序流程图中的各节点（即各基本块）在满足约束条件下排布到流水线各级当中。约束条件来自于两方面，一方面来自于 P4 程序本身，P4 程序每个基本块均会写一部分变量（即对变量赋值）和读一部分变量，变量的读写使得基本块之间存在数据依赖，同时，基本块执行完后可能跳转到多个基本块执行，从而使得基本块之间也存在着控制依赖，数据依赖和控制依赖约束了基本块排布的流水线级数的大小关系，关于数据依赖和控制依赖的详细说明参见附录A；另一方面的约束条件来自于芯片的资源约束，芯片中的资源包括TCAM、HASH、ALU、QUALIFY四类（附录B中解释了四类资源的作用以供感兴趣的同学进一步了解，不了解并不影响问题作答）。流水线中针对于这四类资源有着严格的限制（具体的资源限制在赛题中进行说明），资源排布时不能违反芯片的资源限制。\n\n本问题中，输入数据给出了各基本块在P4程序流程图中的邻接关系，各基本块占用的四类资源的数量，以及各基本块读写的变量信息，本问题的赛题总共包括两个子问题，需要同学们在满足上述数据依赖、控制依赖、以及各具体子问题的资源约束条件下进行资源排布，并充分考虑各子问题的优化目标，以求最大化芯片资源利用率。\n\n图2  PISA架构资源排布示意图\n\n\\section{输入数据说明}\n\n输入数据包含三个附件，分别给出了各基本块资源使用情况、各基本块读写的变量信息，以及各基本块在流图中的邻接基本块。各附件格式如下：\n\n\\subsection{(1) attachment1.csv: 各基本块使用的资源信息}\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & TCAM & HASH & ALU & QUALIFY \\\\\n\\hline\n0 & 0 & 0 & 2 & 0 \\\\\n1 & 0 & 0 & 0 & 0 \\\\\n2 & 0 & 0 & 0 & 0 \\\\\n3 & 0 & 0 & 0 & 0 \\\\\n4 & 0 & 0 & 10 & 3 \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列为基本块编号，第2列到第5列为各基本块使用的四种资源的数目。资源总共分为四种（TCAM, HASH, ALU, QUALIFY）。例如，0号基本块需要占用2个ALU资源，4号基本块需要占用10个ALU资源和3个Qualify资源。\n\n\\subsection{(2) attachment2.csv: 各基本块读写的变量信息}\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & W/R & Var1 & Var2 & Var3 \\\\\n\\hline\n0 & W & X0 & X1 &  \\\\\n0 & R &  &  &  \\\\\n1 & W &  &  &  \\\\\n1 & R &  &  &  \\\\\n2 & W &  &  &  \\\\\n2 & R &  &  &  \\\\\n3 & W &  &  &  \\\\\n3 & R &  &  &  \\\\\n4 & W & X5 & X6 &  \\\\\n4 & R & X23 & X24 &  \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列表示基本块编号，第二列中“W”表示写，“R”表示读，后续列表示基本块写或者读的变量。当某一行从第三列及以后没有任何元素时，说明此编号的基本块没有写（或读）任何变量（此时该基本块仅作为连接其他基本块的中间基本块，没有执行任何计算）。例如：0号基本块写了变量X0、X1，但没有读任何变量；1号基本块既没有写任何变量，也没有读任何变量。\\subsection{(3) attachment3.csv: 各基本块在流程图中的邻接基本块信息}\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n0 & 1 & 2 & ... \\\\\n\\hline\n1 & 2 &   & ... \\\\\n\\hline\n2 &   &   & ... \\\\\n\\hline\n3 & 31 &   & ... \\\\\n\\hline\n4 & 0 & 586 & ... \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列为基本块编号，后续列为与当前基本块在流程图中邻接的基本块编号，即在流程图中，本基本块到后续列中的基本块之间存在有向边连接。例如，由上表第一行可知，0号基本块到1号基本块和2号基本块之间存在有向边连接（即0号基本块执行结束后可以跳转到1号基本块或2号基本块执行）；由第三行可知从2号基本块出发没有边（即基本块2执行后程序结束，不会再跳转到其它基本块执行）。通过此文件可以确定基本块在源程序的执行顺序，确定每个基本块执行后跳转的目的基本块，进而构建起基本块的流程图。\\section{问题}\n\n本题需要建立资源排布问题的数学模型，并在此基础上处理如下两个问题：\n\n\\subsection{问题1} 给定资源约束条件如下：\n\n\\begin{enumerate}\n  \\item 流水线每级的 TCAM 资源最大为 1；\n  \\item 流水线每级的 HASH 资源最大为 2；\n  \\item 流水线每级的 ALU 资源最大为 56；\n  \\item 流水线每级的 QUALIFY 资源最大为 64；\n  \\item 约定流水线第 0 级与第 16 级，第 1 级与第 17 级，…，第 15 级与第 31 级为折叠级数，折叠的两级 TCAM 资源加起来最大为 1，HASH 资源加起来最大为 3。注：如果需要的流水线级数超过 32 级，则从第 32 开始的级数不考虑折叠资源限制；\n  \\item 有 TCAM 资源的偶数级数量不超过 5；\n  \\item 每个基本块只能排布到一级。\n\\end{enumerate}\n\n在上述资源约束条件下进行资源排布，并以占用的流水线级数尽量最少为优化目标。请给出资源排布算法，输出基本块排布结果，输出的结果格式如下：\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\n流水线级数 & 分配的基本块编号 &  &  &  \\\\\n\\hline\n0 & xxx & xxx & xxx & xxx \\\\\n1 & xxx & xxx & xxx & xxx \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n\\subsection{问题2} 考虑图 3 所示的流程图，基本块 2 和基本块 3 不在一条执行流程上（因为基本块 1 执行完后要么执行基本块 2，要么执行基本块 3，基本块 2 和基本块 3 不可能都执行）。准确来说，在 P4 程序流程图中，由一个基本块出发可以到达另一个基本块则说明两基本块在一条执行流程上，反之不在一条执行流程上。对于这种不在一条执行流程上的基本块，可以共享 HASH 资源和 ALU 资源，基本块 2 和 3 任意一个的 HASH 资源与 ALU 资源均不超过每级资源限制，基本块 2 和 3 即可排布到同一级。根据问题1中的约束条件 (2)、(3)、(5) 作如下更改：\n\n\\begin{enumerate}\n  \\item (2) 流水线每级中同一条执行流程上的基本块的 HASH 资源之和最大为 2；\n  \\item (3)流水线每级中同一条执行流程上的基本块的 ALU 资源之和最大为 56；\n  \\item (5)折叠的两级，对于 TCAM 资源约束不变，对于 HASH 资源，每级分别计算同一条执行流程上的基本块占用的 HASH 资源，再将两级的计算结果相加，结果不超过 3。\n\\end{enumerate}\n\n其它约束条件同问题 1。更改资源约束条件后重新考虑问题 1，给出排布算法，输出基本块排布结果。输出格式同问题 1。\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.4\\textwidth]{flow_example.png}\n\\caption{流程图示例}\n\\end{figure}\nAddendum: \n参考文献\nBosshart P, Daly D, Gibb G, et al. P4: Programming protocol-independent packet processors[J]. ACM SIGCOMM Computer Communication Review, 2014, 44(3): 87-95.\nBosshart P, Gibb G, Kim H S, et al. Forwarding metamorphosis: Fast programmable match-action processing in hardware for SDN[J]. ACM SIGCOMM Computer Communication Review, 2013, 43(4): 99-110.\n\n附录A\n1、数据依赖\n数据依赖是语句或代码块间数据流造成的一种约束。具体来说包含3种依赖方式：\n（1）S1在S2之前执行，当S1写某个变量而S2读该变量时，S1和S2存在写后读数据依赖。例如图A-1中，S1写了变量a，而S2读了变量a（使用a作条件判断），则S1和S2存在写后读依赖；S3写了变量d，而S4读了变量d（使用d作为指令的源），则S3和S4也存在写后读依赖。\n（2）S1在S2之前执行，当S1读某个变量而S2写该变量时，S1和S2存在读后写数据依赖。例如图A-1中，S3读了变量e（使用e作指令的源），而S4写了变量e，则S3和S4存在读后写依赖。\n（3）S1在S2之前执行，当S1和S2均写某个变量时，S1和S2存在写后写数据依赖。例如图A-1中，S3和S5均写了变量d，则S3和S5存在写后写依赖。\n\n\n图A-1  数据依赖示例\n\n在PISA架构中，当基本块A和B存在写后读数据依赖或写后写数据依赖时，基本块A排布的流水线级数需要小于基本块B排布的级数，比如基本块B被排到了流水线第10级，则基本块A只能排到流水线第0级到第9级；当基本块A和B存在读后写数据依赖时，基本块A排布的流水线级数需要小于或等于基本块B排布的级数，比如基本块B被排到流水线第10级，则基本块A只能排到第0级到第10级。\n2、控制依赖\n控制依赖是程序控制流导致的一种约束。控制依赖定义为：当从某个基本块出发的路径，只有部分路径通过下游某个基本块时，两基本块构成控制依赖。如图A-2所示的控制流图，B1与B2、B5、B6、B7、B8之间存在控制依赖，B5与B6、B8之间存在控制依赖，但B5和B7不构成控制依赖，因为从B5出发的两条路径下游都会经过B7。在PISA架构中，如果基本块A与基本块B存在控制依赖，则A排布的流水线级数需要小于或等于B排布的流水线级数。\n\n\n图A-2  控制依赖示例\n\n附录B\n为了说明TCAM、HASH、ALU、QUALIFY四类资源的作用，我们需要对P4语言有一个简单的了解。表项是P4程序的基本元素之一，P4程序中的表项包括key和action两个基本属性，表项在芯片底层由一条条的条目构成，P4程序执行表项时会使用key去条目中查找，命中一个条目后会从条目中取出源数据，再将取出的数据放到action的指令中去执行。关于表项的详细说明可参见如下网址的P4语言标准文档：https://p4.org/p4-spec/docs/P4-16-v1.0.0-spec.html.\n在简单了解P4语言后，我们进一步说明四类资源的具体作用。\nTCAM和HASH：TCAM和HASH都是芯片中的表项资源，P4程序中可定义类型为TCAM或HASH的表项，类型为TCAM的表项需要占据芯片TCAM资源，类型为HASH的表项需要占用芯片HASH资源；\nALU：如上所述，表项执行时需要从条目中取出源数据放到action的指令中执行，指令的执行在芯片中需要放到ALU中进行，因此action中的指令需要占用ALU资源；\nQUALIFY：在P4程序中有做条件判断的if-else语句（含义同其它高级语言），if-else语句中的条件判断在执行时需要放到芯片QUALIFY中进行，需要占用QUALIFY资源。\n附录C\n资源约束以赛题中问题1的资源约束为准，假设输入数据如下：\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & TCAM & HASH & ALU & QUALIFY \\\\\n\\hline\n0 & 0 & 0 & 2 & 0 \\\\\n\\hline\n1 & 1 & 0 & 0 & 0 \\\\\n\\hline\n2 & 0 & 0 & 0 & 0 \\\\\n\\hline\n3 & 1 & 0 & 0 & 0 \\\\\n\\hline\n\\end{tabular}\n\\caption{(1) attachment1.csv: 各基本块使用的资源信息}\n\\end{table}\n\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\n0 & W & X0 & & \\\\\n\\hline\n0 & R & & & \\\\\n\\hline\n1 & W & X1 & & \\\\\n\\hline\n1 & R & X0 & & \\\\\n\\hline\n2 & W & X2 & & \\\\\n\\hline\n2 & R & X0 & & \\\\\n\\hline\n\\end{tabular}\n\\caption{(2) attachment2.csv: 各基本块读写的变量信息}\n\\end{table}\n\n\\begin{table}\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n0 & 1 & 2 & \\dots \\\\\n\\hline\n1 & 3 & & \\dots \\\\\n\\hline\n2 & 3 & & \\dots \\\\\n\\hline\n3 & & & \\dots \\\\\n\\hline\n\\end{tabular}\n\\caption{(3) attachment3.csv: 各基本块在流程图中的邻接基本块信息}\n\\end{table}\n\n依据attachment3.csv，可以构建起基本块执行的流程图，如图C-1所示。依据基本块流程图和控制依赖的定义可以知道：基本块0和基本块1存在控制依赖，基本块0和基本块2也存在控制依赖。在流程图中，1号基本块和2号基本块位于0号基本块下游，由于0号基本块写了变量X0，1号基本块和2号基本块均读了变量X0，因此0号基本块和1号基本块存在写后读数据依赖，0号基本块和2号基本块也存在数据依赖。综合依赖关系来看，1号基本块和2号基本块排布的级数需要大于0号基本块排布的级数。\n\n\\begin{figure}[h]\n    \\centering\n    \\begin{tikzpicture}[node distance=2cm]\n        \\node (0) {0};\n        \\node (1) [below left of=0] {1};\n        \\node (2) [below right of=0] {2};\n        \\node (3) [below of=1, right of=2] {3};\n        \n        \\draw[->] (0) -- (1);\n        \\draw[->] (0) -- (2);\n        \\draw[->] (1) -- (3);\n        \\draw[->] (2) -- (3);\n    \\end{tikzpicture}\n    \\caption{基本块流程图示例}\n    \\label{fig:C-1}\n\\end{figure}\n\n在资源排布时，假设0号基本块排布到流水线第0级，则1号基本块和2号基本快排布的级数需要大于等于1，由于1号基本块和2号基本块放到一级时满足资源约束，因此1号基本块和2号基本块可以同时放到第1级。3号基本块放到第1级时超过资源约束（1号基本块和3号基本块均需要占据1个TCAM资源，而资源约束中一级流水线TCAM资源最多为1），因此3号基本块不能放到流水线第1级。将3号基本块放到第0级和第2级均可以满足依赖关系和资源约束，放到第0级时总共占用流水线2级，而放到第2级时总共占用流水线3级，因此将基本块3放到第0级更优。因此最优排布结果如下：\n\n\\begin{table}[h]\n    \\centering\n    \\begin{tabular}{|c|c|c|}\n        \\hline\n        流水线级数 & 分配的基本块编号 & \\\\\n        \\hline\n        0 & 0 & 3 \\\\\n        \\hline\n        1 & 1 & 2 \\\\\n        \\hline\n    \\end{tabular}\n    \\caption{最优排布结果}\n    \\label{tab:optimal_scheduling}\n\\end{table}\n\n事实上，最优排布结果更改了基本块在芯片底层执行的流程图，实际在芯片底层执行的流程图如图C-2所示。其中0号基本块和3号基本块均在芯片流水线第0级执行，1号基本块和2号基本块均在芯片流水线第1级执行。由于资源排布时考虑到了数据依赖和控制依赖，因此虽然最终执行的基本块流程图发生了变化，但程序原本的逻辑并没有被更改。更改流程图后占用的流水线级数更少，有利于充分利用芯片流水线资源。\n\n\\begin{figure}[h]\n    \\centering\n    \\begin{tikzpicture}[scale=1.5]\n        \\node[circle, draw] (0) at (0,0) {0};\n        \\node[circle, draw] (1) at (-1,-1) {1};\n        \\node[circle, draw] (2) at (1,-1) {2};\n        \\node[circle, draw] (3) at (0,1) {3};\n        \n        \\draw[->] (3) -- (0);\n        \\draw[->] (0) -- (1);\n        \\draw[->] (0) -- (2);\n        \n        \\draw[dashed] (-1.5,1.5) -- (1.5,1.5);\n        \\draw[dashed] (-1.5,-1.5) -- (1.5,-1.5);\n        \\draw[dashed] (-1.5,0.5) -- (1.5,0.5);\n        \\draw[dashed] (-1.5,-0.5) -- (1.5,-0.5);\n        \n        \\node[right] at (1.75,0.5) {流水线第0级执行};\n        \\node[right] at (1.75,-0.5) {流水线第1级执行};\n    \\end{tikzpicture}\n    \\caption{芯片底层实际执行的流程图}\n    \\label{fig:chip_flowchart}\n\\end{figure}\nDataset Path:\n['attachment1.csv', 'attachment2.csv', 'attachment3.csv']\n\nData Description:\n该数据集由三部分文件组成：attachment1（按基本块汇总的资源使用情况）、attachment2（基本块的读写变量信息）和attachment3.csv（基本块之间的跳转关系）。attachment1 为每个基本块提供了四类硬件/逻辑资源的使用量字段 TCAM、HASH、ALU 和 QUALIFY，并以基本块编号（BLOCK）为索引，数值类型表示各类资源的占用数量；attachment2 每行表示一个基本块，格式为“基本块编号,写入的变量,读取的变量”，其中写入或读取项可为空，变量以逗号分隔，便于进行数据依赖、活性分析和定义-使用链构建；attachment3.csv 每行列出对应基本块可以跳转到的目标基本块索引（例如“0,1,2”表示基本块0可跳转至1和2），用于构建控制流图（CFG）。结合三部分数据可以将控制流（来自 attachment3）、数据流（来自 attachment2）和资源分布（来自 attachment1）关联起来，用于识别资源热点、检测并行/串行依赖、进行寄存器或表资源分配优化、基本块合并或分割建议、死代码检测和性能瓶颈分析；字段类型为整数编号与逗号分隔的变量列表，文件格式为逐行记录的文本/CSV 结构，适合静态分析、可视化和自动化优化工具输入。"
  },
  "problem_background": "芯片是电子行业的基础，在当前日益复杂的国际形势下，芯片成了各个大国必争的高科技技术。本课题关注网络通信领域的交换芯片，传统的交换芯片功能固定，当出现新的网络协议时，必须重新设计芯片，而芯片从设计到使用，往往需要几年的时间，因此固定功能的交换芯片大大降低了研发效率，为了解决此问题，诞生了可编程的交换芯片。PISA（Protocol Independent Switch Architecture）是当前主流的可编程交换芯片架构之一，其有着和固定功能交换芯片相当的处理速率，同时兼具了可编程性，在未来网络中具有广阔的应用场景[1-2]。\n\n在对PISA架构作进一步说明之前我们首先澄清几个基本概念：\n\n1. 报文：报文即网络通信中传输的数据包，在网络通信中，用户传输的数据被封装成一个个的数据包进行传输。\n\n2. 基本块：基本块是源程序的一个程序片段，对源程序进行基本块划分会将源程序划分为一个个的基本块。至于基本块如何划分本身也是一个值得探讨的问题，但超出了本问题的范围，在此不再多加赘述。\n\n3. 流水线：流水线为一系列处理单元串联构成，报文在流水线中按次序依次通过每个处理单元，最终完成处理。流水线各级即是指流水线中各处理单元。\n\nPISA架构如图1所示，其包括报文解析（parser）、多级的报文处理流水线（Pipeline Pocket Process）、以及报文重组（Deparser）三个组成部分。报文解析用于识别报文种类；多级的报文处理流水线用于修改报文数据，在实际的PISA架构芯片中，不同的芯片流水线的级数可能不同；报文重组用于报文重新组装。本课题只关注其中多级的报文处理流水线部分。在PISA架构编程模型中，用户使用P4语言描述报文处理行为得到P4程序，再由编译器编译P4程序，进而生成芯片上可以执行的机器码。编译器在编译P4程序时，会首先将P4程序划分为一系列的基本块，再将各基本块排布到流水线各级当中。由于各基本块均会占用一定的芯片资源，将基本块排布到流水线各级即是将各基本块的资源排布到流水线各级当中（即需要确定每个基本块排布到流水线哪一级），因此我们将基本块的排布问题称作 PISA 架构芯片资源排布问题。在实际的 PISA 架构芯片的设计中，为了减少连线的复杂度，往往对流水线各级的资源、以及流水线各级之间的资源有着多种多样的约束条件，这一系列复杂的资源约束条件使得资源排布问题尤为困难。然而，芯片的各类资源均有限，越高的资源利用率意味着能够越好的发挥芯片的能力，让芯片支持更多的业务，因此，高资源利用率的资源排布算法对于编译器设计至关重要。",
  "problem_requirement": "由基本块定义可知基本块为源程序的片段，基本块中会执行指令来完成计算，指令执行时会读取指令源操作数（即读源操作数对应的变量）进行计算，再将计算结果赋值给目的操作数（即写目的操作数对应的变量）。对于划分好的基本块，每个基本块中的指令并行执行，执行时按照先读后写的顺序（由芯片底层实现所决定），即先同时读出所有的目的操作数，再并行执行所有指令的计算，最后同时将计算结果赋值给目的操作数。由于并行向同一个变量写多次时存在冲突，因此每个基本块只会写同一个变量一次（即基本块中不存在多条指令对相同变量赋值）。\n\n基本块可以被抽象成一个节点，抽象后基本块中执行的具体指令被屏蔽，只保留读写的变量信息。当基本块 A 执行完可以跳转到基本块 B 执行时，在 A 和 B 之间增加一条有向边，这样 P4 程序即可表示为一个有向无环图（P4 程序不存在循环），称作 P4 程序流程图，如图 2 左图所示。PISA 架构资源排布即是将 P4 程序流程图中的各节点（即各基本块）在满足约束条件下排布到流水线各级当中。约束条件来自于两方面，一方面来自于 P4 程序本身，P4 程序每个基本块均会写一部分变量（即对变量赋值）和读一部分变量，变量的读写使得基本块之间存在数据依赖，同时，基本块执行完后可能跳转到多个基本块执行，从而使得基本块之间也存在着控制依赖，数据依赖和控制依赖约束了基本块排布的流水线级数的大小关系，关于数据依赖和控制依赖的详细说明参见附录A；另一方面的约束条件来自于芯片的资源约束，芯片中的资源包括TCAM、HASH、ALU、QUALIFY四类（附录B中解释了四类资源的作用以供感兴趣的同学进一步了解，不了解并不影响问题作答）。流水线中针对于这四类资源有着严格的限制（具体的资源限制在赛题中进行说明），资源排布时不能违反芯片的资源限制。\n\n本问题中，输入数据给出了各基本块在P4程序流程图中的邻接关系，各基本块占用的四类资源的数量，以及各基本块读写的变量信息，本问题的赛题总共包括两个子问题，需要同学们在满足上述数据依赖、控制依赖、以及各具体子问题的资源约束条件下进行资源排布，并充分考虑各子问题的优化目标，以求最大化芯片资源利用率。\n\n图2  PISA架构资源排布示意图\n\n\\section{输入数据说明}\n\n输入数据包含三个附件，分别给出了各基本块资源使用情况、各基本块读写的变量信息，以及各基本块在流图中的邻接基本块。各附件格式如下：\n\n\\subsection{(1) attachment1.csv: 各基本块使用的资源信息}\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & TCAM & HASH & ALU & QUALIFY \\\\\n\\hline\n0 & 0 & 0 & 2 & 0 \\\\\n1 & 0 & 0 & 0 & 0 \\\\\n2 & 0 & 0 & 0 & 0 \\\\\n3 & 0 & 0 & 0 & 0 \\\\\n4 & 0 & 0 & 10 & 3 \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列为基本块编号，第2列到第5列为各基本块使用的四种资源的数目。资源总共分为四种（TCAM, HASH, ALU, QUALIFY）。例如，0号基本块需要占用2个ALU资源，4号基本块需要占用10个ALU资源和3个Qualify资源。\n\n\\subsection{(2) attachment2.csv: 各基本块读写的变量信息}\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\nBLOCK & W/R & Var1 & Var2 & Var3 \\\\\n\\hline\n0 & W & X0 & X1 &  \\\\\n0 & R &  &  &  \\\\\n1 & W &  &  &  \\\\\n1 & R &  &  &  \\\\\n2 & W &  &  &  \\\\\n2 & R &  &  &  \\\\\n3 & W &  &  &  \\\\\n3 & R &  &  &  \\\\\n4 & W & X5 & X6 &  \\\\\n4 & R & X23 & X24 &  \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列表示基本块编号，第二列中“W”表示写，“R”表示读，后续列表示基本块写或者读的变量。当某一行从第三列及以后没有任何元素时，说明此编号的基本块没有写（或读）任何变量（此时该基本块仅作为连接其他基本块的中间基本块，没有执行任何计算）。例如：0号基本块写了变量X0、X1，但没有读任何变量；1号基本块既没有写任何变量，也没有读任何变量。\\subsection{(3) attachment3.csv: 各基本块在流程图中的邻接基本块信息}\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n0 & 1 & 2 & ... \\\\\n\\hline\n1 & 2 &   & ... \\\\\n\\hline\n2 &   &   & ... \\\\\n\\hline\n3 & 31 &   & ... \\\\\n\\hline\n4 & 0 & 586 & ... \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n表中第一列为基本块编号，后续列为与当前基本块在流程图中邻接的基本块编号，即在流程图中，本基本块到后续列中的基本块之间存在有向边连接。例如，由上表第一行可知，0号基本块到1号基本块和2号基本块之间存在有向边连接（即0号基本块执行结束后可以跳转到1号基本块或2号基本块执行）；由第三行可知从2号基本块出发没有边（即基本块2执行后程序结束，不会再跳转到其它基本块执行）。通过此文件可以确定基本块在源程序的执行顺序，确定每个基本块执行后跳转的目的基本块，进而构建起基本块的流程图。\\section{问题}\n\n本题需要建立资源排布问题的数学模型，并在此基础上处理如下两个问题：\n\n\\subsection{问题1} 给定资源约束条件如下：\n\n\\begin{enumerate}\n  \\item 流水线每级的 TCAM 资源最大为 1；\n  \\item 流水线每级的 HASH 资源最大为 2；\n  \\item 流水线每级的 ALU 资源最大为 56；\n  \\item 流水线每级的 QUALIFY 资源最大为 64；\n  \\item 约定流水线第 0 级与第 16 级，第 1 级与第 17 级，…，第 15 级与第 31 级为折叠级数，折叠的两级 TCAM 资源加起来最大为 1，HASH 资源加起来最大为 3。注：如果需要的流水线级数超过 32 级，则从第 32 开始的级数不考虑折叠资源限制；\n  \\item 有 TCAM 资源的偶数级数量不超过 5；\n  \\item 每个基本块只能排布到一级。\n\\end{enumerate}\n\n在上述资源约束条件下进行资源排布，并以占用的流水线级数尽量最少为优化目标。请给出资源排布算法，输出基本块排布结果，输出的结果格式如下：\n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|c|}\n\\hline\n流水线级数 & 分配的基本块编号 &  &  &  \\\\\n\\hline\n0 & xxx & xxx & xxx & xxx \\\\\n1 & xxx & xxx & xxx & xxx \\\\\n\\hline\n\\end{tabular}\n\\end{table}\n\n\\subsection{问题2} 考虑图 3 所示的流程图，基本块 2 和基本块 3 不在一条执行流程上（因为基本块 1 执行完后要么执行基本块 2，要么执行基本块 3，基本块 2 和基本块 3 不可能都执行）。准确来说，在 P4 程序流程图中，由一个基本块出发可以到达另一个基本块则说明两基本块在一条执行流程上，反之不在一条执行流程上。对于这种不在一条执行流程上的基本块，可以共享 HASH 资源和 ALU 资源，基本块 2 和 3 任意一个的 HASH 资源与 ALU 资源均不超过每级资源限制，基本块 2 和 3 即可排布到同一级。根据问题1中的约束条件 (2)、(3)、(5) 作如下更改：\n\n\\begin{enumerate}\n  \\item (2) 流水线每级中同一条执行流程上的基本块的 HASH 资源之和最大为 2；\n  \\item (3)流水线每级中同一条执行流程上的基本块的 ALU 资源之和最大为 56；\n  \\item (5)折叠的两级，对于 TCAM 资源约束不变，对于 HASH 资源，每级分别计算同一条执行流程上的基本块占用的 HASH 资源，再将两级的计算结果相加，结果不超过 3。\n\\end{enumerate}\n\n其它约束条件同问题 1。更改资源约束条件后重新考虑问题 1，给出排布算法，输出基本块排布结果。输出格式同问题 1。\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.4\\textwidth]{flow_example.png}\n\\caption{流程图示例}\n\\end{figure}",
  "problem_analysis": "从宏观角度看，这道题本质上是一个带有先行约束的离散资源分配与调度问题：把程序的基本块映射（place/schedule）到有限深度的流水线级上，使得数据依赖与控制依赖语义不被破坏，同时满足每级以及折叠级之间的资源容量限制，目标是尽量压缩所需的流水线级数（等价于最小化最大使用级号或 makespan）。这个问题融汇了编译器中的基本块调度、并行处理器中的资源调度与可重配置硬件的布局问题，数学上可被视为带有偏序约束（由控制/数据依赖构成的部分有序集）的0–1整数规划或约束满意问题，且还嵌入了多维瓶颈资源（TCAM/HASH/ALU/QUALIFY）与特殊的折叠/共享约束（如折叠级对资源求和上界、偶数级 TCAM 个数上限、Problem2 中基于“可共存性”放松 HASH/ALU 的计算方法）。目标函数（最小化流水线级数）和这些约束共同决定了问题的解法取向：严格追求最优通常需要对节点分配与资源累加进行全局组合搜索（ILP、分支定界或精确的动态规划），但问题的复杂性和规模通常会推动采用启发式策略（基于拓扑排序的最早可行级分配、优先级权重的 list-scheduling、局部搜索、启发式整数规划等）。\n\n问题描述中显性与隐性的假设对建模有关键影响。显性的包括：P4 程序无循环（有向无环图）、每个基本块在执行时只写一次同一变量、执行语义为“先读后写”的并行语义（即基本块内指令并行但读操作在写操作前读取旧值），以及各类资源的离散整数占用与每级上限。隐含的假设包括：变量读/写信息完整且静态、控制流与数据流可以在编译期准确分析以判定可达关系与控制依赖、资源占用是确定且与执行路径无概率性差异、流水线级间的折叠仅在指定范围（0–31）内有影响，以及每个数据包在运行时只有一条执行路径（即同一数据包不会并行穿过两条互斥分支）。这些前提使得可以把“是否可能同时执行”替换成图可达性的静态判定，从而将运行时的动态并发性转化为静态的可共存/不可共存关系用于约束。然而，若现实中分支概率、动态合并或运行时优化会改变执行集合，基于静态可达性的保守建模可能过于保守（丢弃共享潜力），而基于某种概率或平均行为的建模则会冒险违反最坏情况资源约束。\n\n部件之间的相互依赖表现为多个层面的耦合。首先是拓扑依赖：写后读（WAR）或写后写（WAW）带来严格的前驱小于后继（严格不等）约束，读后写（RAW）与控制依赖通常引入非严格（可等号）约束；这些偏序限制决定了某些节点无论资源如何都必须早于或不晚于另一些节点。其次是资源耦合：每级各资源类型的容量约束束缚了能被聚合放入同一级的节点集合，折叠约束把两个远端级号的资源绑定在一起使得跨层分配产生额外耦合。再者 Problem2 引入的“互斥共享”把图结构的可达性直接映射到资源计量规则：在同一流水线级中，若两个基本块不可能同一执行路径出现，则它们的 HASH/ALU 占用可以复用，从而允许把互斥的分支并放在同一级。此类基于路径的共享虽然能显著提高资源利用率，但也把资源校验从简单的“同级求和”变成了“对每一条可能路径上的同级节点求和不能超过上限”的问题，后者在一般 DAG 中可能产生指数级的约束（流经节点的路径数目往往指数增长），从而把原本已难解的离散优化问题进一步复杂化。需要在可计算性和保守性之间做权衡：要么采用最坏情况（对同级所有节点求和）保证安全但牺牲潜在共享；要么采用路径敏感的精确约束以最大化利用，但需要复杂的路径枚举或等价的动态规划/线性化技巧来实现可解性的保持。\n\n关于问题的计算复杂性与可解策略，应当指出该问题在组合复杂度上是困难的。即使不考虑折叠与路径共享，带有多资源的带约束调度/装箱问题通常是 NP-难的；加入折叠对跨级资源求和以及 Problem2 的路径敏感约束后，问题更接近于同时解决多维 bin-packing、偏序调度与图着色的混合体。为此，建模时可选择分层或分阶段策略：小规模或关键子问题可采用精确整数线性规划（ILP）或约束编程来获得最优解并验证启发式方法的质量；较大规模实例宜采用启发式贪心（按拓扑顺序将节点调度到最早满足依赖且不违反资源约束的级）、改进的 list-scheduling（用静态优先级如高度、资源需求或关键路径长度排序）、局部搜索与元启发式（模拟退火、遗传算法）并结合局部修复（例如节点向前或向后移动以减小最大级数），对于 Problem2 的路径共享可用“最长路径上的同级资源和”作为判定函数：对每个级 s，把被分配到 s 的节点在 DAG 上定义为带权点集，计算经过这些点的最大权和路径并确保它不超过该级容量，这一判定可以用拓扑顺序上的动态规划线性时间实现（对单个级而言），从而避免路径枚举的指数爆炸。折叠约束可以通过对被折叠对 (i, i+16) 建立联立容量约束来表达；偶数级 TCAM 个数上限则可作为额外的计数约束。总体策略通常是先做拓扑优先的初始分配，再用资源紧凑化（合并、迁移）和局部修补来减少最大使用级数。\n\n时间尺度与动态因素方面，需要意识到若把模型设计为最坏情况安全约束（保证任意输入包路径下资源不超限），则模型对管线资源的占用往往是保守的，可能牺牲可用吞吐或增加所需的级数。但在工程实践中，若知道分支概率或流量分布，可以构建概率性或期望化的资源模型，以优化平均性能而非最坏情况。这会引入额外的不确定性管理工作：需要对分支概率的估计、运行时行为的漂移、以及分支相关性的变化敏感性进行验证与鲁棒性分析。此外，编译器或后端实现可能对基本块做合并、拆分或代码优化（例如公共子表达式消除、表项合并），这些变换会改变基本块的资源指派和依赖关系，因此在实际部署前模型需要与编译器后端的变换保持一致或在管线调度阶段把这些优化也纳入建模。硬件层面也可能存在微小差异（例如折叠实现的细节、管线级内并行度、实际 ALU/QUALIFY 的并行执行粒度），这些都要求对模型输出进行工程层面的检验与微调。\n\n在建模表述上可以有多种可替代的重构。一种更保守的表述是把 Problem2 的共享改为“按最大可同时活跃集合求和”，即对每级求出任意可能同时执行的节点子集（通常是完全可达链或路径），并以此约束资源；这种表述更接近编译器的 live-range 分配思想并在保证安全性方面显式。另一种更激进的表述则是引入概率或成本函数：允许在概率意义下超额使用资源，同时对超额使用施加代价，从而将问题从纯可行性转为在资源与性能之间进行权衡的优化问题。此外，可以把目标从单纯最小化最大级数转为多目标优化，例如同时考虑流水线深度、各级资源碎片化程度、平均/最大延迟和表项重用率，不同目标会引导出不同的策略（例如偏向均衡分配以降低碎片，或偏向极端压缩以最小化级深）。这些替代视角会影响所用算法范式：保守可行性偏向截断式约束编程，概率/期望优化则适合随机优化与鲁棒规划方法，多目标问题可利用标度或 Pareto 前沿搜索策略。\n\n最后需要强调建模与求解的迭代性与验证必要性。由于问题包含许多工程假设与离散化近似（例如基本块资源数是精确的、控制流图的结构在编译后不变、折叠约束按固定对映射），在实际应用中应当保持一种反复的验证—修正循环：先建立一个保守但可求解的基线模型并在小规模实例上用精确方法验证启发式，随后在生产规模上采用启发式并用仿真或实际数据包流量跟踪评估资源利用率与违约率；如果发现过度保守导致浪费，增加路径敏感性或引入概率性约束；若发现潜在的运行时违例，则收紧约束或在硬件/编译环节增加保护。总体上，问题既有严密的理论建模维度（偏序与资源约束的整数规划结构），也有强烈的工程实践维度（需与编译器、硬件实现细节和运行时流量模式耦合），因此最合理的研究路径是结合形式化模型、启发式算法与实验验证的迭代式方法。",
  "modeling_solution": "模型概述与基本假设。为把题目描述形式化成可求解的数学优化问题，令 B 为基本块集合（|B| = n），E 为流程图的有向边集合。每个基本块 b ∈ B 的四类资源占用量记为 res_{b,r}，r ∈ R = {TCAM, HASH, ALU, QUALIFY}，这些数值来自 attachment1.csv。attachment2.csv 给出每个基本块读写的变量集合，从中可构造出依赖关系：若 b 写了变量 v 且 b' 读了 v，则存在写后读（write→read）依赖 b ≺_WR b'（严格先行）；若 b 与 b' 都写同一变量则存在写后写（write→write）依赖 b ≺_WW b'（严格先行）；若 b 读了变量且 b' 写了该变量则存在读后写（read→write）依赖 b ≼_RW b'（允许相等，即非严格）；流程图的控制依赖根据 CFG 的可达性与“仅部分路径通过”规则构造，若 b 和 b' 存在控制依赖则也建立非严格先行 b ≼_C b'。综合上面三类依赖可得到两类偏序约束集合 P_strict（需严格小于）和 P_nonstrict（需小于等于）。为便于建模，假设 P4 程序无循环（DAG），每个基本块在执行中只对同一变量写一次（题设），且资源占用为确定的整数。为保证模型可解，引入一个人工上界 S_upper（例如 S_upper = n-1 或者一个实际硬件允许的最大深度）作为流水线级数编号上界；最终模型将最小化实际使用的最大级别 T_max ∈ {0,..,S_upper}。\n\n决策变量与基本等式。对每个基本块 b 和每个流水线级 s = 0..S_upper 定义二元变量 x_{b,s} ∈ {0,1}，表示 b 是否被分配到级 s。每个基本块恰好被分配到一级：∀b, sum_{s} x_{b,s} = 1。定义整数变量 t_b 表示 b 分配的级号，线性表达为 t_b = sum_{s} s * x_{b,s}。定义整数变量 T_max 表示所用的最高级别，目标将为最小化 T_max，并通过约束 ∀b, t_b ≤ T_max 来保证关系；为防止对称性和改善求解，亦可引入 y_s ∈ {0,1} 表示“级 s 被使用”（即存在 b 分配到 s），并用约束 y_s ≥ x_{b,s}（∀b）以及 y_s ≤ sum_b x_{b,s} 来线性化 y_s。\n\n依赖约束（偏序）。对每个严格依赖对 (i,j) ∈ P_strict 施加 t_i + 1 ≤ t_j（等价于 t_i < t_j）。对每个非严格依赖 (i,j) ∈ P_nonstrict 施加 t_i ≤ t_j。控制依赖按 P_nonstrict 处理，读后写按非严格处理，写后读和写后写按严格处理。这样保证编译后流水线顺序不会破坏程序语义。\n\n资源约束（问题1的原始形式）。对每一资源 r 和每一级 s，标准的保守约束为： sum_{b} res_{b,r} * x_{b,s} ≤ cap_{r,s}，其中 cap_{r,s} 为该级 r 资源上限（题目给定常数，例如 cap_{TCAM,s}=1，cap_{HASH,s}=2，cap_{ALU,s}=56，cap_{QUALIFY,s}=64，对所有 s 小于 32 的折叠对另有额外约束见下）。折叠约束：题设将级 0 与 16、1 与 17、…、15 与 31 视为折叠对；对于每个折叠对 (s, s+16)（s=0..15）施加 TCAM： sum_b res_{b,TCAM} * x_{b,s} + sum_b res_{b,TCAM} * x_{b,s+16} ≤ 1；HASH 折叠约束为 sum_b res_{b,HASH} * x_{b,s} + sum_b res_{b,HASH} * x_{b,s+16} ≤ 3。若实际所需流水线深度超过 32，则从第 32 级开始不适用折叠限制（在 MILP 中直接只对 s=0..15 的折叠对强制约束即可）。偶数级 TCAM 个数上限：题设要求“有 TCAM 资源的偶数级数量不超过 5”。为表达“某级有 TCAM 资源”引入 y^{TCAM}_s ∈ {0,1}，对所有 s 施加 sum_b res_{b,TCAM} * x_{b,s} ≤ M * y^{TCAM}_s（M 为大数，如最大可能 TCAM 需求），并且 y^{TCAM}_s ≤ sum_b x_{b,s} * 1_{res_{b,TCAM}>0}（或等价地 y^{TCAM}_s ≤ sum_b indicator_b * x_{b,s}），最终约束为 sum_{s even} y^{TCAM}_s ≤ 5。每个基本块只能分配到一级由前述对 x_{b,s} 的约束保证。\n\n目标函数。主要优化目标为最小化 T_max（即占用流水线的最大级号，从而最小化流水线级数）。在 MILP 中可以设目标 min T_max，并可添加次要目标（如减少资源碎片、负载均衡）作为二级优化或加权项，例如最小化 ε * sum_s (unused_capacity_metric) 以打破等价解中不必要的对称性。\n\nProblem2（基于执行路径的资源共享）建模创新：在问题2 中，若两个基本块不可能在同一执行流上同时执行，则它们在同一级可共享 HASH 与 ALU 资源；等价地，对处在同一级的节点，不能超过每条可能执行路径上该级节点在该路径上的资源和上限。直接枚举图中所有简单路径会导致指数级约束，为此提出一种多变量线性化的路径敏感约束，基于“最长路径权和”思想并引入辅助变量以保持 MILP 的线性形式。对每一级 s 和资源 r ∈ {HASH, ALU} 引入连续非负变量 z_{v,s,r}（v ∈ B）来表示“在级 s 上、以节点 v 作为路径终点时的最大累积资源和”，以及 m_{s,r} 表示级 s 的最大路径资源和（m_{s,r} = max_v z_{v,s,r}）。利用 DAG 的拓扑顺序，建立下面的线性不等式：对所有 v， z_{v,s,r} ≥ res_{v,r} * x_{v,s}；对所有边 u→v， z_{v,s,r} ≥ z_{u,s,r} + res_{v,r} * x_{v,s}。这些约束确保 z_{v,s,r} 至少等于通过任一前驱 u 到 v 的路径上在级 s 的资源累计权和（若 u 未分配到 s 则 z_{u,s,r} 可能为 0）；令 m_{s,r} ≥ z_{v,s,r} ∀v，则 m_{s,r} 表示级 s 上任意路径的最大累积资源。对 Problem2 的资源容量约束改写为 m_{s,HASH} ≤ cap_{HASH}（例如 2）和 m_{s,ALU} ≤ cap_{ALU}（例如 56）。折叠对在 Problem2 下的 HASH 约束同题面描述：先计算两级各自的 m_{s,HASH} 与 m_{s+16,HASH}（如果存在），再强制 m_{s,HASH} + m_{s+16,HASH} ≤ 3。TCAM 的折叠规则在 Problem2 中不变，仍按级内直接求和限制。上述线性不等式组避免了枚举所有路径而仍实现了路径级别可行性检查（因 DAG 和 z 约束的递推性质，任何路径对应的累积和必被某个 z_{v,s,r} 覆盖）。\n\n完整 MILP 模型（两种情形共通基础）。决策变量：x_{b,s} ∈ {0,1}（b ∈ B, s=0..S_upper）、t_b ∈ Z, T_max ∈ Z, y_s ∈ {0,1}（是否使用 s），y^{TCAM}_s ∈ {0,1}（是否在 s 使用 TCAM），对于 Problem2 还需 z_{v,s,r} ≥ 0（连续）与 m_{s,r} ≥ 0（连续）。约束集合包括：分配约束 sum_s x_{b,s}=1；t_b = sum_s s * x_{b,s}；依赖约束 t_i + 1 ≤ t_j (∀(i,j)∈P_strict)；t_i ≤ t_j (∀(i,j)∈P_nonstrict)；级使用变量关联 y_s ≥ x_{b,s}，y_s ≤ sum_b x_{b,s}；T_max ≥ t_b ∀b；资源约束（Problem1）： ∀s, ∀r, sum_b res_{b,r} * x_{b,s} ≤ cap_{r}（对所有 r）；折叠约束（Problem1）： ∀s=0..15, sum_b res_{b,TCAM} * x_{b,s} + sum_b res_{b,TCAM} * x_{b,s+16} ≤ 1，类似 HASH 折叠 ≤3；偶数级 TCAM 个数约束： ∀s, sum_b res_{b,TCAM} * x_{b,s} ≤ M * y^{TCAM}_s，sum_{s even} y^{TCAM}_s ≤ 5。Problem2 中把级内 HASH 与 ALU 简单求和替换为路径敏感 m_{s,r} 上界并引入 z 不等式与 m 对应约束，折叠 HASH 则用 m_{s,HASH}+m_{s+16,HASH} ≤ 3。目标 min T_max（若采用多目标，可将若干次级目标加入 lexicographic 或加权目标）。\n\n求解策略。对中小规模实例（n ≤ 若干百）推荐使用 MILP 求解器（Gurobi、CPLEX 或 OR-Tools 的 CP-SAT），因为上述模型线性化后能较好利用现代混合整数规划求解器的剪枝能力和切割平面技术，且 z 变量与 DAG 边数线性相关不会引入非线性算子。为加速收敛建议：给出良好的初始可行解（见启发式方法）、使用对称性破除（例如要求最早使用级满足连续性 y_0 ≥ y_1 ≥ …，或在可能的情况下强制级使用的前缀性），并对大规模实例采用分支限界并结合启发式修复。\n\n高效启发式（用于大规模或在线场景）。提出基于拓扑排序的 earliest-fit list-scheduling：首先按 DAG 拓扑顺序或按关键度（如最长后续路径长度或资源“重量”）对基本块排序；对每个基本块按顺序把它放到最早满足依赖约束（t_b 必须 ≥ max( predecessors' t + δ )）且不违反当前级资源约束（Problem1 用级内求和；Problem2 在尝试把 b 放到级 s 时，基于已在 s 的节点重新计算 z 递推并检查是否会使某个 z_{v,s,r} 超过 cap_{r}，这可通过一次拓扑线性扫描在 O(|E| + |B|) 时间内完成）；若不能放入已存在的任一级则打开新级（s = current_used_levels）。该启发式可通过局部改进步骤（尝试把某些节点向前迁移或者把某级节点整体压缩到更低级）进一步优化。对于 Problem2 中的路径敏感性，启发式中计算 z 的动态编程方法能在尝试操作时提供精确的可行性检测而无需枚举路径。\n\n分解与加速技巧。当问题规模更大或折叠与路径约束带来大量 z 变量时，可采用 Benders 分解：主问题决定分配 t_b 或粗粒度的级分配（例如把级空间分为块），子问题（或 Benders 副问题）对每个级验证资源可行性（包括路径敏感的 z 验证）；当子问题不可行时生成割回传到主问题。另一实用方法为逐级确定：先在保守模型（按级内总和、不允许路径共享）计算下界并得到初始可行解，再逐级放宽约束（允许路径共享）用局部搜索收紧 T_max。对于需要非常快近似解的场合，可用训练好的机器学习代理（例如图神经网络）来预测节点优先级或直接预测接近可行的分配，然后用局部 MILP 修正。\n\n计算复杂度与资源需求。原始 MILP 中二元变量数为 O(n * S_upper)，连续 z 变量数为 O(n * S_upper * |R_path|)（R_path 只含 HASH/ALU），线性约束数为 O(|E| * S_upper)（由于 z 的递推）。若 n≈数百、S_upper≈几十，模型可在现代求解器上求解；若 n 成千，建议启发式、分解或并行化。求解精度取决于 MILP 的优化允许时间与剪枝效果；通常对中小实例可得到最优或接近最优解；对大实例则推荐设定时间限并接受 GAP。并行化可在 MILP 求解器层面（多线程）或启发式层面（并行尝试不同初始化并取最优）实现。\n\n鲁棒性、敏感性与验证。模型依赖于静态的依赖分析与资源占用估计；若运行时出现分支概率变化或基本块资源估计误差，需对模型做不确定性量化。可以把关键容量约束转换为 Chance-constraints（概率约束）或引入安全裕度（例如把 cap_r 减小一个保守因子）来提升鲁棒性。敏感性分析可对关键参数（如折叠 HASH 上限、偶数级 TCAM 个数上限、ALU 上限）进行单因子或全局灵敏度测试，方法为在这些参数的小幅上下波动下重解模型并观察 T_max 与资源残余的变化。模型验证通过仿真：把得到的映射用于 P4 程序模拟器或流量生成器，统计任一路径在任一级的实际资源峰值，验证不超出硬件限制；若实测发现违约则回到模型加约束或调整参数。\n\n模型扩展与未来改进方向。可以把概率分支信息（分支执行概率）纳入模型，改为期望或风险敏感目标（例如最小化带权期望 T_max 或在给定风险水平下最小化 T_max），这会把问题转化为带概率的优化并允许更激进的资源共享策略。可考虑基本块切分与合并：允许在编译时把一个基本块的动作拆分到多个级别以更好地负载均衡（这在硬件允许的前提下非常有利），对应模型需引入可分割任务与可拆分资源占用的变量。长期性优化可纳入自适应运行时重新编译机制：监测流量并在样本授权下周期性重求解并下发新的排布。算法层面可探索基于强化学习的调度器：用仿真环境训练代理学会在 DAG 上高效地分配基本块以最小化 T_max 与资源碎片。最后，若折叠实现更复杂（例如折叠对并非固定偏移16），模型可扩展为通用折叠对矩阵与动态映射优化问题。\n\n总结性说明。上述模型把问题严谨地表示为一个带偏序约束的离散分配优化问题，Problem1 采用级内资源求和的保守约束，Problem2 在 HASH/ALU 上引入路径敏感的线性化检测（基于 z 变量与最大路径 m 的引入），从而在保证最坏情况安全性的同时最大化资源共享。主张优先在中小规模上用 MILP 得到最优解，面对大规模时采用拓扑优先的 earliest-fit + DP 可行性检验启发式并结合局部搜索和分解策略；在工程实践中推荐加入概率信息与在线重编译机制以应对运行时动态变化，并利用灵敏度分析与仿真来验证模型的现实可用性与稳健性。上述方法兼顾理论完备性与工程可实施性，既能严格保证程序语义与硬件约束，又能通过路径敏感共享显著提高资源利用率与减少所需流水线级数。",
  "task_descriptions": [
    "子任务1 的目标是从提供的三份输入文件（attachment1.csv：每个基本块对 TCAM、HASH、ALU、QUALIFY 的整数资源占用；attachment2.csv：每个基本块的写/读变量列表；attachment3.csv：基本块的有向邻接/跳转关系）出发，构造一个可供混合整数线性规划（MILP）求解器直接使用的严格数学模型以最小化所需流水线最大级号 T_max，同时完备地表达所有语义依赖与硬件资源约束；为此任务需按如下步骤实施并产出明确交付物：1) 数据预处理——用脚本（例如 Python + pandas）读取三份 CSV，构建基本块集合 B、有向边集 E 与每块的资源向量 res_{b,r}，并为每块建立写集合 W_b 与读集合 R_b；2) 依赖分析——基于变量读写关系构造数据依赖集：若 b∈B 写变量 v 且 b' 读 v 则加入严格写后读依赖 (b ≺_{WR} b')，若两块均写同一变量则加入严格写后写依赖 (b ≺_{WW} b')，若 b 读而 b' 写则加入非严格读后写依赖 (b ≼_{RW} b')；再根据控制依赖定义利用标准的后支配（postdominator）分析（可用 Lengauer–Tarjan 算法实现或借助现成库，如 NetworkX 的 dominator 功能）识别控制依赖对并将其转为非严格依赖 P_nonstrict；最终合并得到两个偏序集合 P_strict（要求严格先行，即 t_i + 1 ≤ t_j）与 P_nonstrict（允许相等，即 t_i ≤ t_j）；3) 建模变量与线性化——为一个上界 S_max（建议取 min(n-1, 31 或者可配置上界；注意折叠规则仅在级号 < 32 时生效））定义二元分配变量 x_{b,s}∈{0,1}（b∈B, s=0..S_max），并为每基本块定义整数级号变量 t_b = Σ_s s·x_{b,s}（以线性约束实现）、全局目标变量 T_max 与级使用二元变量 y_s ∈{0,1}（用于对称性破除与输出解释）；强制每块恰有一级：Σ_s x_{b,s}=1，且对所有 b 约束 t_b ≤ T_max；4) 依赖与资源约束线性表达——依赖约束按 P_strict 与 P_nonstrict 分别加入 t_i + 1 ≤ t_j 与 t_i ≤ t_j；对每级 s 与每种资源 r∈{TCAM,HASH,ALU,QUALIFY}加入保守的级内资源约束 Σ_{b} res_{b,r}·x_{b,s} ≤ cap_r（cap 值按题设，例如 TCAM=1,HASH=2,ALU=56,QUALIFY=64）；5) 折叠与全局计数约束——对折叠对 (s, s+16)（s=0..15 且 s+16 ≤ S_max）线性加入 TCAM 折叠约束 Σ_b res_{b,TCAM}·x_{b,s} + Σ_b res_{b,TCAM}·x_{b,s+16} ≤ 1 与 HASH 折叠约束 Σ_b res_{b,HASH}·x_{b,s} + Σ_b res_{b,HASH}·x_{b,s+16} ≤ 3；为表达“偶数级上存在 TCAM 的级数 ≤ 5”引入指示变量 y^{TCAM}_s ∈{0,1} 并以大 M 线性化：Σ_b res_{b,TCAM}·x_{b,s} ≤ M·y^{TCAM}_s（M 可取为所有基本块 TCAM 占用之和）以及 Σ_{s even} y^{TCAM}_s ≤ 5；同时关联 y_s 与 x_{b,s}（y_s ≥ x_{b,s} ∀b, y_s ≤ Σ_b x_{b,s}）以便输出和对称性破除；6) 目标函数——主目标为 min T_max（最小化最大使用级别），可在模型中添加可选的对称性破除约束（例如要求 y_0 ≥ y_1 ≥ ...）或将次级目标作为加权项以求解器性能优化；7) 可实现细节与求解器接口——将所有变量和约束以标准 MILP 格式生成（例如通过 Python 的 PuLP、Pyomo 或 Gurobi/CPLEX 的 Python API），明确变量类型（x 与 y 二元，t_b 与 T_max 整数或连续并强制为整数域，依据求解器），并在模型构建脚本中包含选项以调整 S_max 与 M 的取值、启用/禁用折叠约束（以支持大于 32 级的情形）；8) 验证与交付物——脚本输出应包括：已解析的依赖对列表 P_strict/P_nonstrict、完整 MILP 模型文件（.lp/.mps 或 solver API 对象）、用于可视化的原始基本块到级的可行解样例接口 y_s 与 x_{b,s} 的映射表，以及基本的可行性检查（验证每条依赖和每级资源未被违反）；该子任务不包含求解优化结果本身或针对 Problem2 的路径敏感建模，完成后应能独立将产生的 MILP 模型交付给求解器以获得最优或近似排布。",
    "子任务2（路径敏感共享建模与可解法）：本子任务的目标是把题目中Problem2的资源共享规则以可线性化、可求解的形式加入调度模型：在保证程序语义（由已有的CFG与数据/控制依赖约束确定）下，允许“不在同一执行流程上的基本块在同一级共享 HASH 与 ALU 资源”，即用级内“任一路径上资源和不超过上限”的判定替代简单的同级总和限制，从而提高资源复用率；为此输入为已解析的基本块集合 B、有向无环的流程图 E、每块在四类资源上的整数占用 res_{b,r}、以及资源上限与折叠规则（TCAM 折叠与偶数级 TCAM 限制保持不变，HASH/ALU 在本子任务中改为路径敏感约束）。具体要求和方法如下：以二元分配变量 x_{b,s}（表示基本块 b 分配到级 s）与整数级号 t_b（已由基础模型定义）为基础，针对每个流水线级 s 与面向资源 r∈{HASH,ALU} 引入连续非负辅助变量 z_{v,s,r}（对每个节点 v 表示以 v 为终点在级 s 上某条路径的累积资源和的下界）和 m_{s,r}（级 s 上所有路径的最大累积资源和）；用 DAG 的拓扑顺序线性刻画路径累积关系：对所有 v 保证 z_{v,s,r} ≥ res_{v,r} * x_{v,s}（自身贡献），并对每条边 u→v 加入递推不等式 z_{v,s,r} ≥ z_{u,s,r} + res_{v,r} * x_{v,s}，然后对所有 v 约束 m_{s,r} ≥ z_{v,s,r}，最终以 m_{s,r} ≤ cap_{r} 代替原来的 ∑_b res_{b,r}·x_{b,s} ≤ cap_{r}（仅对 HASH 与 ALU 使用此路径敏感上界）；折叠约束按题意修改为对 s=0..15 要求 m_{s,HASH} + m_{s+16,HASH} ≤ 3（TCAM 折叠仍按级内条目和约束实现），同时保留各级其他资源类型（TCAM、QUALIFY）和偶数级 TCAM 个数等原约束（以相同的二元指示变量线性化）。技术实现要点包括：利用拓扑排序在一次线性扫描内计算或增量更新某一级 s 上的所有 z_{·,s,r}（复杂度 O(|E|+|B|)），这使得在启发式调度中能够快速检查将某一块 b 放入级 s 会否违反 m_{s,r} 上界；在求解器层面，把 z 与 m 作为连续变量并将所有约束加入 MILP，可交由 Gurobi/CPLEX 或 OR-Tools CP‑SAT（具备线性约束支持的求解器）求解中小规模实例以求最优解；为加速和生成可行初解，同时实现可扩展性，应实现基于拓扑/关键路径权重的 earliest‑fit list scheduling：按优先级顺序遍历基本块，对每个候选级 s 用上述拓扑 DP 计算增量 z 并测试 m_{s,r}，如果可行则放置，否则尝试下一个级或新建级；最后可配合局部迁移（前移/后移）和级合并的简短局部搜索以压缩最大级号。交付物应包含：扩展模型的完整变量与线性约束清单（x、t、z、m 的域说明与等式/不等式），用于增量可行性检测的拓扑 DP 伪代码或实现说明，折叠规则在 m 变量层面的线性化表达，以及用于 MILP 求解和启发式调度的接口说明（输入格式、S_max 选择建议、数值稳定性注意事项），以便该子任务独立实现路径敏感的 HASH/ALU 共享建模与可解流程。",
    "子任务3（可扩展求解框架与工程实现）要求把前面构建的调度/映射模型工程化为可在中大规模实例上高效求解的模块化框架：输入为已解析的基本块集合 B、有向无环图 E（按邻接表存储）、每块的资源向量 res_{b,r}、依赖集合 P_strict/P_nonstrict、以及可配置的最大级数 S_max 与资源上限；输出为分配变量 x_{b,s}（或等价的级号 t_b）、全局最大级 T_max、每级资源汇总以及可用于下游验证的日志与回退映射。为实现可扩展性与工业可用性，本子任务需按以下步骤实现并交付：1) 基础数据结构与预处理——用稀疏邻接表和拓扑序列预计算每节点的前驱/后继列表、最长后续路径长度（关键路径权重）和每节点资源“重量”，并维护按级的资源计数表与节点集合，采用位集合或哈希表以支持快速增删与并行访问；2) 单级路径敏感可行性检测（核心子例程）——实现按拓扑序线性时间的动态规划来计算某一级 s 的 z_{v,s,r}（v∈B, r∈{HASH,ALU}）：初始化 z_v ← res_{v,r} if v 分配到 s else 0，然后按拓扑顺序对每条边 u→v 做 z_v ← max(z_v, z_u + res_{v,r})，最终 m_{s,r} = max_v z_v；该子例程用于在尝试向级 s 放入或移出某节点时做增量可行性检查，时间复杂度 O(|E|+|B|) 并应实现增量更新以避免全表重算；3) 启发式初解生成——实现 earliest‑fit list scheduling：按优先级（例如关键路径长度、资源重量或自定义评分）顺序遍历节点，对每个节点在最早满足依赖约束的已有级 s 调用单级可行性检测，若通过则分配，否则尝试下一级或新开级，记录时间限与失败回退策略；4) 局部优化与压缩操作——实现一组原子局部操作（将单节点向前/向后移动一级、在两个相邻级间合并/拆分节点集、交换两个节点的级分配），每次尝试仅用增量 z 更新检测可行性，并以启发式或局部搜索（例如禁忌/模拟退火）接受改善以减小 T_max 或资源碎片；5) 精化与精确求解接口——为中小规模实例或当启发式无法进一步改进时，构建与 MILP 求解器（Gurobi/CPLEX/OR‑Tools CP‑SAT）的双向接口：主流程将启发式得到的可行解作为初始解并可选地向 MILP 提交精化求解，或在 Benders 分解框架下令主问题仅决定粗粒度变量（如每节点的目标区间或分块级分配），子问题以单级 DP 验证并返回不可行割（具体地：子问题在固定 x 下对每级执行 z 计算以检查资源违例并将产生的违反约束线性化为 Benders 割回写主问题）；6) 分解、并行与分块策略——当 n 或 S_max 较大时，提供（a）按级区间或节点子图分块的分层求解（先对高影响子图求解并固定其分配，再迭代解决剩余部分），（b）并行化：利用 MILP 求解器的多线程能力并在并行工作线程上尝试多种启发式初解与不同优先级策略，最终选择最优或最稳定解，(c) 时间受限的渐进式求解：允许在给定时间窗内返回当前最优可行解与 GAP 报告；7) 实现细节与性能工程——推荐使用 Python 做胶水层（pandas/NetworkX 用于前处理），关键性能内核用 C/C++ 或 Cython 实现（尤其是单级 DP、增量更新与并行数据结构），并采用稀疏矩阵/压缩表示以减小内存；为避免重复计算，实现变更驱动的增量更新：当尝试把节点放入或移出级 s，仅在受影响的可达子集上更新 z 而非全图重算；8) 验证、日志与回退机制——每次分配或变动后自动记录依赖检查、每级资源使用快照及单级 z 最大值，提供快速仿真接口（用 DP 校验所有可能路径或用抽样路径验证）以证明当前映射满足最坏情形约束；若运行时或仿真检测到违例，框架应能自动回退到上一个通过验证的可行解或触发保守映射生成器；9) 可配置参数与交互API——提供配置项（时间限、S_max、优先级策略、并行线程数、分块大小、是否启用 Benders）和程序化 API，使上层系统能以批处理或在线方式调用（返回解、诊断信息与可视化输出）。交付物应包括可运行的软件包（源码与编译指令）、核心子例程（单级 DP 与增量更新）、若干典型实例的运行脚本、与至少一个工业级 MILP 求解器的接口示例、性能基准脚本（测量单次 DP 时间、增量更新代价、启发式收敛速度）及完整的使用说明与故障处理流程；复杂度提示：单次单级可行性检测 O(|E|+|B|)、每次局部变动的增量更新平均远小于全图规模，整体内存与变量数约 O(n·S_max)，当 n 或 S_max 非常大时应优先采用分块/并行或时间受限的近似策略。",
    "子任务4（鲁棒性、灵敏度分析、扩展机制与工程部署策略）旨在为资源排布/调度算法构建系统化的验证、鲁棒化与运行维护流程：其范围包括（1）定义和量化输入不确定性来源（如基本块资源估计误差、分支概率/路径选择分布偏移、折叠约束或硬件容量实际波动、编译器优化带来的结构性变化）；（2）制定并执行敏感性与不确定性分析流程以识别对目标（主要为最低流水线深度 T_max、其次为资源超额风险与碎片化）最敏感的参数与结构决策；（3）提出和实现若干可操作的鲁棒化策略（如引入安全裕度/缩减因子 cap'=(1-ε)·cap、采用 Chance‑constraint 或 两阶段随机规划以控制违约概率、采用 min‑max 鲁棒优化以对抗最坏情形、以及预定义保守回退映射）；（4）定义离线验证与在线监控/触发重编译机制，包括仿真验证、蒙特卡洛或 Bootstrap 采样测试、基于路径抽样的最坏路径压力测试、以及在生产运行时采集关键指标并按规则触发再优化或回退。为实现以上目标需按如下可执行步骤操作：首先收集并整理用于不确定性建模的输入数据集（静态：attachment 系列文件与编译器变换日志；动态：流量样本、分支实际采样/频率、测得的每级资源峰值），并确定不确定性模型（确定性边界、概率分布或经验直方图）；其次进行分层敏感性分析：从单因子（one‑at‑a‑time）试验开始，扩展到全局方差分解或 Sobol 指数、以及情景式（what‑if）分析，以输出参数敏感度排序和建议的安全裕度；第三，在模型层实现鲁棒化选项并对比：（a）安全裕度策略（简单、低开销）；（b）概率约束/采样平均化策略（控制违约概率，需样本与更高计算成本）；（c）最坏情况鲁棒优化（严格但最保守）；对每种策略记录解的 T_max、资源剩余与失败概率；第四，建立验证管线：用仿真器/现场采样生成大量路径样本并验证每级资源峰值不超限，自动生成验证报告（包括违约样本、最大超额量和对应路径）；第五，设计在线监控与自动化运维流程：在部署时对映射版本进行灰度/金丝雀发布，生产环境通过指标采集（T_max 实时估计、每级 TCAM/HASH/ALU/QUALIFY 实际占用、路径违例计数、编译/下发延时）存入时序数据库（例如 Prometheus），并设定明确报警与重编译触发规则（例如当任一资源在多数样本中超过 cap 或违例次数超过阈值时触发即时回退到上一个通过验证的保守映射或启动周期性重编译）；第六，制定映射版本管理与回退策略：保存每次映射的元数据（版本号、输入快照、敏感性报告、仿真日志），并实现可自动回滚的下发流程与速率限制以避免频繁重配置；第七，产出一套可重复执行的交付物：敏感性分析报告（参数排序、推荐 ε 值 或概率阈值）、鲁棒化策略比较表、仿真验证脚本与测试用例集、在线监控与触发规则清单、映射版本管理规范与回退流程文档。建议使用的工具与技术包括：Python 生态（pandas/NumPy/NetworkX）用于数据预处理与不确定性建模；SALib 或自实现的 Sobol/方差分解工具用于全局敏感性分析；蒙特卡洛/Bootstrap 采样与定向最坏路径生成脚本用于仿真；成熟 MILP/优化求解器（Gurobi/CPLEX）或启发式调度模块用于求解不同鲁棒化模型；CI/CD 与监控工具链（Git、容器化部署、Prometheus/Grafana、日志系统）用于自动化验证、部署与回退；以及仿真/测试环境或 P4 程序模拟器用于端到端验证。最后，应规定量化验收准则（例如在给定测试集下违例率 < p_threshold，或在最大允许安全裕度 ε* 下 T_max 不超过目标上界），并在每次模型或编译器变更后强制重新运行敏感性/验证流程，以确保长期稳定性与可维护性。"
  ]
}