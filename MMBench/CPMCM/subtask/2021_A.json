{
  "tasks": [],
  "problem_str": "问题背景：\n计算机视觉、相控阵雷达、声呐、射电天文、无线通信等领域的信号通常呈现为矩阵的形式，这一系列的矩阵间通常在某些维度存在一定的关联性，因此数学上可用相关矩阵组表示。例如，视频信号中的单帧图像可视为一个矩阵，连续的多帧图像组成了相关矩阵组，而相邻图像帧或图像帧内像素间的关联性则反映在矩阵间的相关性上。随着成像传感器数量/雷达阵列/通信阵列的持续扩大，常规处理算法对计算和存储的需求成倍增长，从而对处理器件或算法的实现成本和功耗提出了巨大的挑战。因此，充分挖掘矩阵间关联性，以实现低复杂度的计算和存储，具有十分重要的价值和意义。\n\n问题要求：\n给定一组复数矩阵 $H = \\{H_{j,k}\\}$，$H_{j,k} \\in \\mathbb{C}^{M \\times N}, j = 1, \\ldots, J, k = 1, \\ldots, K$。其中，矩阵之间以及同一矩阵的元素之间有一定的相关性，包括：相同 $j$ 下标、不同 $k$ 下标的矩阵间存在一定的关联，即 $\\{H_{j,1}, H_{j,2}, H_{j,3}, \\ldots, H_{j,K}\\}$ 间存在关联\\footnote{在本问题中，仅考虑同一行块内部的 $K$ 个矩阵间的相关性，不考虑矩阵组 $H$ 中属于不同行块的矩阵（即，不同 $j$ 下标的矩阵）间的相关性。}；且矩阵\n\n\\[\nH_{j,k} = \\begin{bmatrix}\n h_{1,1}^{(j,k)} & h_{1,2}^{(j,k)} & h_{1,3}^{(j,k)} & \\cdots & h_{1,N}^{(j,k)} \\\n h_{2,1}^{(j,k)} & h_{2,2}^{(j,k)} & h_{2,3}^{(j,k)} & \\cdots & h_{2,N}^{(j,k)} \\\n \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\n h_{M,1}^{(j,k)} & h_{M,2}^{(j,k)} & h_{M,3}^{(j,k)} & \\cdots & h_{M,N}^{(j,k)}\n\\end{bmatrix}\n\\]\n\n的各个元素间 $\\{h_{m,n}^{(j,k)}\\}, m = 1, \\ldots, M, n = 1, \\ldots, N$，也存在关联。\n\n定义矩阵组 $H = \\{H_{j,k}\\}$ 上的一组数学运算，其中间结果 $V = \\{V_{j,k}\\}$ 由如下的公式给出：\n\n\\[\nV_{j,k} = svd\\big(H_{j,k}\\big), \\text{or } H_{j,k} = U_{j,k} S_{j,k} \\widetilde{V}_{j,k}^H, V_{j,k} = \\widetilde{V}_{j,k}^H(:,1:L)\n\\]\n\n\\[\nj = 1, \\ldots, J; \\, k = 1, \\ldots, K\n\\]其中，\\(svd(\\cdot)\\)为矩阵的奇异值分解（即，SVD 分解）中求解右奇异向量的过程，其简要说明可参考附录一；\\(V_{j,k}\\)是由\\(H_{j,k}\\)的前\\(L\\)个右奇异向量构成的矩阵，\\(L\\)个之后的右奇异向量可以忽略，维度为\\(N \\times L\\)。\n\n进一步，为得到最终输出结果\\(W = \\{W_{j,k}\\}\\)，先将不同\\(j\\)下标、相同\\(k\\)下标的\\(V_{j,k}\\)进行横向的拼接，得到维度为\\(N \\times LJ\\)的\\(V_k = [V_{1,k} \\quad \\cdots \\quad V_{j,k} \\quad \\cdots \\quad V_{J,k}]\\)，然后根据如下公式获取\\(W_k\\)：\n\\[\nW_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}\n\\]\n其中，\\(\\sigma^2\\)为固定常数；\\(W_k\\)维度同\\(V_k\\)；\\(I\\)为单位矩阵，维度为\\(LJ \\times LJ\\)。\n\n最后，将各\\(W_k\\)按如下的公式进行拆解：\n\\[\nW_k = [W_{1,k}, \\ldots, W_{j,k}, \\ldots, W_{J,k}]\n\\]\n其中，\\(W_{j,k}\\)是\\(W_k\\)中顺序排列的子矩阵，维度为\\(N \\times L\\)。上述各流程亦可参考附录二中的图示说明。\n\n为了降低计算和储存的复杂度，分析相关矩阵组的关联性，通过数学建模对输出结果\\(W\\)进行估计，建模过程表示为：\n\\[\n\\widehat{W} = f(H)\n\\]\n其中\\(\\widehat{W}\\)即为对输出结果\\(W\\)的建模估计。这一建模过程又可以拆分为2个步骤：\n\\[\n\\widehat{V} = f_1(H), \\quad \\widehat{W} = f_2(\\widehat{V})\n\\]\n其中\\(f_1(\\cdot)\\)表示从输入矩阵组\\(H\\)到中间结果\\(V\\)的建模过程，\\(\\widehat{V}\\)表示中间结果\\(V\\)的建模估计，\\(f_2(\\cdot)\\)表示从中间结果\\(V\\)到最终结果\\(W\\)的建模过程，\\(\\widehat{W}\\)表示最终结果\\(W\\)的建模估计。定义\\(W\\)的建模估计精度为：\n\\[\n\\rho_{l,j,k}(W) = \\frac{\\|\\widehat{W}_{l,j,k}^H W_{l,j,k}\\|_2}{\\|\\widehat{W}_{l,j,k}\\|_2 \\|W_{l,j,k}\\|_2}, l = 1, \\ldots, L\n\\]\n其中，\\(\\|\\cdot\\|_2\\)表示矢量的欧几里得范数（也即2范数，对于列矢量\\(a\\)，\\(\\|a\\|_2 = \\sqrt{a^H a}\\)）；\\(W_{l,j,k}\\)表示\\(W_{j,k}\\)的第\\(l\\)列。上式中，\\(\\widehat{W}_{l,j,k}^H W_{l,j,k}\\)为复数标量，此处取其欧几里得范数即获取其模值。\n\n为描述方便，额外定义 $W$ 的最低建模精度 $\\rho_{\\min}(W)$ 为：\n\\[\n\\rho_{\\min}(W) \\triangleq \\min_{l \\in \\{1,2,\\ldots,L\\}} \\min_{j \\in \\{1,2,\\ldots,n\\}} \\min_{k \\in \\{1,2,\\ldots,K\\}} \\rho_{l,j,k}(W)\n\\]\n其中，$\\min(\\cdot)$ 表示在 $l,j,k$ 三个维度上取最小值。另外，中间结果 $V$ 的建模估计精度 $\\rho_{l,j,k}(V)$ 的定义及最低建模精度 $\\rho_{\\min}(V)$ 的定义与此相同。\n\n下面对建模过程中涉及的 **计算复杂度、存储复杂度** 的定义进行说明：\n\n**计算复杂度** 定义为由矩阵组 $H$ 计算得到结果矩阵组 $W$ 所需要的总计算复杂度。复杂矩阵运算可拆解为基本的复杂运算，而基本的复杂运算又可进一步拆解为基本的实数运算。例如，复数乘法按照\n\\[\n(a+bj)(c+dj)=(ac-bd)+(ad+bc)j\n\\]\n计算的复杂度为 4 次实数乘法和 2 次实数加(减)法。实数基本运算的复杂度按照下表计算，其中，实数的加(减)法运算与乘法运算的计算复杂度对比如参考文献[1]。\n\n\\begin{table}[H]\n\\centering\n\\caption{实数基本运算的计算复杂度}\n\\begin{tabular}{|c|c|}\n\\hline\n运算类型 & 计算复杂度 \\\\\\ \n\\hline\n加(减)法 & $1^*$ \\\\\\ \n乘法 & $3^*$ \\\\\\ \n倒数 & $25^*$ \\\\\\ \n平方根 & $25^*$ \\\\\\ \n自然指数 & $25^*$ \\\\\\ \n自然对数 & $25^*$ \\\\\\ \n正弦 & $25^*$ \\\\\\ \n余弦 & $25^*$ \\\\\\ \n其它 & $100^*$ \\\\\\ \n\\hline\n\\end{tabular}\n\\end{table}\n\n如果使用常规的算法完成本问题中的运算流程，获取输出结果 $W=\\{W_{j,k}\\}$ 的计算复杂度由如下几个部分构成：\n\n- 求解右奇异向量过程中的计算复杂度。当使用文献[2]中使用的方法时，基于双对角化(bi-diagonalization)结合QR分解的操作，对于SVD分解本身可以达到近似 $O(NM^2+M^3)$ 的复杂度，其主要流程可参考附录三。\n\n- 获取逆矩阵 $(V_k^H V_k + \\sigma^2 I)^{-1}$ 过程中 的计算复杂度。当使用高斯消元法时，求解维度 $L \\times L$ 的矩阵的逆矩阵的复杂度近似为 $O((L l)^3)$；当矩阵求逆过程中使用的矩阵乘法使用文献[3]中的 Strassen’s 方法时，可以将上述复杂度降低到 $O((L l)^{2.807})$；进一步地，当求逆过程结合了文献[4]中提出的 Coppersmith–Winograd 方法时，理论上可以将上述复杂度降低到 $O((L l)^{2.376})$，对此部分的说明可参考附录四；\n\n- 求解各个 $W_k$ 过程中 的矩阵乘法的计算复杂度。请注意，将 $W_k$ 拆解为若干子矩阵的过程中并不涉及计算复杂度，一般认为可以通过 $W_k$ 直接获取 $W_{j,k}$。\n\n如果使用以上方法，当矩阵组 \\(H = \\{H_{j,k}\\}\\) 的维度，或者，矩阵组内各个矩阵 \\(H_{j,k}\\) 的维度继续提升时，整个系统将承受愈发巨大的计算负担。为此，需要通过恰当的建模方法，使得在近似获得输出结果的同时明显地降低计算复杂度。\n\n在本题目中，利用相关矩阵组的关联性降低计算复杂度可以从如下基础方向（或你认为其他更合适的方向）中的一个或者多个方向切入完成建模题目：\n\n1) 利用矩阵组 \\(H\\) 内部各个矩阵间的关联性，减少前述一组数学运算的整体计算复杂度。例如，矩阵组 \\(H\\) 中包括存在关联性的 5 个矩阵 \\(\\{H_{j,1}, H_{j,2}, H_{j,3}, H_{j,4}, H_{j,5}\\}\\)，部分情况下可以仅针对 \\(H_{j,1}, H_{j,3}, H_{j,5}\\) 进行相应的运算过程并获取 \\(\\widehat{W}_{j,1}, \\widehat{W}_{j,3}, \\widehat{W}_{j,5}\\)，然后通过恰当的插值操作获取 \\(\\widehat{W}_{j,2}\\) 和 \\(\\widehat{W}_{j,4}\\)，使得 \\(\\rho_{l,j,k}(W)\\) 均满足前述建模估计精度的需求。\n\n2) 利用矩阵 \\(H_{j,k}\\) 内部各个矩阵元素间的关联性，降低奇异值分解过程、矩阵求逆过程的计算复杂度。关于奇异值分解的低计算复杂度实现，方法不做限定。例如，可以参考文献 [5] 中提出的随机奇异值分解 (Randomized SVD) 方法，其简要实现过程可以参考网页 [6]，部分摘录于附录五。\n\n3) 针对计算流程进行合理的构造和转化，避免执行相对复杂的矩阵运算步骤。例如，矩阵求逆的计算复杂度较高，而本问题的最终需求为 \\(W_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}\\)，如果将该步骤转化为 \\((V_k^H V_k + \\sigma^2 I) W_k^H = V_k^H\\) 形式来求解 \\(W_k\\)，则潜在地可以降低整体计算流程的计算复杂度。4) 请注意，在完成本问题时，推荐根据上述表格给出更细化的计算复杂度评估。例如，统计建模过程中复数乘法的使用次数、复数加法的使用次数等，然后分别与复数乘法的计算复杂度（可以为 14）及复数加法的计算复杂度（可以为 2）相乘，累加后得到总体计算复杂度。\n\n存储复杂度定义为矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 占用的存储空间的大小，以比特为单位计算。对于复数矩阵中单个复数元素，其实部和虚部均采用 32 比特单精度浮点表示。因此，整个矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 占用的存储空间分别为 \\(64MNJK\\) 比特和 \\(64NLJK\\) 比特。\n\n为了节省存储开销，考虑对 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 分别进行压缩。独立设计 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 的压缩函数 \\(P_1(\\cdot)\\) 和 \\(P_2(\\cdot)\\)，对压缩后的数据 \\(P_1(\\boldsymbol{H})\\) 和 \\(P_2(\\boldsymbol{W})\\) 进行存储。压缩函数的设计请主要考虑挖掘并利用矩阵内部或矩阵间的关联性，或者，矩阵表达的稀疏性；思路可参考但不限于图像的变换域压缩算法或视频的帧间压缩算法。压缩后的每个元素仍然以 32bit 单精度浮点数存储，不考虑位宽的压缩。\n\n\\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 以压缩的形式存储在存储器中。在进行处理之前，需要从存储器中读出 \\(P_1(\\boldsymbol{H})\\) 和 \\(P_2(\\boldsymbol{W})\\) 进行解压缩处理：\n\\[\n\\widehat{\\boldsymbol{H}} = G_1\\big(P_1(\\boldsymbol{H})\\big), \\ \\widehat{\\boldsymbol{W}} = G_2\\big(P_2(\\boldsymbol{W})\\big)\n\\]\n其中，\\(G_1(\\cdot)\\) 和 \\(G_2(\\cdot)\\) 分别表示矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 的解压缩函数。经过压缩和解压缩之后得到的 \\(\\widehat{\\boldsymbol{H}}\\) 和 \\(\\widehat{\\boldsymbol{W}}\\) 与原始的 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 存在误差，定义为\n\\[\nerr_H = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{H}}_{j,k} - \\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}, \\ err_W = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{W}}_{j,k} - \\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}\n\\]\n其中，\\(\\|\\cdot\\|_F\\) 表示矩阵的 Frobenius 范数；\\(E\\{\\cdot\\}\\) 表示求期望运算，即在所提供矩阵组的所有矩阵求平均。注意：标准输出矩阵组 \\(\\boldsymbol{W}\\) 是 0 相位，即其中矩阵 \\(\\boldsymbol{W}_{j,k}\\) 的每个列向量的首个元素是 0 相位复数（实数）。若建模得到的 \\(\\widehat{\\boldsymbol{W}}_{j,k}\\) 带有随机初始相位，可增加一步相位拉齐处理，将 \\(\\widehat{\\boldsymbol{W}}_{j,k}\\) 拉齐到与 \\(\\boldsymbol{W}_{j,k}\\) 相同的 0 相位，然后再计算误差。\n\n综上所述，相关矩阵组的整体处理流程如下图所示。\n\n\\begin{tikzpicture}[node distance=2cm, auto, thick, main/.style = {draw, rectangle, minimum size=2cm}]\n    \\node[main] (input) {$\\boldsymbol{H} = \\{\\boldsymbol{H}_{j,k}\\}$};\n    \\node[main, right of=input] (compress1) {存储单元};\n    \\node[main, right of=compress1] (decompress1) {计算单元};\n    \\node[main, right of=decompress1] (compress2) {存储单元};\n    \\node[main, right of=compress2] (decompress2) {$\\widehat{\\boldsymbol{W}} = \\{\\widehat{\\boldsymbol{W}}_{j,k}\\}$};\n    \n    \\draw[->] (input) -- node[above] {$P_1(\\cdot)$} (compress1);\n    \\draw[->] (compress1) -- node[above] {$G_1(\\cdot)$} (decompress1);\n    \\draw[->] (decompress1) -- node[above] {$P_2(\\cdot)$} (compress2);\n    \\draw[->] (compress2) -- node[above] {$G_2(\\cdot)$} (decompress2);\n    \n    \\node[above of=compress1, node distance=1cm] {压缩};\n    \\node[above of=decompress1, node distance=1cm] {解压缩};\n    \\node[above of=compress2, node distance=1cm] {压缩};\n    \\node[above of=decompress2, node distance=1cm] {解压缩};\n    \n    \\node[below of=decompress1, node distance=1cm] {$\\widehat{\\boldsymbol{W}} = f(\\boldsymbol{H})$};\n\\end{tikzpicture}\n\n三、建模问题\n\n输入矩阵组 $\\mathbf{H}$、标准中间矩阵组 $\\mathbf{V}$ 和标准输出矩阵组 $\\mathbf{W}$ 的数据及其维度如下，数据采用十进制格式：\n\n\\begin{itemize}\n    \\item 第一组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第二组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第三组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第四组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第五组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第六组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n\\end{itemize}\n\n附件中提供 .mat 及 .csv 文件格式的数据，按需使用其中的一种文件格式即可。\n\n请基于以上提供的数据，采用适当的方法，解决以下相关矩阵组的低复杂度计算和存储建模问题。注意，提交结果及论文需要完成以下问题 1、问题 2 中的至少一题，同时完成两题将适当加分。问题 3 为开放式问题，不作为必选，但鼓励尝试，有新意的算法模型设计将得到加分。\n\n在完成以下问题时，仅需考虑各个问题本身申明的建模需求，不需要考虑其他问题产生的建模需求。例如，在完成问题 3 时，不需要额外考虑问题 1 中 $\\rho_{\\min}(V)$ 的建模估计精度需求。\\section*{问题1：相关矩阵组的低复杂度计算}\n\n1) 基于给定的所有矩阵数据 $H$，分析其数据间的关联性，设计相应的近似分析模型 $\\bar{V} = f_1(H)$，在满足 $\\rho_{\\min}(\\bar{V}) \\geq \\rho_{th} = 0.99$ 的情况下，使得根据表格计算的总计算复杂度最低。\n\\begin{itemize}\n\\item 注1：在本问题中，暂不考虑矩阵数据 $H$ 的压缩与解压缩。\n\\item 注2：参考下述 2)，当采用直接设计分析模型 $W = f(H)$ 的方式时，1) 可以跳过不做。\n\\end{itemize}\n\n2) 基于给定的所有矩阵数据 $H$，分析其数据间的关联性，综合设计相应的近似分析模型 $W = f(H)$，在满足 $\\rho_{\\min}(W) \\geq \\rho_{th} = 0.99$ 的情况下，使得根据表格计算的总计算复杂度最低。\n\\begin{itemize}\n\\item 注1：在本问题中，暂不考虑矩阵数据 $H$ 的压缩与解压缩。\n\\item 注2：在本问题中，可以：\n  \\begin{itemize}\n  \\item 在 1) 的基础上考虑 $W = f_2(\\bar{V})$，因此 $W = f(H) = f_2(f_1(H))$；或者，\n  \\item 不需考虑中间结果 $\\bar{V}$，直接设计分析模型 $W = f(H)$，此时 1) 可以跳过不做。\n  \\end{itemize}\n\\item 注3：如果使用常规数学方法，则考虑矩阵所有运算过程涉及的计算复杂度；如果使用人工智能方法，则优先考虑推理阶段的计算复杂度，但需要充分考虑泛化性。\n\\end{itemize}\n\n\\section*{问题2：相关矩阵组的低复杂度存储}\n\n基于给定的所有矩阵数据 $H$ 和 $W$，分析各自数据间的关联性，分别设计相应的压缩 $P_1(\\cdot)$, $P_2(\\cdot)$ 和解压缩 $G_1(\\cdot)$, $G_2(\\cdot)$ 模型，在满足误差 $err_W \\leq E_{th1} = -30 \\,\\text{dB}$, $err_H \\leq E_{th2} = -30 \\,\\text{dB}$ 的情况下，使得存储复杂度和压缩与解压缩的计算复杂度最低，复杂度计算同问题1。\n\\begin{itemize}\n\\item 注1：压缩与解压缩函数的设计方法不做限定。\n\\item 注2：计算复杂度考虑压缩和解压缩函数的所有运算过程。\n\\item 注3：在本问题中，暂不考虑分析模型 $W = f(H)$ 对输出矩阵组 $W$ 的影响。\n\\item 注4：两个建模优化目标（存储复杂度，压缩与解压缩的计算复杂度）的优先级相同。\n\\end{itemize}\n\n\\section*{问题3：相关矩阵组的低复杂度计算和存储}\n\n基于给定的所有矩阵数据 $H$，分析其数据间的关联性，在满足 $\\rho_{\\min}(W) \\geq \\rho_{th} = 0.99$ 的情况下，设计低复杂度计算和存储的整体方案，完成从矩阵输入信号 $H$ 到近似矩阵输出信号 $W$ 的端到端流程。\n\\begin{itemize}\n\\item 注1：在本问题中，可以考虑从矩阵输入信号 $H$ 到近似矩阵输出信号 $W$ 为一个整体流程，而非依次经过“压缩/解压缩、计算单元、压缩/解压缩”的过程。\n\\item 注2：如果使用人工智能方法，需要考虑人工智能模型的存储复杂度以及推理阶段的计算复杂度。\n\\end{itemize}\nAddendum: \n如果使用以上方法，当矩阵组 $H = \\{H_{j,k}\\}$ 的维度，或者，矩阵组内各个矩阵 $H_{j,k}$ 的维度继续提升时，整个系统将承受愈发巨大的计算负担。为此，需要通过恰当的建模方法，使得在近似获得输出结果的同时明显地降低计算复杂度。\n\n在本题目中，利用相关矩阵组的关联性降低计算复杂度可以从如下基础方向（或你认为其他更合适的方向）中的一个或者多个方向切入完成建模题目：\n\n1) 利用矩阵组 $H$ 内部各个矩阵间的关联性，减少前述一组数学运算的整体计算复杂度。例如，矩阵组 $H$ 中包括存在关联性的 5 个矩阵 $\\{H_{j,1}, H_{j,2}, H_{j,3}, H_{j,4}, H_{j,5}\\}$，部分情况下可以仅针对 $H_{j,1}, H_{j,3}, H_{j,5}$ 进行相应的运算过程并获取 $\\widehat{W}_{j,1}, \\widehat{W}_{j,3}, \\widehat{W}_{j,5}$，然后通过恰当的插值操作获取 $\\widehat{W}_{j,2}$ 和 $\\widehat{W}_{j,4}$，使得 $\\rho_{l,j,k}(W)$ 均满足前述建模估计精度的需求。\n\n2) 利用矩阵 $H_{j,k}$ 内部各个矩阵元素间的关联性，降低奇异值分解过程、矩阵求逆过程的计算复杂度。关于奇异值分解的低计算复杂度实现，方法不做限定。例如，可以参考文献 [5] 中提出的随机奇异值分解 (Randomized SVD) 方法，其简要实现过程可以参考网页 [6]，部分摘录于附录五。\n\n3) 针对计算流程进行合理的构造和转化，避免执行相对复杂的矩阵运算步骤。例如，矩阵求逆的计算复杂度较高，而本问题的最终需求为 $W_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}$，如果将该步骤转化为 $(V_k^H V_k + \\sigma^2 I) W_k^H = V_k^H$ 形式来求解 $W_k$，则潜在地可以降低整体计算流程的计算复杂度。4) 请注意，在完成本问题时，推荐根据上述表格给出更细化的计算复杂度评估。例如，统计建模过程中复数乘法的使用次数、复数加法的使用次数等，然后分别与复数乘法的计算复杂度（可以为 14）及复数加法的计算复杂度（可以为 2）相乘，累加后得到总体计算复杂度。\n\n存储复杂度定义为矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 占用的存储空间的大小，以比特为单位计算。对于复数矩阵中单个复数元素，其实部和虚部均采用 32 比特单精度浮点表示。因此，整个矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 占用的存储空间分别为 $64MNJK$ 比特和 $64NLJK$ 比特。\n\n为了节省存储开销，考虑对 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 分别进行压缩。独立设计 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 的压缩函数 $P_1(\\cdot)$ 和 $P_2(\\cdot)$，对压缩后的数据 $P_1(\\boldsymbol{H})$ 和 $P_2(\\boldsymbol{W})$ 进行存储。压缩函数的设计请主要考虑挖掘并利用矩阵内部或矩阵间的关联性，或者，矩阵表达的稀疏性；思路可参考但不限于图像的变换域压缩算法或视频的帧间压缩算法。压缩后的每个元素仍然以 32bit 单精度浮点数存储，不考虑位宽的压缩。\n\n$\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 以压缩的形式存储在存储器中。在进行处理之前，需要从存储器中读出 $P_1(\\boldsymbol{H})$ 和 $P_2(\\boldsymbol{W})$ 进行解压缩处理：\n\\[\n\\widehat{\\boldsymbol{H}} = G_1\\big(P_1(\\boldsymbol{H})\\big), \\ \\widehat{\\boldsymbol{W}} = G_2\\big(P_2(\\boldsymbol{W})\\big)\n\\]\n其中，$G_1(\\cdot)$ 和 $G_2(\\cdot)$ 分别表示矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 的解压缩函数。经过压缩和解压缩之后得到的 $\\widehat{\\boldsymbol{H}}$ 和 $\\widehat{\\boldsymbol{W}}$ 与原始的 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 存在误差，定义为\n\\[\nerr_H = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{H}}_{j,k} - \\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}, \\ err_W = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{W}}_{j,k} - \\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}\n\\]\n其中，$\\|\\cdot\\|_F$ 表示矩阵的 Frobenius 范数；$E\\{\\cdot\\}$ 表示求期望运算，即在所提供矩阵组的所有矩阵求平均。注意：标准输出矩阵组 $\\boldsymbol{W}$ 是 0 相位，即其中矩阵 $\\boldsymbol{W}_{j,k}$ 的每个列向量的首个元素是 0 相位复数（实数）。若建模得到的 $\\widehat{\\boldsymbol{W}}_{j,k}$ 带有随机初始相位，可增加一步相位拉齐处理，将 $\\widehat{\\boldsymbol{W}}_{j,k}$ 拉齐到与 $\\boldsymbol{W}_{j,k}$ 相同的 0 相位，然后再计算误差。\n\n综上所述，相关矩阵组的整体处理流程如下图所示。\n\n\\begin{tikzpicture}[node distance=2cm, auto, thick, main/.style = {draw, rectangle, minimum size=2cm}]\n    \\node[main] (input) {$\\boldsymbol{H} = \\{\\boldsymbol{H}_{j,k}\\}$};\n    \\node[main, right of=input] (compress1) {存储单元};\n    \\node[main, right of=compress1] (decompress1) {计算单元};\n    \\node[main, right of=decompress1] (compress2) {存储单元};\n    \\node[main, right of=compress2] (decompress2) {$\\widehat{\\boldsymbol{W}} = \\{\\widehat{\\boldsymbol{W}}_{j,k}\\}$};\n    \n    \\draw[->] (input) -- node[above] {$P_1(\\cdot)$} (compress1);\n    \\draw[->] (compress1) -- node[above] {$G_1(\\cdot)$} (decompress1);\n    \\draw[->] (decompress1) -- node[above] {$P_2(\\cdot)$} (compress2);\n    \\draw[->] (compress2) -- node[above] {$G_2(\\cdot)$} (decompress2);\n    \n    \\node[above of=compress1, node distance=1cm] {压缩};\n    \\node[above of=decompress1, node distance=1cm] {解压缩};\n    \\node[above of=compress2, node distance=1cm] {压缩};\n    \\node[above of=decompress2, node distance=1cm] {解压缩};\n    \n    \\node[below of=decompress1, node distance=1cm] {$\\widehat{\\boldsymbol{W}} = f(\\boldsymbol{H})$};\n\\end{tikzpicture}\n\n请基于以上提供的数据，采用适当的方法，解决以下相关矩阵组的低复杂度计算和存储建模问题。注意，提交结果及论文需要完成以下问题 1、问题 2 中的至少一题，同时完成两题将适当加分。问题 3 为开放式问题，不作为必选，但鼓励尝试，有新意的算法模型设计将得到加分。\n\n在完成以下问题时，仅需考虑各个问题本身申明的建模需求，不需要考虑其他问题产生的建模需求。例如，在完成问题 3 时，不需要额外考虑问题 1 中 $\\rho_{\\min}(V)$ 的建模估计精度需求。参考文献\nSwartzlander, Earl E., and Hani H. Saleh. \"Floating-point implementation of complex multiplication.\" 2009 Conference Record of the Forty-Third Asilomar Conference on Signals, Systems and Computers. IEEE, 2009.\nGolub, Gene, and William Kahan. \"Calculating the singular values and pseudo-inverse of a matrix.\" Journal of the Society for Industrial and Applied Mathematics, Series B: Numerical Analysis 2.2 (1965): 205-224.\nStrassen, Volker. \"Gaussian elimination is not optimal.\" Numerische mathematik 13.4 (1969): 354-356.\nCoppersmith, Don, and Shmuel Winograd. \"Matrix multiplication via arithmetic progressions.\" Proceedings of the nineteenth annual ACM symposium on Theory of computing. 1987.\nHalko, Nathan, Per-Gunnar Martinsson, and Joel A. Tropp. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions.\" SIAM review 53.2 (2011): 217-288.\n网址：https://gregorygundersen.com/blog/2019/01/17/randomized-svd/\nDataset Path:\n['Data1_H.csv', 'Data1_H.mat', 'Data1_V.csv', 'Data1_V.mat', 'Data1_W.csv', 'Data1_W.mat', 'Data2_H.csv', 'Data2_H.mat', 'Data2_V.csv', 'Data2_V.mat', 'Data2_W.csv', 'Data2_W.mat', 'Data3_H.csv', 'Data3_H.mat', 'Data3_V.csv', 'Data3_V.mat', 'Data3_W.csv', 'Data3_W.mat', 'Data4_H.csv', 'Data4_H.mat', 'Data4_V.csv', 'Data4_V.mat', 'Data4_W.csv', 'Data4_W.mat', 'Data5_H.csv', 'Data5_H.mat', 'Data5_V.csv', 'Data5_V.mat', 'Data5_W.csv', 'Data5_W.mat', 'Data6_H.csv', 'Data6_H.mat', 'Data6_V.csv', 'Data6_V.mat', 'Data6_W.csv', 'Data6_W.mat', 'Readme.txt', '附录.docx']\n\nData Description:\n该数据集由多组以CSV（部分为.mat）格式存储的复数矩阵文件构成（主要文件名为Data1_H/V/W … Data6_H/V/W、Data5_H.mat、Readme.txt及附录.docx），每个矩阵元素均为复数形式（实部+虚部i，部分数值显示极小虚部如e-17），CSV文件中复数元素以逗号分隔、矩阵按行/块排列并以换行分隔，整体按约定的多维张量顺序存储：H 集合的理论维度为 M×N×J×K（示例给定 M=4、N=64、J=4、K=384），V 和 W 的维度为 N×L×J×K（示例 L=2），且CSV行通常对应 N 维度、列按{M, J, K}或{L, J, K}顺序排放；各 Data*_H/V/W 文件分别包含不同场景下的复数矩阵集合，元素数值分布多为小幅正负浮点数（示例值如0.059197+0.1187i、-0.06006+0.04340i等），部分 W 文件列字段非常多（如 Data4_W 列举至上百个元素字段），Data5_H 被提供为 .mat 文件但其中的 W 读取失败并记录为无法解析。数据描述反复强调矩阵之间存在结构性相关性，尤其是在同一“行块”内部的 K 个矩阵之间具有显著相关性（不同行块之间通常不考虑相关性），因此适合用于信号处理与通信系统领域的矩阵相关性分析、降维与分解任务；附录.docx 提供了关于奇异值分解（SVD）的理论与实现细节（含双对角化+QR、基于随机SVD的近似方法及降低矩阵乘法复杂度的策略），Readme.txt 则说明了文件的存储格式与维度约定，便于按上述多维索引重构原始矩阵张量并用于后续的矩阵分解、统计分析或模型验证。",
  "problem": {
    "background": "计算机视觉、相控阵雷达、声呐、射电天文、无线通信等领域的信号通常呈现为矩阵的形式，这一系列的矩阵间通常在某些维度存在一定的关联性，因此数学上可用相关矩阵组表示。例如，视频信号中的单帧图像可视为一个矩阵，连续的多帧图像组成了相关矩阵组，而相邻图像帧或图像帧内像素间的关联性则反映在矩阵间的相关性上。随着成像传感器数量/雷达阵列/通信阵列的持续扩大，常规处理算法对计算和存储的需求成倍增长，从而对处理器件或算法的实现成本和功耗提出了巨大的挑战。因此，充分挖掘矩阵间关联性，以实现低复杂度的计算和存储，具有十分重要的价值和意义。",
    "problem_requirement": "给定一组复数矩阵 $H = \\{H_{j,k}\\}$，$H_{j,k} \\in \\mathbb{C}^{M \\times N}, j = 1, \\ldots, J, k = 1, \\ldots, K$。其中，矩阵之间以及同一矩阵的元素之间有一定的相关性，包括：相同 $j$ 下标、不同 $k$ 下标的矩阵间存在一定的关联，即 $\\{H_{j,1}, H_{j,2}, H_{j,3}, \\ldots, H_{j,K}\\}$ 间存在关联\\footnote{在本问题中，仅考虑同一行块内部的 $K$ 个矩阵间的相关性，不考虑矩阵组 $H$ 中属于不同行块的矩阵（即，不同 $j$ 下标的矩阵）间的相关性。}；且矩阵\n\n\\[\nH_{j,k} = \\begin{bmatrix}\n h_{1,1}^{(j,k)} & h_{1,2}^{(j,k)} & h_{1,3}^{(j,k)} & \\cdots & h_{1,N}^{(j,k)} \\\n h_{2,1}^{(j,k)} & h_{2,2}^{(j,k)} & h_{2,3}^{(j,k)} & \\cdots & h_{2,N}^{(j,k)} \\\n \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\n h_{M,1}^{(j,k)} & h_{M,2}^{(j,k)} & h_{M,3}^{(j,k)} & \\cdots & h_{M,N}^{(j,k)}\n\\end{bmatrix}\n\\]\n\n的各个元素间 $\\{h_{m,n}^{(j,k)}\\}, m = 1, \\ldots, M, n = 1, \\ldots, N$，也存在关联。\n\n定义矩阵组 $H = \\{H_{j,k}\\}$ 上的一组数学运算，其中间结果 $V = \\{V_{j,k}\\}$ 由如下的公式给出：\n\n\\[\nV_{j,k} = svd\\big(H_{j,k}\\big), \\text{or } H_{j,k} = U_{j,k} S_{j,k} \\widetilde{V}_{j,k}^H, V_{j,k} = \\widetilde{V}_{j,k}^H(:,1:L)\n\\]\n\n\\[\nj = 1, \\ldots, J; \\, k = 1, \\ldots, K\n\\]其中，\\(svd(\\cdot)\\)为矩阵的奇异值分解（即，SVD 分解）中求解右奇异向量的过程，其简要说明可参考附录一；\\(V_{j,k}\\)是由\\(H_{j,k}\\)的前\\(L\\)个右奇异向量构成的矩阵，\\(L\\)个之后的右奇异向量可以忽略，维度为\\(N \\times L\\)。\n\n进一步，为得到最终输出结果\\(W = \\{W_{j,k}\\}\\)，先将不同\\(j\\)下标、相同\\(k\\)下标的\\(V_{j,k}\\)进行横向的拼接，得到维度为\\(N \\times LJ\\)的\\(V_k = [V_{1,k} \\quad \\cdots \\quad V_{j,k} \\quad \\cdots \\quad V_{J,k}]\\)，然后根据如下公式获取\\(W_k\\)：\n\\[\nW_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}\n\\]\n其中，\\(\\sigma^2\\)为固定常数；\\(W_k\\)维度同\\(V_k\\)；\\(I\\)为单位矩阵，维度为\\(LJ \\times LJ\\)。\n\n最后，将各\\(W_k\\)按如下的公式进行拆解：\n\\[\nW_k = [W_{1,k}, \\ldots, W_{j,k}, \\ldots, W_{J,k}]\n\\]\n其中，\\(W_{j,k}\\)是\\(W_k\\)中顺序排列的子矩阵，维度为\\(N \\times L\\)。上述各流程亦可参考附录二中的图示说明。\n\n为了降低计算和储存的复杂度，分析相关矩阵组的关联性，通过数学建模对输出结果\\(W\\)进行估计，建模过程表示为：\n\\[\n\\widehat{W} = f(H)\n\\]\n其中\\(\\widehat{W}\\)即为对输出结果\\(W\\)的建模估计。这一建模过程又可以拆分为2个步骤：\n\\[\n\\widehat{V} = f_1(H), \\quad \\widehat{W} = f_2(\\widehat{V})\n\\]\n其中\\(f_1(\\cdot)\\)表示从输入矩阵组\\(H\\)到中间结果\\(V\\)的建模过程，\\(\\widehat{V}\\)表示中间结果\\(V\\)的建模估计，\\(f_2(\\cdot)\\)表示从中间结果\\(V\\)到最终结果\\(W\\)的建模过程，\\(\\widehat{W}\\)表示最终结果\\(W\\)的建模估计。定义\\(W\\)的建模估计精度为：\n\\[\n\\rho_{l,j,k}(W) = \\frac{\\|\\widehat{W}_{l,j,k}^H W_{l,j,k}\\|_2}{\\|\\widehat{W}_{l,j,k}\\|_2 \\|W_{l,j,k}\\|_2}, l = 1, \\ldots, L\n\\]\n其中，\\(\\|\\cdot\\|_2\\)表示矢量的欧几里得范数（也即2范数，对于列矢量\\(a\\)，\\(\\|a\\|_2 = \\sqrt{a^H a}\\)）；\\(W_{l,j,k}\\)表示\\(W_{j,k}\\)的第\\(l\\)列。上式中，\\(\\widehat{W}_{l,j,k}^H W_{l,j,k}\\)为复数标量，此处取其欧几里得范数即获取其模值。\n\n为描述方便，额外定义 $W$ 的最低建模精度 $\\rho_{\\min}(W)$ 为：\n\\[\n\\rho_{\\min}(W) \\triangleq \\min_{l \\in \\{1,2,\\ldots,L\\}} \\min_{j \\in \\{1,2,\\ldots,n\\}} \\min_{k \\in \\{1,2,\\ldots,K\\}} \\rho_{l,j,k}(W)\n\\]\n其中，$\\min(\\cdot)$ 表示在 $l,j,k$ 三个维度上取最小值。另外，中间结果 $V$ 的建模估计精度 $\\rho_{l,j,k}(V)$ 的定义及最低建模精度 $\\rho_{\\min}(V)$ 的定义与此相同。\n\n下面对建模过程中涉及的 **计算复杂度、存储复杂度** 的定义进行说明：\n\n**计算复杂度** 定义为由矩阵组 $H$ 计算得到结果矩阵组 $W$ 所需要的总计算复杂度。复杂矩阵运算可拆解为基本的复杂运算，而基本的复杂运算又可进一步拆解为基本的实数运算。例如，复数乘法按照\n\\[\n(a+bj)(c+dj)=(ac-bd)+(ad+bc)j\n\\]\n计算的复杂度为 4 次实数乘法和 2 次实数加(减)法。实数基本运算的复杂度按照下表计算，其中，实数的加(减)法运算与乘法运算的计算复杂度对比如参考文献[1]。\n\n\\begin{table}[H]\n\\centering\n\\caption{实数基本运算的计算复杂度}\n\\begin{tabular}{|c|c|}\n\\hline\n运算类型 & 计算复杂度 \\\\\\ \n\\hline\n加(减)法 & $1^*$ \\\\\\ \n乘法 & $3^*$ \\\\\\ \n倒数 & $25^*$ \\\\\\ \n平方根 & $25^*$ \\\\\\ \n自然指数 & $25^*$ \\\\\\ \n自然对数 & $25^*$ \\\\\\ \n正弦 & $25^*$ \\\\\\ \n余弦 & $25^*$ \\\\\\ \n其它 & $100^*$ \\\\\\ \n\\hline\n\\end{tabular}\n\\end{table}\n\n如果使用常规的算法完成本问题中的运算流程，获取输出结果 $W=\\{W_{j,k}\\}$ 的计算复杂度由如下几个部分构成：\n\n- 求解右奇异向量过程中的计算复杂度。当使用文献[2]中使用的方法时，基于双对角化(bi-diagonalization)结合QR分解的操作，对于SVD分解本身可以达到近似 $O(NM^2+M^3)$ 的复杂度，其主要流程可参考附录三。\n\n- 获取逆矩阵 $(V_k^H V_k + \\sigma^2 I)^{-1}$ 过程中 的计算复杂度。当使用高斯消元法时，求解维度 $L \\times L$ 的矩阵的逆矩阵的复杂度近似为 $O((L l)^3)$；当矩阵求逆过程中使用的矩阵乘法使用文献[3]中的 Strassen’s 方法时，可以将上述复杂度降低到 $O((L l)^{2.807})$；进一步地，当求逆过程结合了文献[4]中提出的 Coppersmith–Winograd 方法时，理论上可以将上述复杂度降低到 $O((L l)^{2.376})$，对此部分的说明可参考附录四；\n\n- 求解各个 $W_k$ 过程中 的矩阵乘法的计算复杂度。请注意，将 $W_k$ 拆解为若干子矩阵的过程中并不涉及计算复杂度，一般认为可以通过 $W_k$ 直接获取 $W_{j,k}$。\n\n如果使用以上方法，当矩阵组 \\(H = \\{H_{j,k}\\}\\) 的维度，或者，矩阵组内各个矩阵 \\(H_{j,k}\\) 的维度继续提升时，整个系统将承受愈发巨大的计算负担。为此，需要通过恰当的建模方法，使得在近似获得输出结果的同时明显地降低计算复杂度。\n\n在本题目中，利用相关矩阵组的关联性降低计算复杂度可以从如下基础方向（或你认为其他更合适的方向）中的一个或者多个方向切入完成建模题目：\n\n1) 利用矩阵组 \\(H\\) 内部各个矩阵间的关联性，减少前述一组数学运算的整体计算复杂度。例如，矩阵组 \\(H\\) 中包括存在关联性的 5 个矩阵 \\(\\{H_{j,1}, H_{j,2}, H_{j,3}, H_{j,4}, H_{j,5}\\}\\)，部分情况下可以仅针对 \\(H_{j,1}, H_{j,3}, H_{j,5}\\) 进行相应的运算过程并获取 \\(\\widehat{W}_{j,1}, \\widehat{W}_{j,3}, \\widehat{W}_{j,5}\\)，然后通过恰当的插值操作获取 \\(\\widehat{W}_{j,2}\\) 和 \\(\\widehat{W}_{j,4}\\)，使得 \\(\\rho_{l,j,k}(W)\\) 均满足前述建模估计精度的需求。\n\n2) 利用矩阵 \\(H_{j,k}\\) 内部各个矩阵元素间的关联性，降低奇异值分解过程、矩阵求逆过程的计算复杂度。关于奇异值分解的低计算复杂度实现，方法不做限定。例如，可以参考文献 [5] 中提出的随机奇异值分解 (Randomized SVD) 方法，其简要实现过程可以参考网页 [6]，部分摘录于附录五。\n\n3) 针对计算流程进行合理的构造和转化，避免执行相对复杂的矩阵运算步骤。例如，矩阵求逆的计算复杂度较高，而本问题的最终需求为 \\(W_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}\\)，如果将该步骤转化为 \\((V_k^H V_k + \\sigma^2 I) W_k^H = V_k^H\\) 形式来求解 \\(W_k\\)，则潜在地可以降低整体计算流程的计算复杂度。4) 请注意，在完成本问题时，推荐根据上述表格给出更细化的计算复杂度评估。例如，统计建模过程中复数乘法的使用次数、复数加法的使用次数等，然后分别与复数乘法的计算复杂度（可以为 14）及复数加法的计算复杂度（可以为 2）相乘，累加后得到总体计算复杂度。\n\n存储复杂度定义为矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 占用的存储空间的大小，以比特为单位计算。对于复数矩阵中单个复数元素，其实部和虚部均采用 32 比特单精度浮点表示。因此，整个矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 占用的存储空间分别为 \\(64MNJK\\) 比特和 \\(64NLJK\\) 比特。\n\n为了节省存储开销，考虑对 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 分别进行压缩。独立设计 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 的压缩函数 \\(P_1(\\cdot)\\) 和 \\(P_2(\\cdot)\\)，对压缩后的数据 \\(P_1(\\boldsymbol{H})\\) 和 \\(P_2(\\boldsymbol{W})\\) 进行存储。压缩函数的设计请主要考虑挖掘并利用矩阵内部或矩阵间的关联性，或者，矩阵表达的稀疏性；思路可参考但不限于图像的变换域压缩算法或视频的帧间压缩算法。压缩后的每个元素仍然以 32bit 单精度浮点数存储，不考虑位宽的压缩。\n\n\\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 以压缩的形式存储在存储器中。在进行处理之前，需要从存储器中读出 \\(P_1(\\boldsymbol{H})\\) 和 \\(P_2(\\boldsymbol{W})\\) 进行解压缩处理：\n\\[\n\\widehat{\\boldsymbol{H}} = G_1\\big(P_1(\\boldsymbol{H})\\big), \\ \\widehat{\\boldsymbol{W}} = G_2\\big(P_2(\\boldsymbol{W})\\big)\n\\]\n其中，\\(G_1(\\cdot)\\) 和 \\(G_2(\\cdot)\\) 分别表示矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 的解压缩函数。经过压缩和解压缩之后得到的 \\(\\widehat{\\boldsymbol{H}}\\) 和 \\(\\widehat{\\boldsymbol{W}}\\) 与原始的 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 存在误差，定义为\n\\[\nerr_H = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{H}}_{j,k} - \\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}, \\ err_W = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{W}}_{j,k} - \\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}\n\\]\n其中，\\(\\|\\cdot\\|_F\\) 表示矩阵的 Frobenius 范数；\\(E\\{\\cdot\\}\\) 表示求期望运算，即在所提供矩阵组的所有矩阵求平均。注意：标准输出矩阵组 \\(\\boldsymbol{W}\\) 是 0 相位，即其中矩阵 \\(\\boldsymbol{W}_{j,k}\\) 的每个列向量的首个元素是 0 相位复数（实数）。若建模得到的 \\(\\widehat{\\boldsymbol{W}}_{j,k}\\) 带有随机初始相位，可增加一步相位拉齐处理，将 \\(\\widehat{\\boldsymbol{W}}_{j,k}\\) 拉齐到与 \\(\\boldsymbol{W}_{j,k}\\) 相同的 0 相位，然后再计算误差。\n\n综上所述，相关矩阵组的整体处理流程如下图所示。\n\n\\begin{tikzpicture}[node distance=2cm, auto, thick, main/.style = {draw, rectangle, minimum size=2cm}]\n    \\node[main] (input) {$\\boldsymbol{H} = \\{\\boldsymbol{H}_{j,k}\\}$};\n    \\node[main, right of=input] (compress1) {存储单元};\n    \\node[main, right of=compress1] (decompress1) {计算单元};\n    \\node[main, right of=decompress1] (compress2) {存储单元};\n    \\node[main, right of=compress2] (decompress2) {$\\widehat{\\boldsymbol{W}} = \\{\\widehat{\\boldsymbol{W}}_{j,k}\\}$};\n    \n    \\draw[->] (input) -- node[above] {$P_1(\\cdot)$} (compress1);\n    \\draw[->] (compress1) -- node[above] {$G_1(\\cdot)$} (decompress1);\n    \\draw[->] (decompress1) -- node[above] {$P_2(\\cdot)$} (compress2);\n    \\draw[->] (compress2) -- node[above] {$G_2(\\cdot)$} (decompress2);\n    \n    \\node[above of=compress1, node distance=1cm] {压缩};\n    \\node[above of=decompress1, node distance=1cm] {解压缩};\n    \\node[above of=compress2, node distance=1cm] {压缩};\n    \\node[above of=decompress2, node distance=1cm] {解压缩};\n    \n    \\node[below of=decompress1, node distance=1cm] {$\\widehat{\\boldsymbol{W}} = f(\\boldsymbol{H})$};\n\\end{tikzpicture}\n\n三、建模问题\n\n输入矩阵组 $\\mathbf{H}$、标准中间矩阵组 $\\mathbf{V}$ 和标准输出矩阵组 $\\mathbf{W}$ 的数据及其维度如下，数据采用十进制格式：\n\n\\begin{itemize}\n    \\item 第一组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第二组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第三组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第四组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第五组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第六组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n\\end{itemize}\n\n附件中提供 .mat 及 .csv 文件格式的数据，按需使用其中的一种文件格式即可。\n\n请基于以上提供的数据，采用适当的方法，解决以下相关矩阵组的低复杂度计算和存储建模问题。注意，提交结果及论文需要完成以下问题 1、问题 2 中的至少一题，同时完成两题将适当加分。问题 3 为开放式问题，不作为必选，但鼓励尝试，有新意的算法模型设计将得到加分。\n\n在完成以下问题时，仅需考虑各个问题本身申明的建模需求，不需要考虑其他问题产生的建模需求。例如，在完成问题 3 时，不需要额外考虑问题 1 中 $\\rho_{\\min}(V)$ 的建模估计精度需求。\\section*{问题1：相关矩阵组的低复杂度计算}\n\n1) 基于给定的所有矩阵数据 $H$，分析其数据间的关联性，设计相应的近似分析模型 $\\bar{V} = f_1(H)$，在满足 $\\rho_{\\min}(\\bar{V}) \\geq \\rho_{th} = 0.99$ 的情况下，使得根据表格计算的总计算复杂度最低。\n\\begin{itemize}\n\\item 注1：在本问题中，暂不考虑矩阵数据 $H$ 的压缩与解压缩。\n\\item 注2：参考下述 2)，当采用直接设计分析模型 $W = f(H)$ 的方式时，1) 可以跳过不做。\n\\end{itemize}\n\n2) 基于给定的所有矩阵数据 $H$，分析其数据间的关联性，综合设计相应的近似分析模型 $W = f(H)$，在满足 $\\rho_{\\min}(W) \\geq \\rho_{th} = 0.99$ 的情况下，使得根据表格计算的总计算复杂度最低。\n\\begin{itemize}\n\\item 注1：在本问题中，暂不考虑矩阵数据 $H$ 的压缩与解压缩。\n\\item 注2：在本问题中，可以：\n  \\begin{itemize}\n  \\item 在 1) 的基础上考虑 $W = f_2(\\bar{V})$，因此 $W = f(H) = f_2(f_1(H))$；或者，\n  \\item 不需考虑中间结果 $\\bar{V}$，直接设计分析模型 $W = f(H)$，此时 1) 可以跳过不做。\n  \\end{itemize}\n\\item 注3：如果使用常规数学方法，则考虑矩阵所有运算过程涉及的计算复杂度；如果使用人工智能方法，则优先考虑推理阶段的计算复杂度，但需要充分考虑泛化性。\n\\end{itemize}\n\n\\section*{问题2：相关矩阵组的低复杂度存储}\n\n基于给定的所有矩阵数据 $H$ 和 $W$，分析各自数据间的关联性，分别设计相应的压缩 $P_1(\\cdot)$, $P_2(\\cdot)$ 和解压缩 $G_1(\\cdot)$, $G_2(\\cdot)$ 模型，在满足误差 $err_W \\leq E_{th1} = -30 \\,\\text{dB}$, $err_H \\leq E_{th2} = -30 \\,\\text{dB}$ 的情况下，使得存储复杂度和压缩与解压缩的计算复杂度最低，复杂度计算同问题1。\n\\begin{itemize}\n\\item 注1：压缩与解压缩函数的设计方法不做限定。\n\\item 注2：计算复杂度考虑压缩和解压缩函数的所有运算过程。\n\\item 注3：在本问题中，暂不考虑分析模型 $W = f(H)$ 对输出矩阵组 $W$ 的影响。\n\\item 注4：两个建模优化目标（存储复杂度，压缩与解压缩的计算复杂度）的优先级相同。\n\\end{itemize}\n\n\\section*{问题3：相关矩阵组的低复杂度计算和存储}\n\n基于给定的所有矩阵数据 $H$，分析其数据间的关联性，在满足 $\\rho_{\\min}(W) \\geq \\rho_{th} = 0.99$ 的情况下，设计低复杂度计算和存储的整体方案，完成从矩阵输入信号 $H$ 到近似矩阵输出信号 $W$ 的端到端流程。\n\\begin{itemize}\n\\item 注1：在本问题中，可以考虑从矩阵输入信号 $H$ 到近似矩阵输出信号 $W$ 为一个整体流程，而非依次经过“压缩/解压缩、计算单元、压缩/解压缩”的过程。\n\\item 注2：如果使用人工智能方法，需要考虑人工智能模型的存储复杂度以及推理阶段的计算复杂度。\n\\end{itemize}",
    "dataset_path": [
      "Data1_H.csv",
      "Data1_H.mat",
      "Data1_V.csv",
      "Data1_V.mat",
      "Data1_W.csv",
      "Data1_W.mat",
      "Data2_H.csv",
      "Data2_H.mat",
      "Data2_V.csv",
      "Data2_V.mat",
      "Data2_W.csv",
      "Data2_W.mat",
      "Data3_H.csv",
      "Data3_H.mat",
      "Data3_V.csv",
      "Data3_V.mat",
      "Data3_W.csv",
      "Data3_W.mat",
      "Data4_H.csv",
      "Data4_H.mat",
      "Data4_V.csv",
      "Data4_V.mat",
      "Data4_W.csv",
      "Data4_W.mat",
      "Data5_H.csv",
      "Data5_H.mat",
      "Data5_V.csv",
      "Data5_V.mat",
      "Data5_W.csv",
      "Data5_W.mat",
      "Data6_H.csv",
      "Data6_H.mat",
      "Data6_V.csv",
      "Data6_V.mat",
      "Data6_W.csv",
      "Data6_W.mat",
      "Readme.txt",
      "附录.docx"
    ],
    "dataset_description": {
      "Data1_H": "Data1_H.csv包含一组复数矩阵数据，每个矩阵元素为复数，表示某种特定的物理或数学模型中的数据。矩阵之间存在一定的相关性，特别是在同一行块内部的矩阵间。",
      "Data1_V": "Data1_V.csv包含一组复数矩阵数据，每个矩阵元素为复数，用于描述某种特定的物理或数学模型中的相关性。",
      "Data1_W": "Data1_W.csv包含一组复数矩阵数据，每个矩阵元素以逗号分隔，矩阵之间以换行符分隔。数据用于表示不同矩阵块之间的相关性，每个矩阵块内部的元素具有复数形式。",
      "Data2_H": "Data2_H.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，矩阵之间存在一定的相关性，特别是在同一行块内部的矩阵间存在关联。",
      "Data2_V": "Data2_V.csv包含一组复数矩阵数据，每个矩阵元素为复数，数据格式为CSV。矩阵元素之间存在一定的相关性，特别是在同一行块内部的矩阵间存在关联。",
      "Data2_W": "Data2_W.csv包含一组复数矩阵数据，每个矩阵元素以逗号分隔，矩阵之间以换行符分隔。每个矩阵元素是一个复数，形式为实部+虚部i。",
      "Data3_H": "Data3_H.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于描述特定的物理或数学模型中的相关性。",
      "Data3_V": "Data3_V.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，矩阵之间存在一定的相关性，特别是在同一行块内部的矩阵间存在关联。",
      "Data3_W": "Data3_W.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，矩阵之间存在一定的相关性，特别是同一行块内部的矩阵间存在关联。",
      "Data4_H": "Data4_H.csv包含一组复数矩阵数据，每个矩阵元素为复数，矩阵之间存在一定的相关性，特别是同一行块内部的矩阵间存在关联。",
      "Data4_V": "Data4_V.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，表示在特定应用（如通信系统）中的复数权重或系数。",
      "Data4_W": "Data4_W.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于描述某种特定的物理或数学模型中的相关性。",
      "Data5_H": "Data5_H.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于描述特定的复数矩阵集合。",
      "Data5_V": "Data5_V.csv包含一组复数矩阵数据，每个矩阵元素为复数，数据格式为CSV。每个矩阵的维度为M×N，文件中包含多个这样的矩阵，它们之间存在一定的相关性。",
      "Data5_W": "Data5_W.csv包含一组复数矩阵数据，每个矩阵元素为复数，用于描述某种特定的物理或数学模型中的相关性。",
      "Data6_H": "Data6_H.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于表示某种特定的物理或数学模型中的数据。",
      "Data6_V": "Data6_V.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于描述某种特定的物理或数学模型中的相关性。",
      "Data6_W": "Data6_W.csv包含一组复数矩阵数据，每个矩阵元素为复数，矩阵间存在一定的相关性，特别是同一行块内部的矩阵间存在关联。",
      "Readme": "Readme.txt描述了复数矩阵数据集的结构和存储方式，包括矩阵H、V和W的维度和存储格式。数据集主要用于处理和分析复数矩阵之间的相关性。",
      "附录": "附录.docx包含关于复数矩阵的奇异值分解（SVD）的理论介绍、计算流程图、基于双对角化和QR分解的SVD分解方法、降低矩阵乘法计算复杂度的思想以及基于随机SVD的SVD分解方法。文件内容主要涉及信号处理和矩阵计算中的理论和方法。"
    },
    "variable_description": [
      {
        "字段1": "复数矩阵元素，表示为复数形式，例如 -0.0573195081752203+0.07223851113124791i",
        "字段2": "复数矩阵元素，表示为复数形式，例如 0.1017433963631207+0.0483942961589262i",
        "字段3": "复数矩阵元素，表示为复数形式，例如 0.1986413136767434-0.0163500597447652i",
        "字段4": "复数矩阵元素，表示为复数形式，例如 0.1903448186429902-0.06933378999856921i",
        "字段5": "复数矩阵元素，表示为复数形式，例如 0.0585637111465514+0.0024710325336675i",
        "字段6": "复数矩阵元素，表示为复数形式，例如 0.0522192821880284+0.0141234944316726i",
        "字段7": "复数矩阵元素，表示为复数形式，例如 0.0571538197878162+0.0357232802147536i",
        "字段8": "复数矩阵元素，表示为复数形式，例如 -0.0159003946513353+0.0572570931953365i",
        "字段9": "复数矩阵元素，表示为复数形式，例如 -0.0110096771444464-0.0066322463476208i",
        "字段10": "复数矩阵元素，表示为复数形式，例如 0.0721429393533861+0.08565374814402919i"
      },
      {},
      {
        "字段1": "Data1_V.csv复数矩阵的元素，每个元素由实部和虚部组成，表示为 a+bi 的形式，其中 a 和 b 是实数。",
        "字段2": "Data1_V.csv矩阵元素的实部，表示复数的实数部分。",
        "字段3": "Data1_V.csv矩阵元素的虚部，表示复数的虚数部分。"
      },
      {
        "H": "复数矩阵集合，每个元素H_{j,k}是一个M×N的复数矩阵，j=1,...,J, k=1,...,K。",
        "M": "矩阵H_{j,k}的行数。",
        "N": "矩阵H_{j,k}的列数。",
        "J": "矩阵集合H的行数。",
        "K": "矩阵集合H的列数，表示同一行块内部的矩阵数量。"
      },
      {
        "字段1": "Data1_W.csv复数矩阵的第一个元素，形式为实部+虚部i",
        "字段2": "Data1_W.csv复数矩阵的第二个元素，形式为实部+虚部i",
        "字段3": "Data1_W.csv复数矩阵的第三个元素，形式为实部+虚部i",
        "字段4": "Data1_W.csv复数矩阵的第四个元素，形式为实部+虚部i",
        "字段5": "Data1_W.csv复数矩阵的第五个元素，形式为实部+虚部i",
        "字段6": "Data1_W.csv复数矩阵的第六个元素，形式为实部+虚部i",
        "字段7": "Data1_W.csv复数矩阵的第七个元素，形式为实部+虚部i",
        "字段8": "Data1_W.csv复数矩阵的第八个元素，形式为实部+虚部i",
        "字段9": "Data1_W.csv复数矩阵的第九个元素，形式为实部+虚部i",
        "字段10": "Data1_W.csv复数矩阵的第十个元素，形式为实部+虚部i",
        "字段11": "Data1_W.csv复数矩阵的第十一个元素，形式为实部+虚部i",
        "字段12": "Data1_W.csv复数矩阵的第十二个元素，形式为实部+虚部i",
        "字段13": "Data1_W.csv复数矩阵的第十三个元素，形式为实部+虚部i",
        "字段14": "Data1_W.csv复数矩阵的第十四个元素，形式为实部+虚部i",
        "字段15": "Data1_W.csv复数矩阵的第十五个元素，形式为实部+虚部i",
        "字段16": "Data1_W.csv复数矩阵的第十六个元素，形式为实部+虚部i",
        "字段17": "Data1_W.csv复数矩阵的第十七个元素，形式为实部+虚部i",
        "字段18": "Data1_W.csv复数矩阵的第十八个元素，形式为实部+虚部i",
        "字段19": "Data1_W.csv复数矩阵的第十九个元素，形式为实部+虚部i",
        "字段20": "Data1_W.csv复数矩阵的第二十个元素，形式为实部+虚部i",
        "字段21": "Data1_W.csv复数矩阵的第二十一个元素，形式为实部+虚部i",
        "字段22": "Data1_W.csv复数矩阵的第二十二个元素，形式为实部+虚部i",
        "字段23": "Data1_W.csv复数矩阵的第二十三个元素，形式为实部+虚部i",
        "字段24": "Data1_W.csv复数矩阵的第二十四个元素，形式为实部+虚部i",
        "字段25": "Data1_W.csv复数矩阵的第二十五个元素，形式为实部+虚部i",
        "字段26": "Data1_W.csv复数矩阵的第二十六个元素，形式为实部+虚部i",
        "字段27": "Data1_W.csv复数矩阵的第二十七个元素，形式为实部+虚部i",
        "字段28": "Data1_W.csv复数矩阵的第二十八个元素，形式为实部+虚部i",
        "字段29": "Data1_W.csv复数矩阵的第二十九个元素，形式为实部+虚部i",
        "字段30": "Data1_W.csv复数矩阵的第三十个元素，形式为实部+虚部i",
        "字段31": "Data1_W.csv复数矩阵的第三十一个元素，形式为实部+虚部i",
        "字段32": "Data1_W.csv复数矩阵的第三十二个元素，形式为实部+虚部i",
        "字段33": "Data1_W.csv复数矩阵的第三十三个元素，形式为实部+虚部i",
        "字段34": "Data1_W.csv复数矩阵的第三十四个元素，形式为实部+虚部i",
        "字段35": "Data1_W.csv复数矩阵的第三十五个元素，形式为实部+虚部i",
        "字段36": "Data1_W.csv复数矩阵的第三十六个元素，形式为实部+虚部i",
        "字段37": "Data1_W.csv复数矩阵的第三十七个元素，形式为实部+虚部i",
        "字段38": "Data1_W.csv复数矩阵的第三十八个元素，形式为实部+虚部i",
        "字段39": "Data1_W.csv复数矩阵的第三十九个元素，形式为实部+虚部i",
        "字段40": "Data1_W.csv复数矩阵的第四十个元素，形式为实部+虚部i",
        "字段41": "Data1_W.csv复数矩阵的第四十一个元素，形式为实部+虚部i",
        "字段42": "Data1_W.csv复数矩阵的第四十二个元素，形式为实部+虚部i",
        "字段43": "Data1_W.csv复数矩阵的第四十三个元素，形式为实部+虚部i",
        "字段44": "Data1_W.csv复数矩阵的第四十四个元素，形式为实部+虚部i",
        "字段45": "Data1_W.csv复数矩阵的第四十五个元素，形式为实部+虚部i",
        "字段46": "Data1_W.csv复数矩阵的第四十六个元素，形式为实部+虚部i",
        "字段47": "Data1_W.csv复数矩阵的第四十七个元素，形式为实部+虚部i",
        "字段48": "Data1_W.csv复数矩阵的第四十八个元素，形式为实部+虚部i",
        "字段49": "Data1_W.csv复数矩阵的第四十九个元素，形式为实部+虚部i",
        "字段50": "Data1_W.csv复数矩阵的第五十个元素，形式为实部+虚部i",
        "字段51": "Data1_W.csv复数矩阵的第五十一个元素，形式为实部+虚部i",
        "字段52": "Data1_W.csv复数矩阵的第五十二个元素，形式为实部+虚部i",
        "字段53": "Data1_W.csv复数矩阵的第五十三个元素，形式为实部+虚部i",
        "字段54": "Data1_W.csv复数矩阵的第五十四个元素，形式为实部+虚部i",
        "字段55": "Data1_W.csv复数矩阵的第五十五个元素，形式为实部+虚部i",
        "字段56": "Data1_W.csv复数矩阵的第五十六个元素，形式为实部+虚部i",
        "字段57": "Data1_W.csv复数矩阵的第五十七个元素，形式为实部+虚部i",
        "字段58": "Data1_W.csv复数矩阵的第五十八个元素，形式为实部+虚部i",
        "字段59": "Data1_W.csv复数矩阵的第五十九个元素，形式为实部+虚部i",
        "字段60": "Data1_W.csv复数矩阵的第六十个元素，形式为实部+虚部i",
        "字段61": "Data1_W.csv复数矩阵的第六十一个元素，形式为实部+虚部i",
        "字段62": "Data1_W.csv复数矩阵的第六十二个元素，形式为实部+虚部i",
        "字段63": "Data1_W.csv复数矩阵的第六十三个元素，形式为实部+虚部i",
        "字段64": "Data1_W.csv复数矩阵的第六十四个元素，形式为实部+虚部i",
        "字段65": "Data1_W.csv复数矩阵的第六十五个元素，形式为实部+虚部i",
        "字段66": "Data1_W.csv复数矩阵的第六十六个元素，形式为实部+虚部i",
        "字段67": "Data1_W.csv复数矩阵的第六十七个元素，形式为实部+虚部i",
        "字段68": "Data1_W.csv复数矩阵的第六十八个元素，形式为实部+虚部i",
        "字段69": "Data1_W.csv复数矩阵的第六十九个元素，形式为实部+虚部i",
        "字段70": "Data1_W.csv复数矩阵的第七十个元素，形式为实部+虚部i",
        "字段71": "Data1_W.csv复数矩阵的第七十一个元素，形式为实部+虚部i",
        "字段72": "Data1_W.csv复数矩阵的第七十二个元素，形式为实部+虚部i",
        "字段73": "Data1_W.csv复数矩阵的第七十三个元素，形式为实部+虚部i",
        "字段74": "Data1_W.csv复数矩阵的第七十四个元素，形式为实部+虚部i",
        "字段75": "Data1_W.csv复数矩阵的第七十五个元素，形式为实部+虚部i",
        "字段76": "Data1_W.csv复数矩阵的第七十六个元素，形式为实部+虚部i",
        "字段77": "Data1_W.csv复数矩阵的第七十七个元素，形式为实部+虚部i",
        "字段78": "Data1_W.csv复数矩阵的第七十八个元素，形式为实部+虚部i",
        "字段79": "Data1_W.csv复数矩阵的第七十九个元素，形式为实部+虚部i",
        "字段80": "Data1_W.csv复数矩阵的第八十个元素，形式为实部+虚部i",
        "字段81": "Data1_W.csv复数矩阵的第八十一个元素，形式为实部+虚部i"
      },
      {},
      {
        "字段1": "复数矩阵元素，形式为实部+虚部i，例如0.048004150390625+0.05682373046875i",
        "字段2": "复数矩阵元素，形式为实部+虚部i，例如0.0615234375-0.034729003906875i",
        "字段3": "复数矩阵元素，形式为实部+虚部i，例如0.09735107421875-0.0924072265625i",
        "字段4": "复数矩阵元素，形式为实部+虚部i，例如0.172607421875-0.09051513671875i",
        "字段5": "复数矩阵元素，形式为实部+虚部i，例如0.146240234375+0.01204681396484375i",
        "字段6": "复数矩阵元素，形式为实部+虚部i，例如0.123779296875+0.1549072265625i",
        "字段7": "复数矩阵元素，形式为实部+虚部i，例如0.057830810546875+0.11590576171875i",
        "字段8": "复数矩阵元素，形式为实部+虚部i，例如0.044921875+0.03875732421875i",
        "字段9": "复数矩阵元素，形式为实部+虚部i，例如0.08319091796875+0.0237884521484375i",
        "字段10": "复数矩阵元素，形式为实部+虚部i，例如0.06842041015625+0.005157470703125i",
        "字段11": "复数矩阵元素，形式为实部+虚部i，例如0.06097412109375+0.039581298828125i",
        "字段12": "复数矩阵元素，形式为实部+虚部i，例如0.09613037109375+0.041595458984375i",
        "字段13": "复数矩阵元素，形式为实部+虚部i，例如0.10443115234375+0.0792236328125i",
        "字段14": "复数矩阵元素，形式为实部+虚部i，例如0.04583740234375+0.1370849609375i",
        "字段15": "复数矩阵元素，形式为实部+虚部i，例如0.059112548828125+0.06658935546875i",
        "字段16": "复数矩阵元素，形式为实部+虚部i，例如-0.0440673828125+0.0070343017578125i",
        "字段17": "复数矩阵元素，形式为实部+虚部i，例如0.06341552734375-0.028778076171875i",
        "字段18": "复数矩阵元素，形式为实部+虚部i，例如0.00106048583984375+0.050567626953125i",
        "字段19": "复数矩阵元素，形式为实部+虚部i，例如0.032989501953125+0.115966796875i",
        "字段20": "复数矩阵元素，形式为实部+虚部i，例如0.05706787109375+0.049652099609375i",
        "字段21": "复数矩阵元素，形式为实部+虚部i，例如-0.0084381103515625+0.02154541015625i",
        "字段22": "复数矩阵元素，形式为实部+虚部i，例如0.005336761474609375+0.03729248046875i",
        "字段23": "复数矩阵元素，形式为实部+虚部i，例如0.002553939819335938+0.03143310546875i",
        "字段24": "复数矩阵元素，形式为实部+虚部i，例如-0.07733154296875-0.0001319646835327148i",
        "字段25": "复数矩阵元素，形式为实部+虚部i，例如0.002820968627929688-0.01214599609375i",
        "字段26": "复数矩阵元素，形式为实部+虚部i，例如-0.046478271484375+0.0303802490234375i",
        "字段27": "复数矩阵元素，形式为实部+虚部i，例如0.001781463623046875+0.05078125i",
        "字段28": "复数矩阵元素，形式为实部+虚部i，例如-0.03668212890625+0.043182373046875i",
        "字段29": "复数矩阵元素，形式为实部+虚部i，例如-0.048095703125+0.059326171875i",
        "字段30": "复数矩阵元素，形式为实部+虚部i，例如0.0237579345703125+0.05682373046875i",
        "字段31": "复数矩阵元素，形式为实部+虚部i，例如0.04547119140625-0.0228271484375i",
        "字段32": "复数矩阵元素，形式为实部+虚部i，例如0.002817153930664062-0.00959014892578125i",
        "字段33": "复数矩阵元素，形式为实部+虚部i，例如0.040374755859375+0.035064697265625i",
        "字段34": "复数矩阵元素，形式为实部+虚部i，例如0.09124755859375-0.058746337890625i",
        "字段35": "复数矩阵元素，形式为实部+虚部i，例如0.060760498046875-0.041259765625i",
        "字段36": "复数矩阵元素，形式为实部+虚部i，例如0.04351806640625-0.0439453125i",
        "字段37": "复数矩阵元素，形式为实部+虚部i，例如0.0794677734375-0.09490966796875i",
        "字段38": "复数矩阵元素，形式为实部+虚部i，例如0.07574462890625-0.019256591796875i",
        "字段39": "复数矩阵元素，形式为实部+虚部i，例如0.04901123046875+0.0170745849609375i",
        "字段40": "复数矩阵元素，形式为实部+虚部i，例如0.067138671875+0.047393798828125i",
        "字段41": "复数矩阵元素，形式为实部+虚部i，例如0.117919921875-0.048858642578125i",
        "字段42": "复数矩阵元素，形式为实部+虚部i，例如0.115478515625-0.0357666015625i",
        "字段43": "复数矩阵元素，形式为实部+虚部i，例如0.01641845703125+0.055450439453125i",
        "字段44": "复数矩阵元素，形式为实部+虚部i，例如-0.007801055908203125+0.09820556640625i",
        "字段45": "复数矩阵元素，形式为实部+虚部i，例如0.1077880859375-0.007389068603515625i",
        "字段46": "复数矩阵元素，形式为实部+虚部i，例如0.06195068359375+0.03167724609375i",
        "字段47": "复数矩阵元素，形式为实部+虚部i，例如0.059906005859375+0.09161376953125i",
        "字段48": "复数矩阵元素，形式为实部+虚部i，例如-0.056365966796875+0.01776123046875i",
        "字段49": "复数矩阵元素，形式为实部+虚部i，例如0.0987548828125-0.0357666015625i",
        "字段50": "复数矩阵元素，形式为实部+虚部i，例如0.0849609375+0.0576171875i",
        "字段51": "复数矩阵元素，形式为实部+虚部i，例如-0.001552581787109375+0.09429931640625i",
        "字段52": "复数矩阵元素，形式为实部+虚部i，例如-0.051666259765625-0.0180206298828125i",
        "字段53": "复数矩阵元素，形式为实部+虚部i，例如-0.036376953125-0.006664276123046875i",
        "字段54": "复数矩阵元素，形式为实部+虚部i，例如-0.02880859375+0.09228515625i",
        "字段55": "复数矩阵元素，形式为实部+虚部i，例如-0.04315185546875+0.08575439453125i",
        "字段56": "复数矩阵元素，形式为实部+虚部i，例如-0.11676025390625-0.0155181884765625i",
        "字段57": "复数矩阵元素，形式为实部+虚部i，例如0.046661376953125-0.0219879150390625i",
        "字段58": "复数矩阵元素，形式为实部+虚部i，例如-0.0469970703125+0.0675048828125i",
        "字段59": "复数矩阵元素，形式为实部+虚部i，例如-0.034698486328125-0.01177215576171875i",
        "字段60": "复数矩阵元素，形式为实部+虚部i，例如-0.08837890625-0.0201416015625i",
        "字段61": "复数矩阵元素，形式为实部+虚部i，例如-0.1015625-0.01369476318359375i",
        "字段62": "复数矩阵元素，形式为实部+虚部i，例如-0.0384521484375+0.0340576171875i",
        "字段63": "复数矩阵元素，形式为实部+虚部i，例如-0.0164642333984375-0.006000518798828125i",
        "字段64": "复数矩阵元素，形式为实部+虚部i，例如-0.037994384765625-0.0806884765625i"
      },
      {},
      {
        "字段1": "复数矩阵元素，格式为实部+虚部i，例如0.1348683177726314-6.486689751263888e-18i",
        "字段2": "复数矩阵元素，格式为实部+虚部i，例如0.01395357762261786-0.03669933568225095i",
        "字段3": "复数矩阵元素，格式为实部+虚部i，例如-0.03264978047578374-0.04726938488383i",
        "字段4": "复数矩阵元素，格式为实部+虚部i，例如-0.07544280778584202-0.07994732121107247i",
        "字段5": "复数矩阵元素，格式为实部+虚部i，例如-0.1359511466176085-0.08698052574222374i",
        "字段6": "复数矩阵元素，格式为实部+虚部i，例如-0.2277828150823917-0.06667043770543274i",
        "字段7": "复数矩阵元素，格式为实部+虚部i，例如-0.1542157881124336-0.1968850450789114i",
        "字段8": "复数矩阵元素，格式为实部+虚部i，例如-0.1104503835342339-0.07924685955270896i",
        "字段9": "复数矩阵元素，格式为实部+虚部i，例如0.01961045610274203-0.05757719757263841i",
        "字段10": "复数矩阵元素，格式为实部+虚部i，例如-0.02637527105490748-0.05370956417835392i",
        "字段11": "复数矩阵元素，格式为实部+虚部i，例如-0.0956917294722527-0.0444712750239358i",
        "字段12": "复数矩阵元素，格式为实部+虚部i，例如-0.08572525155870681-0.02672308431815517i",
        "字段13": "复数矩阵元素，格式为实部+虚部i，例如-0.133707152588923-0.01659071127741192i",
        "字段14": "复数矩阵元素，格式为实部+虚部i，例如-0.2119962331777845-0.05995057916994304i",
        "字段15": "复数矩阵元素，格式为实部+虚部i，例如-0.2162720200290589-0.03405309706368799i",
        "字段16": "复数矩阵元素，格式为实部+虚部i，例如-0.1101587945023687+0.04746760658233819i",
        "字段17": "复数矩阵元素，格式为实部+虚部i，例如0.0521107551998064-0.1188858842036796i",
        "字段18": "复数矩阵元素，格式为实部+虚部i，例如0.0002825348863659704-0.05394879992942355i",
        "字段19": "复数矩阵元素，格式为实部+虚部i，例如-0.07183283548413766-0.0128761847164831i",
        "字段20": "复数矩阵元素，格式为实部+虚部i，例如-0.04508484954622149-0.02552562187960871i",
        "字段21": "复数矩阵元素，格式为实部+虚部i，例如-0.0535376521502315+0.01687249029479821i",
        "字段22": "复数矩阵元素，格式为实部+虚部i，例如-0.1909041779737298+0.09486022063764266i",
        "字段23": "复数矩阵元素，格式为实部+虚部i，例如-0.2206381312908412+0.1435318675213286i",
        "字段24": "复数矩阵元素，格式为实部+虚部i，例如-0.08796732995284896+0.09541113877953843i",
        "字段25": "复数矩阵元素，格式为实部+虚部i，例如-0.03780036073104211-0.1104338146396621i",
        "字段26": "复数矩阵元素，格式为实部+虚部i，例如-0.05305718493723603-0.1106534312402578i",
        "字段27": "复数矩阵元素，格式为实部+虚部i，例如-0.005933585845797896-0.0282961656361336i",
        "字段28": "复数矩阵元素，格式为实部+虚部i，例如0.04022898730271977+0.0168466020076732i",
        "字段29": "复数矩阵元素，格式为实部+虚部i，例如-0.03426219841145725+0.04625563408987595i",
        "字段30": "复数矩阵元素，格式为实部+虚部i，例如-0.1075636542390828+0.1229380611954588i",
        "字段31": "复数矩阵元素，格式为实部+虚部i，例如-0.05951252959421954+0.1262619739899129i",
        "字段32": "复数矩阵元素，格式为实部+虚部i，例如-0.08373158000002319+0.1280636591274074i",
        "字段33": "复数矩阵元素，格式为实部+虚部i，例如0.08259176402473105-0.03814679650221789i",
        "字段34": "复数矩阵元素，格式为实部+虚部i，例如-0.06210277524957084-0.07616456530756979i",
        "字段35": "复数矩阵元素，格式为实部+虚部i，例如-0.05166628349252307-0.0116991892560419i",
        "字段36": "复数矩阵元素，格式为实部+虚部i，例如-0.08652063328508142+0.04965669955739916i",
        "字段37": "复数矩阵元素，格式为实部+虚部i，例如-0.06273288150888041-0.109238719973504i",
        "字段38": "复数矩阵元素，格式为实部+虚部i，例如-0.06255371133483767-0.1024758231294641i",
        "字段39": "复数矩阵元素，格式为实部+虚部i，例如-0.05903338972323135-0.02989908943541215i",
        "字段40": "复数矩阵元素，格式为实部+虚部i，例如-0.07754025410299983-0.0052884308837983i",
        "字段41": "复数矩阵元素，格式为实部+虚部i，例如0.04045580357317161-0.07677269227196749i",
        "字段42": "复数矩阵元素，格式为实部+虚部i，例如-0.1108762476036159+0.02043711672510128i",
        "字段43": "复数矩阵元素，格式为实部+虚部i，例如-0.1120646709478676+0.1469991522970532i",
        "字段44": "复数矩阵元素，格式为实部+虚部i，例如-0.1106805754977222+0.0771222499163582i",
        "字段45": "复数矩阵元素，格式为实部+虚部i，例如-0.100504060977378-0.06851908220044313i",
        "字段46": "复数矩阵元素，格式为实部+虚部i，例如-0.1001687886629608-0.01931170449465862i",
        "字段47": "复数矩阵元素，格式为实部+虚部i，例如-0.09470706025426118+0.06742583099321468i",
        "字段48": "复数矩阵元素，格式为实部+虚部i，例如-0.01762368921910178-0.002945313851078167i",
        "字段49": "复数矩阵元素，格式为实部+虚部i，例如0.05668505466648035+0.004140606225027113i",
        "字段50": "复数矩阵元素，格式为实部+虚部i，例如-0.02547187999423965+0.2004846090915704i",
        "字段51": "复数矩阵元素，格式为实部+虚部i，例如-0.0154248259066833+0.1414455579584763i",
        "字段52": "复数矩阵元素，格式为实部+虚部i，例如0.05721153908783447-0.04161218016010886i",
        "字段53": "复数矩阵元素，格式为实部+虚部i，例如-0.02355802932670512+0.02992717953134072i",
        "字段54": "复数矩阵元素，格式为实部+虚部i，例如-0.1462370545726034+0.1166761184386175i",
        "字段55": "复数矩阵元素，格式为实部+虚部i，例如-0.05933343475290868+0.03963692007062856i",
        "字段56": "复数矩阵元素，格式为实部+虚部i，例如0.06267738096947863-0.02316844374730323i",
        "字段57": "复数矩阵元素，格式为实部+虚部i，例如0.0189396458167183+0.03951325158279258i",
        "字段58": "复数矩阵元素，格式为实部+虚部i，例如0.06331890598583301+0.1060436582309852i",
        "字段59": "复数矩阵元素，格式为实部+虚部i，例如0.1034008710922889-0.0672223751213465i",
        "字段60": "复数矩阵元素，格式为实部+虚部i，例如0.0740638377436949-0.1081502749032855i",
        "字段61": "复数矩阵元素，格式为实部+虚部i，例如-0.01922178636442999+0.05878709179377601i",
        "字段62": "复数矩阵元素，格式为实部+虚部i，例如-0.1122046807666984+0.1118203493918829i",
        "字段63": "复数矩阵元素，格式为实部+虚部i，例如-0.02888178911592481+0.02119322810058163i",
        "字段64": "复数矩阵元素，格式为实部+虚部i，例如-0.02907049186474421-0.01445158568225714i"
      },
      {},
      {
        "矩阵元素": "每个矩阵元素是一个复数，包含实部和虚部，形式为实部+虚部i。"
      },
      {
        "H": "复数矩阵集合，每个矩阵 H_{j,k} 的维度为 M x N，其中 j = 1, ..., J, k = 1, ..., K。矩阵之间存在特定的相关性，特别是在同一行块内部的矩阵之间。"
      },
      {
        "字段1": "复数矩阵的元素，每个元素由实部和虚部组成，表示为 a+bi 的形式，其中 a 和 b 是浮点数。",
        "字段2": "矩阵元素之间的相关性，同一行块内部的矩阵元素之间存在一定的关联性，但不同行块的矩阵元素之间不考虑相关性。"
      },
      {
        "H": "复数矩阵集合，每个矩阵 H_{j,k} 的维度为 M x N，其中 j = 1, ..., J, k = 1, ..., K。矩阵之间存在特定的相关性，特别是在同一行块内部的矩阵之间。"
      },
      {
        "字段1": "Data3_V.csv复数矩阵的元素，形式为实部+虚部i，每个元素代表矩阵中的一个值。"
      },
      {
        "H": "复数矩阵集合，每个矩阵 H_{j,k} 的大小为 M x N，其中 j = 1, ..., J, k = 1, ..., K",
        "M": "矩阵 H_{j,k} 的行数",
        "N": "矩阵 H_{j,k} 的列数",
        "J": "矩阵集合 H 中矩阵的行数",
        "K": "矩阵集合 H 中矩阵的列数"
      },
      {
        "字段1": "复数矩阵的元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。"
      },
      {},
      {
        "字段1": "复数矩阵的元素，每个元素由实部和虚部组成，表示为 a+bi 的形式，其中 a 和 b 为实数。",
        "字段2": "矩阵的维度为 MxN，其中 M 和 N 分别表示矩阵的行数和列数。",
        "字段3": "矩阵的下标 j 和 k，表示矩阵在数据集中的位置，其中 j 表示行块索引，k 表示同一行块内的矩阵索引。"
      },
      {
        "H": "复数矩阵集合，每个矩阵 H_{j,k} 的维度为 M x N，其中 j = 1, ..., J, k = 1, ..., K。矩阵之间存在特定的相关性，特别是在同一行块内部的矩阵之间。"
      },
      {
        "字段1": "Data4_V.csv复数矩阵的元素，每个元素由实部和虚部组成，表示为 a+bi 形式，其中 a 和 b 为浮点数。",
        "字段2": "Data4_V.csv矩阵元素的实部，表示为浮点数。",
        "字段3": "Data4_V.csv矩阵元素的虚部，表示为浮点数。"
      },
      {},
      {
        "字段1": "Data4_W.csv复数矩阵的第一行第一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段2": "Data4_W.csv复数矩阵的第一行第二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段3": "Data4_W.csv复数矩阵的第一行第三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段4": "Data4_W.csv复数矩阵的第一行第四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段5": "Data4_W.csv复数矩阵的第一行第五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段6": "Data4_W.csv复数矩阵的第一行第六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段7": "Data4_W.csv复数矩阵的第一行第七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段8": "Data4_W.csv复数矩阵的第一行第八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段9": "Data4_W.csv复数矩阵的第一行第九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段10": "Data4_W.csv复数矩阵的第一行第十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段11": "Data4_W.csv复数矩阵的第一行第十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段12": "Data4_W.csv复数矩阵的第一行第十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段13": "Data4_W.csv复数矩阵的第一行第十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段14": "Data4_W.csv复数矩阵的第一行第十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段15": "Data4_W.csv复数矩阵的第一行第十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段16": "Data4_W.csv复数矩阵的第一行第十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段17": "Data4_W.csv复数矩阵的第一行第十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段18": "Data4_W.csv复数矩阵的第一行第十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段19": "Data4_W.csv复数矩阵的第一行第十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段20": "Data4_W.csv复数矩阵的第一行第二十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段21": "Data4_W.csv复数矩阵的第一行第二十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段22": "Data4_W.csv复数矩阵的第一行第二十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段23": "Data4_W.csv复数矩阵的第一行第二十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段24": "Data4_W.csv复数矩阵的第一行第二十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段25": "Data4_W.csv复数矩阵的第一行第二十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段26": "Data4_W.csv复数矩阵的第一行第二十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段27": "Data4_W.csv复数矩阵的第一行第二十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段28": "Data4_W.csv复数矩阵的第一行第二十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段29": "Data4_W.csv复数矩阵的第一行第二十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段30": "Data4_W.csv复数矩阵的第一行第三十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段31": "Data4_W.csv复数矩阵的第一行第三十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段32": "Data4_W.csv复数矩阵的第一行第三十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段33": "Data4_W.csv复数矩阵的第一行第三十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段34": "Data4_W.csv复数矩阵的第一行第三十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段35": "Data4_W.csv复数矩阵的第一行第三十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段36": "Data4_W.csv复数矩阵的第一行第三十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段37": "Data4_W.csv复数矩阵的第一行第三十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段38": "Data4_W.csv复数矩阵的第一行第三十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段39": "Data4_W.csv复数矩阵的第一行第三十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段40": "Data4_W.csv复数矩阵的第一行第四十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段41": "Data4_W.csv复数矩阵的第一行第四十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段42": "Data4_W.csv复数矩阵的第一行第四十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段43": "Data4_W.csv复数矩阵的第一行第四十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段44": "Data4_W.csv复数矩阵的第一行第四十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段45": "Data4_W.csv复数矩阵的第一行第四十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段46": "Data4_W.csv复数矩阵的第一行第四十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段47": "Data4_W.csv复数矩阵的第一行第四十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段48": "Data4_W.csv复数矩阵的第一行第四十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段49": "Data4_W.csv复数矩阵的第一行第四十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段50": "Data4_W.csv复数矩阵的第一行第五十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段51": "Data4_W.csv复数矩阵的第一行第五十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段52": "Data4_W.csv复数矩阵的第一行第五十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段53": "Data4_W.csv复数矩阵的第一行第五十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段54": "Data4_W.csv复数矩阵的第一行第五十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段55": "Data4_W.csv复数矩阵的第一行第五十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段56": "Data4_W.csv复数矩阵的第一行第五十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段57": "Data4_W.csv复数矩阵的第一行第五十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段58": "Data4_W.csv复数矩阵的第一行第五十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段59": "Data4_W.csv复数矩阵的第一行第五十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段60": "Data4_W.csv复数矩阵的第一行第六十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段61": "Data4_W.csv复数矩阵的第一行第六十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段62": "Data4_W.csv复数矩阵的第一行第六十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段63": "Data4_W.csv复数矩阵的第一行第六十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段64": "Data4_W.csv复数矩阵的第一行第六十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段65": "Data4_W.csv复数矩阵的第一行第六十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段66": "Data4_W.csv复数矩阵的第一行第六十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段67": "Data4_W.csv复数矩阵的第一行第六十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段68": "Data4_W.csv复数矩阵的第一行第六十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段69": "Data4_W.csv复数矩阵的第一行第六十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段70": "Data4_W.csv复数矩阵的第一行第七十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段71": "Data4_W.csv复数矩阵的第一行第七十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段72": "Data4_W.csv复数矩阵的第一行第七十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段73": "Data4_W.csv复数矩阵的第一行第七十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段74": "Data4_W.csv复数矩阵的第一行第七十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段75": "Data4_W.csv复数矩阵的第一行第七十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段76": "Data4_W.csv复数矩阵的第一行第七十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段77": "Data4_W.csv复数矩阵的第一行第七十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段78": "Data4_W.csv复数矩阵的第一行第七十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段79": "Data4_W.csv复数矩阵的第一行第七十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段80": "Data4_W.csv复数矩阵的第一行第八十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段81": "Data4_W.csv复数矩阵的第一行第八十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段82": "Data4_W.csv复数矩阵的第一行第八十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段83": "Data4_W.csv复数矩阵的第一行第八十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段84": "Data4_W.csv复数矩阵的第一行第八十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段85": "Data4_W.csv复数矩阵的第一行第八十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段86": "Data4_W.csv复数矩阵的第一行第八十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段87": "Data4_W.csv复数矩阵的第一行第八十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段88": "Data4_W.csv复数矩阵的第一行第八十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段89": "Data4_W.csv复数矩阵的第一行第八十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段90": "Data4_W.csv复数矩阵的第一行第九十个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段91": "Data4_W.csv复数矩阵的第一行第九十一个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段92": "Data4_W.csv复数矩阵的第一行第九十二个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段93": "Data4_W.csv复数矩阵的第一行第九十三个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段94": "Data4_W.csv复数矩阵的第一行第九十四个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段95": "Data4_W.csv复数矩阵的第一行第九十五个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段96": "Data4_W.csv复数矩阵的第一行第九十六个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段97": "Data4_W.csv复数矩阵的第一行第九十七个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段98": "Data4_W.csv复数矩阵的第一行第九十八个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段99": "Data4_W.csv复数矩阵的第一行第九十九个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。",
        "字段100": "Data4_W.csv复数矩阵的第一行第一百个元素，形式为 a+bi，其中 a 和 b 分别为实部和虚部。"
      },
      {},
      {
        "字段1": "复数矩阵元素，每个元素由实部和虚部组成，格式为实部+虚部i，例如：-0.06005859375+0.04339599609375i"
      },
      {
        "Data5_H.mat": null
      },
      {
        "字段1": "复数矩阵的元素，格式为实部+虚部i，例如0.05919721303158053-1.241333868269242e-17i",
        "字段2": "复数矩阵的元素，格式为实部+虚部i，例如0.08188138541560143+0.06575045552574575i",
        "字段3": "复数矩阵的元素，格式为实部+虚部i，例如0.06672617609981607+0.01416564816879124i",
        "字段4": "复数矩阵的元素，格式为实部+虚部i，例如0.1335173988634753+0.08866822007766548i",
        "字段5": "复数矩阵的元素，格式为实部+虚部i，例如0.002412779459503367+0.1187354590403402i",
        "字段6": "复数矩阵的元素，格式为实部+虚部i，例如-0.1141178683619419-0.05002450577465967i",
        "字段7": "复数矩阵的元素，格式为实部+虚部i，例如-0.07433849916186151-0.1281656702513307i",
        "字段8": "复数矩阵的元素，格式为实部+虚部i，例如-0.09596972434453277-0.1037671152238357i",
        "字段9": "复数矩阵的元素，格式为实部+虚部i，例如0.04353728580831757-0.05942879236536401i",
        "字段10": "复数矩阵的元素，格式为实部+虚部i，例如0.08997990408352344-0.0243617259792864i",
        "字段11": "复数矩阵的元素，格式为实部+虚部i，例如0.08141407778117853-0.05689875643324677i",
        "字段12": "复数矩阵的元素，格式为实部+虚部i，例如0.1581593391227167-0.0259867610026242i",
        "字段13": "复数矩阵的元素，格式为实部+虚部i，例如0.02514125752744024+0.08558402591312124i",
        "字段14": "复数矩阵的元素，格式为实部+虚部i，例如-0.1323282470704857-0.0136668597788006i",
        "字段15": "复数矩阵的元素，格式为实部+虚部i，例如-0.1369097994268628-0.08809082543840636i",
        "字段16": "复数矩阵的元素，格式为实部+虚部i，例如-0.1681296809736868-0.015898964296617i",
        "字段17": "复数矩阵的元素，格式为实部+虚部i，例如0.007403733974352648-0.02716509946055574i",
        "字段18": "复数矩阵的元素，格式为实部+虚部i，例如-0.005572462676812223-0.06368213127016754i",
        "字段19": "复数矩阵的元素，格式为实部+虚部i，例如0.005249716805634678-0.1473535356866249i",
        "字段20": "复数矩阵的元素，格式为实部+虚部i，例如0.09413105799587256-0.1292791223447157i",
        "字段21": "复数矩阵的元素，格式为实部+虚部i，例如-0.02004445716968092+0.04368099164614139i",
        "字段22": "复数矩阵的元素，格式为实部+虚部i，例如-0.1355379282474346-0.0119534636369901i",
        "字段23": "复数矩阵的元素，格式为实部+虚部i，例如-0.0557254397035766+0.04254578081205729i",
        "字段24": "复数矩阵的元素，格式为实部+虚部i，例如-0.1512054325509013+0.1227636093440181i",
        "字段25": "复数矩阵的元素，格式为实部+虚部i，例如-0.02331447385813426-0.004652866277569098i",
        "字段26": "复数矩阵的元素，格式为实部+虚部i，例如-0.05516322717473663-0.05289763606176216i",
        "字段27": "复数矩阵的元素，格式为实部+虚部i，例如-0.04445917125633398-0.1442483556904184i",
        "字段28": "复数矩阵的元素，格式为实部+虚部i，例如0.0275375686082275-0.1171542125661238i",
        "字段29": "复数矩阵的元素，格式为实部+虚部i，例如-0.04244950821786414+0.01195791685946303i",
        "字段30": "复数矩阵的元素，格式为实部+虚部i，例如-0.1032508192511356+0.02043984691831308i",
        "字段31": "复数矩阵的元素，格式为实部+虚部i，例如0.005909894303457254+0.1003985293312194i",
        "字段32": "复数矩阵的元素，格式为实部+虚部i，例如-0.04192716761770786+0.1449968166857757i",
        "字段33": "复数矩阵的元素，格式为实部+虚部i，例如0.07450119859534966-0.06817946812443257i",
        "字段34": "复数矩阵的元素，格式为实部+虚部i，例如-0.09031001927332115-0.10343301844171i",
        "字段35": "复数矩阵的元素，格式为实部+虚部i，例如-0.08204015214963281-0.1967086012251286i",
        "字段36": "复数矩阵的元素，格式为实部+虚部i，例如-0.07730110174833696-0.06148307805416404i",
        "字段37": "复数矩阵的元素，格式为实部+虚部i，例如-0.1620235295963397-0.01674442311889856i",
        "字段38": "复数矩阵的元素，格式为实部+虚部i，例如-0.05565955404095829+0.04990291260002143i",
        "字段39": "复数矩阵的元素，格式为实部+虚部i，例如-0.0362145174912022+0.09694876915441079i",
        "字段40": "复数矩阵的元素，格式为实部+虚部i，例如-0.0491606443761933+0.1133246014187295i",
        "字段41": "复数矩阵的元素，格式为实部+虚部i，例如0.05826343945169853+0.03425249285100068i",
        "字段42": "复数矩阵的元素，格式为实部+虚部i，例如-0.1532473149778671+0.01958818203682362i",
        "字段43": "复数矩阵的元素，格式为实部+虚部i，例如-0.151175940372716-0.1088317987324722i",
        "字段44": "复数矩阵的元素，格式为实部+虚部i，例如-0.08839835430296729+0.01480864517123051i",
        "字段45": "复数矩阵的元素，格式为实部+虚部i，例如-0.1614508926604193+0.02873923674847449i",
        "字段46": "复数矩阵的元素，格式为实部+虚部i，例如-0.03997971307540235-0.01584445590175675i",
        "字段47": "复数矩阵的元素，格式为实部+虚部i，例如0.09653750216086414+0.05079893088005873i",
        "字段48": "复数矩阵的元素，格式为实部+虚部i，例如0.1241756367957061+0.1261984096030705i",
        "字段49": "复数矩阵的元素，格式为实部+虚部i，例如0.07201316503298369+0.0772799434498439i",
        "字段50": "复数矩阵的元素，格式为实部+虚部i，例如-0.004713610059740632+0.1105610987547936i",
        "字段51": "复数矩阵的元素，格式为实部+虚部i，例如-0.04623815702828656+0.1366070007846349i",
        "字段52": "复数矩阵的元素，格式为实部+虚部i，例如-0.07246215190836811+0.05701909390335463i",
        "字段53": "复数矩阵的元素，格式为实部+虚部i，例如-0.06288131872876353+0.01960523827443714i",
        "字段54": "复数矩阵的元素，格式为实部+虚部i，例如-0.0599568862555751-0.0558611084020174i",
        "字段55": "复数矩阵的元素，格式为实部+虚部i，例如0.06256080982759882-0.1239080565305148i",
        "字段56": "复数矩阵的元素，格式为实部+虚部i，例如0.1393167758545438-0.03752583665129892i",
        "字段57": "复数矩阵的元素，格式为实部+虚部i，例如0.07097879910590006+0.04817456423427996i",
        "字段58": "复数矩阵的元素，格式为实部+虚部i，例如0.1530166678537265+0.118630521024039i",
        "字段59": "复数矩阵的元素，格式为实部+虚部i，例如0.07197780466334612+0.2111229208144252i",
        "字段60": "复数矩阵的元素，格式为实部+虚部i，例如-0.03656317281454027+0.04324854259198648i",
        "字段61": "复数矩阵的元素，格式为实部+虚部i，例如0.03204419650964958-0.05915405437123161i",
        "字段62": "复数矩阵的元素，格式为实部+虚部i，例如-0.02297430197511927-0.06559752752467367i",
        "字段63": "复数矩阵的元素，格式为实部+虚部i，例如-0.08077536125061843-0.1639635728758033i",
        "字段64": "复数矩阵的元素，格式为实部+虚部i，例如0.0235977402255747-0.1315359521859147i"
      },
      {
        "H": "复数矩阵集合，每个矩阵 H_{j,k} 的大小为 M x N，其中 j = 1, ..., J, k = 1, ..., K",
        "M": "矩阵 H_{j,k} 的行数",
        "N": "矩阵 H_{j,k} 的列数",
        "J": "矩阵集合 H 中矩阵的行数",
        "K": "矩阵集合 H 中矩阵的列数"
      },
      {
        "字段1": "Data5_W.csv复数矩阵的元素，每个元素由实部和虚部组成，表示为 a+bi 的形式，其中 a 和 b 为实数。",
        "字段2": "Data5_W.csv矩阵元素的实部，表示复数的实数部分。",
        "字段3": "Data5_W.csv矩阵元素的虚部，表示复数的虚数部分。"
      },
      {
        "Data5_W": {
          "description": "这个文件是一个 .mat 文件，但读取失败，因此无法直接获取其内部的结构化数据信息。"
        }
      },
      {
        "字段1": "复数矩阵的元素，每个元素由实部和虚部组成，表示为 a+bi 的形式，其中 a 和 b 是浮点数。",
        "字段2": "矩阵的维度为 M x N，其中 M 和 N 分别表示矩阵的行数和列数。",
        "字段3": "矩阵之间的相关性，同一行块内部的 K 个矩阵间存在相关性，但不同行块的矩阵间不考虑相关性。"
      },
      {},
      {
        "字段1": "复数矩阵的元素，每个元素由实部和虚部组成，表示为 a+bi 的形式，其中 a 和 b 分别为实部和虚部的值。"
      },
      {},
      {
        "字段1": "复数矩阵的元素，每个元素由实部和虚部组成，格式为 a+bi，其中 a 和 b 为浮点数。",
        "字段2": "矩阵元素的实部，表示复数的实数部分。",
        "字段3": "矩阵元素的虚部，表示复数的虚数部分。"
      },
      {},
      {
        "M": "矩阵H的行数，值为4",
        "N": "矩阵H的列数，值为64",
        "J": "矩阵H的行块数量，值为4",
        "K": "矩阵H的列块数量，值为384",
        "L": "矩阵V和W的行数，值为2",
        "H": "复数矩阵，维度为M×N×J×K，存储为csv文件，每一行表示N维度，各列按照{M，J，K}顺序排放",
        "V": "复数矩阵，维度为N×L×J×K，存储为csv文件，每一行表示N维度，各列按照{L，J，K}顺序排放",
        "W": "复数矩阵，维度为N×L×J×K，存储为csv文件，每一行表示N维度，各列按照{L，J，K}顺序排放"
      },
      {}
    ],
    "addendum": "如果使用以上方法，当矩阵组 $H = \\{H_{j,k}\\}$ 的维度，或者，矩阵组内各个矩阵 $H_{j,k}$ 的维度继续提升时，整个系统将承受愈发巨大的计算负担。为此，需要通过恰当的建模方法，使得在近似获得输出结果的同时明显地降低计算复杂度。\n\n在本题目中，利用相关矩阵组的关联性降低计算复杂度可以从如下基础方向（或你认为其他更合适的方向）中的一个或者多个方向切入完成建模题目：\n\n1) 利用矩阵组 $H$ 内部各个矩阵间的关联性，减少前述一组数学运算的整体计算复杂度。例如，矩阵组 $H$ 中包括存在关联性的 5 个矩阵 $\\{H_{j,1}, H_{j,2}, H_{j,3}, H_{j,4}, H_{j,5}\\}$，部分情况下可以仅针对 $H_{j,1}, H_{j,3}, H_{j,5}$ 进行相应的运算过程并获取 $\\widehat{W}_{j,1}, \\widehat{W}_{j,3}, \\widehat{W}_{j,5}$，然后通过恰当的插值操作获取 $\\widehat{W}_{j,2}$ 和 $\\widehat{W}_{j,4}$，使得 $\\rho_{l,j,k}(W)$ 均满足前述建模估计精度的需求。\n\n2) 利用矩阵 $H_{j,k}$ 内部各个矩阵元素间的关联性，降低奇异值分解过程、矩阵求逆过程的计算复杂度。关于奇异值分解的低计算复杂度实现，方法不做限定。例如，可以参考文献 [5] 中提出的随机奇异值分解 (Randomized SVD) 方法，其简要实现过程可以参考网页 [6]，部分摘录于附录五。\n\n3) 针对计算流程进行合理的构造和转化，避免执行相对复杂的矩阵运算步骤。例如，矩阵求逆的计算复杂度较高，而本问题的最终需求为 $W_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}$，如果将该步骤转化为 $(V_k^H V_k + \\sigma^2 I) W_k^H = V_k^H$ 形式来求解 $W_k$，则潜在地可以降低整体计算流程的计算复杂度。4) 请注意，在完成本问题时，推荐根据上述表格给出更细化的计算复杂度评估。例如，统计建模过程中复数乘法的使用次数、复数加法的使用次数等，然后分别与复数乘法的计算复杂度（可以为 14）及复数加法的计算复杂度（可以为 2）相乘，累加后得到总体计算复杂度。\n\n存储复杂度定义为矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 占用的存储空间的大小，以比特为单位计算。对于复数矩阵中单个复数元素，其实部和虚部均采用 32 比特单精度浮点表示。因此，整个矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 占用的存储空间分别为 $64MNJK$ 比特和 $64NLJK$ 比特。\n\n为了节省存储开销，考虑对 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 分别进行压缩。独立设计 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 的压缩函数 $P_1(\\cdot)$ 和 $P_2(\\cdot)$，对压缩后的数据 $P_1(\\boldsymbol{H})$ 和 $P_2(\\boldsymbol{W})$ 进行存储。压缩函数的设计请主要考虑挖掘并利用矩阵内部或矩阵间的关联性，或者，矩阵表达的稀疏性；思路可参考但不限于图像的变换域压缩算法或视频的帧间压缩算法。压缩后的每个元素仍然以 32bit 单精度浮点数存储，不考虑位宽的压缩。\n\n$\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 以压缩的形式存储在存储器中。在进行处理之前，需要从存储器中读出 $P_1(\\boldsymbol{H})$ 和 $P_2(\\boldsymbol{W})$ 进行解压缩处理：\n\\[\n\\widehat{\\boldsymbol{H}} = G_1\\big(P_1(\\boldsymbol{H})\\big), \\ \\widehat{\\boldsymbol{W}} = G_2\\big(P_2(\\boldsymbol{W})\\big)\n\\]\n其中，$G_1(\\cdot)$ 和 $G_2(\\cdot)$ 分别表示矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 的解压缩函数。经过压缩和解压缩之后得到的 $\\widehat{\\boldsymbol{H}}$ 和 $\\widehat{\\boldsymbol{W}}$ 与原始的 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 存在误差，定义为\n\\[\nerr_H = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{H}}_{j,k} - \\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}, \\ err_W = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{W}}_{j,k} - \\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}\n\\]\n其中，$\\|\\cdot\\|_F$ 表示矩阵的 Frobenius 范数；$E\\{\\cdot\\}$ 表示求期望运算，即在所提供矩阵组的所有矩阵求平均。注意：标准输出矩阵组 $\\boldsymbol{W}$ 是 0 相位，即其中矩阵 $\\boldsymbol{W}_{j,k}$ 的每个列向量的首个元素是 0 相位复数（实数）。若建模得到的 $\\widehat{\\boldsymbol{W}}_{j,k}$ 带有随机初始相位，可增加一步相位拉齐处理，将 $\\widehat{\\boldsymbol{W}}_{j,k}$ 拉齐到与 $\\boldsymbol{W}_{j,k}$ 相同的 0 相位，然后再计算误差。\n\n综上所述，相关矩阵组的整体处理流程如下图所示。\n\n\\begin{tikzpicture}[node distance=2cm, auto, thick, main/.style = {draw, rectangle, minimum size=2cm}]\n    \\node[main] (input) {$\\boldsymbol{H} = \\{\\boldsymbol{H}_{j,k}\\}$};\n    \\node[main, right of=input] (compress1) {存储单元};\n    \\node[main, right of=compress1] (decompress1) {计算单元};\n    \\node[main, right of=decompress1] (compress2) {存储单元};\n    \\node[main, right of=compress2] (decompress2) {$\\widehat{\\boldsymbol{W}} = \\{\\widehat{\\boldsymbol{W}}_{j,k}\\}$};\n    \n    \\draw[->] (input) -- node[above] {$P_1(\\cdot)$} (compress1);\n    \\draw[->] (compress1) -- node[above] {$G_1(\\cdot)$} (decompress1);\n    \\draw[->] (decompress1) -- node[above] {$P_2(\\cdot)$} (compress2);\n    \\draw[->] (compress2) -- node[above] {$G_2(\\cdot)$} (decompress2);\n    \n    \\node[above of=compress1, node distance=1cm] {压缩};\n    \\node[above of=decompress1, node distance=1cm] {解压缩};\n    \\node[above of=compress2, node distance=1cm] {压缩};\n    \\node[above of=decompress2, node distance=1cm] {解压缩};\n    \n    \\node[below of=decompress1, node distance=1cm] {$\\widehat{\\boldsymbol{W}} = f(\\boldsymbol{H})$};\n\\end{tikzpicture}\n\n请基于以上提供的数据，采用适当的方法，解决以下相关矩阵组的低复杂度计算和存储建模问题。注意，提交结果及论文需要完成以下问题 1、问题 2 中的至少一题，同时完成两题将适当加分。问题 3 为开放式问题，不作为必选，但鼓励尝试，有新意的算法模型设计将得到加分。\n\n在完成以下问题时，仅需考虑各个问题本身申明的建模需求，不需要考虑其他问题产生的建模需求。例如，在完成问题 3 时，不需要额外考虑问题 1 中 $\\rho_{\\min}(V)$ 的建模估计精度需求。参考文献\nSwartzlander, Earl E., and Hani H. Saleh. \"Floating-point implementation of complex multiplication.\" 2009 Conference Record of the Forty-Third Asilomar Conference on Signals, Systems and Computers. IEEE, 2009.\nGolub, Gene, and William Kahan. \"Calculating the singular values and pseudo-inverse of a matrix.\" Journal of the Society for Industrial and Applied Mathematics, Series B: Numerical Analysis 2.2 (1965): 205-224.\nStrassen, Volker. \"Gaussian elimination is not optimal.\" Numerische mathematik 13.4 (1969): 354-356.\nCoppersmith, Don, and Shmuel Winograd. \"Matrix multiplication via arithmetic progressions.\" Proceedings of the nineteenth annual ACM symposium on Theory of computing. 1987.\nHalko, Nathan, Per-Gunnar Martinsson, and Joel A. Tropp. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions.\" SIAM review 53.2 (2011): 217-288.\n网址：https://gregorygundersen.com/blog/2019/01/17/randomized-svd/",
    "data_summary": "Dataset Path:\n['Data1_H.csv', 'Data1_H.mat', 'Data1_V.csv', 'Data1_V.mat', 'Data1_W.csv', 'Data1_W.mat', 'Data2_H.csv', 'Data2_H.mat', 'Data2_V.csv', 'Data2_V.mat', 'Data2_W.csv', 'Data2_W.mat', 'Data3_H.csv', 'Data3_H.mat', 'Data3_V.csv', 'Data3_V.mat', 'Data3_W.csv', 'Data3_W.mat', 'Data4_H.csv', 'Data4_H.mat', 'Data4_V.csv', 'Data4_V.mat', 'Data4_W.csv', 'Data4_W.mat', 'Data5_H.csv', 'Data5_H.mat', 'Data5_V.csv', 'Data5_V.mat', 'Data5_W.csv', 'Data5_W.mat', 'Data6_H.csv', 'Data6_H.mat', 'Data6_V.csv', 'Data6_V.mat', 'Data6_W.csv', 'Data6_W.mat', 'Readme.txt', '附录.docx']\n\nData Description:\n该数据集由多组以CSV（部分为.mat）格式存储的复数矩阵文件构成（主要文件名为Data1_H/V/W … Data6_H/V/W、Data5_H.mat、Readme.txt及附录.docx），每个矩阵元素均为复数形式（实部+虚部i，部分数值显示极小虚部如e-17），CSV文件中复数元素以逗号分隔、矩阵按行/块排列并以换行分隔，整体按约定的多维张量顺序存储：H 集合的理论维度为 M×N×J×K（示例给定 M=4、N=64、J=4、K=384），V 和 W 的维度为 N×L×J×K（示例 L=2），且CSV行通常对应 N 维度、列按{M, J, K}或{L, J, K}顺序排放；各 Data*_H/V/W 文件分别包含不同场景下的复数矩阵集合，元素数值分布多为小幅正负浮点数（示例值如0.059197+0.1187i、-0.06006+0.04340i等），部分 W 文件列字段非常多（如 Data4_W 列举至上百个元素字段），Data5_H 被提供为 .mat 文件但其中的 W 读取失败并记录为无法解析。数据描述反复强调矩阵之间存在结构性相关性，尤其是在同一“行块”内部的 K 个矩阵之间具有显著相关性（不同行块之间通常不考虑相关性），因此适合用于信号处理与通信系统领域的矩阵相关性分析、降维与分解任务；附录.docx 提供了关于奇异值分解（SVD）的理论与实现细节（含双对角化+QR、基于随机SVD的近似方法及降低矩阵乘法复杂度的策略），Readme.txt 则说明了文件的存储格式与维度约定，便于按上述多维索引重构原始矩阵张量并用于后续的矩阵分解、统计分析或模型验证。",
    "data_description": {
      "Data1_H": "Data1_H.csv包含一组复数矩阵数据，每个矩阵元素为复数，表示某种特定的物理或数学模型中的数据。矩阵之间存在一定的相关性，特别是在同一行块内部的矩阵间。",
      "Data1_V": "Data1_V.csv包含一组复数矩阵数据，每个矩阵元素为复数，用于描述某种特定的物理或数学模型中的相关性。",
      "Data1_W": "Data1_W.csv包含一组复数矩阵数据，每个矩阵元素以逗号分隔，矩阵之间以换行符分隔。数据用于表示不同矩阵块之间的相关性，每个矩阵块内部的元素具有复数形式。",
      "Data2_H": "Data2_H.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，矩阵之间存在一定的相关性，特别是在同一行块内部的矩阵间存在关联。",
      "Data2_V": "Data2_V.csv包含一组复数矩阵数据，每个矩阵元素为复数，数据格式为CSV。矩阵元素之间存在一定的相关性，特别是在同一行块内部的矩阵间存在关联。",
      "Data2_W": "Data2_W.csv包含一组复数矩阵数据，每个矩阵元素以逗号分隔，矩阵之间以换行符分隔。每个矩阵元素是一个复数，形式为实部+虚部i。",
      "Data3_H": "Data3_H.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于描述特定的物理或数学模型中的相关性。",
      "Data3_V": "Data3_V.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，矩阵之间存在一定的相关性，特别是在同一行块内部的矩阵间存在关联。",
      "Data3_W": "Data3_W.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，矩阵之间存在一定的相关性，特别是同一行块内部的矩阵间存在关联。",
      "Data4_H": "Data4_H.csv包含一组复数矩阵数据，每个矩阵元素为复数，矩阵之间存在一定的相关性，特别是同一行块内部的矩阵间存在关联。",
      "Data4_V": "Data4_V.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，表示在特定应用（如通信系统）中的复数权重或系数。",
      "Data4_W": "Data4_W.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于描述某种特定的物理或数学模型中的相关性。",
      "Data5_H": "Data5_H.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于描述特定的复数矩阵集合。",
      "Data5_V": "Data5_V.csv包含一组复数矩阵数据，每个矩阵元素为复数，数据格式为CSV。每个矩阵的维度为M×N，文件中包含多个这样的矩阵，它们之间存在一定的相关性。",
      "Data5_W": "Data5_W.csv包含一组复数矩阵数据，每个矩阵元素为复数，用于描述某种特定的物理或数学模型中的相关性。",
      "Data6_H": "Data6_H.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于表示某种特定的物理或数学模型中的数据。",
      "Data6_V": "Data6_V.csv包含一组复数矩阵数据，每个矩阵元素为复数形式，用于描述某种特定的物理或数学模型中的相关性。",
      "Data6_W": "Data6_W.csv包含一组复数矩阵数据，每个矩阵元素为复数，矩阵间存在一定的相关性，特别是同一行块内部的矩阵间存在关联。",
      "Readme": "Readme.txt描述了复数矩阵数据集的结构和存储方式，包括矩阵H、V和W的维度和存储格式。数据集主要用于处理和分析复数矩阵之间的相关性。",
      "附录": "附录.docx包含关于复数矩阵的奇异值分解（SVD）的理论介绍、计算流程图、基于双对角化和QR分解的SVD分解方法、降低矩阵乘法计算复杂度的思想以及基于随机SVD的SVD分解方法。文件内容主要涉及信号处理和矩阵计算中的理论和方法。"
    },
    "problem_str": "问题背景：\n计算机视觉、相控阵雷达、声呐、射电天文、无线通信等领域的信号通常呈现为矩阵的形式，这一系列的矩阵间通常在某些维度存在一定的关联性，因此数学上可用相关矩阵组表示。例如，视频信号中的单帧图像可视为一个矩阵，连续的多帧图像组成了相关矩阵组，而相邻图像帧或图像帧内像素间的关联性则反映在矩阵间的相关性上。随着成像传感器数量/雷达阵列/通信阵列的持续扩大，常规处理算法对计算和存储的需求成倍增长，从而对处理器件或算法的实现成本和功耗提出了巨大的挑战。因此，充分挖掘矩阵间关联性，以实现低复杂度的计算和存储，具有十分重要的价值和意义。\n\n问题要求：\n给定一组复数矩阵 $H = \\{H_{j,k}\\}$，$H_{j,k} \\in \\mathbb{C}^{M \\times N}, j = 1, \\ldots, J, k = 1, \\ldots, K$。其中，矩阵之间以及同一矩阵的元素之间有一定的相关性，包括：相同 $j$ 下标、不同 $k$ 下标的矩阵间存在一定的关联，即 $\\{H_{j,1}, H_{j,2}, H_{j,3}, \\ldots, H_{j,K}\\}$ 间存在关联\\footnote{在本问题中，仅考虑同一行块内部的 $K$ 个矩阵间的相关性，不考虑矩阵组 $H$ 中属于不同行块的矩阵（即，不同 $j$ 下标的矩阵）间的相关性。}；且矩阵\n\n\\[\nH_{j,k} = \\begin{bmatrix}\n h_{1,1}^{(j,k)} & h_{1,2}^{(j,k)} & h_{1,3}^{(j,k)} & \\cdots & h_{1,N}^{(j,k)} \\\n h_{2,1}^{(j,k)} & h_{2,2}^{(j,k)} & h_{2,3}^{(j,k)} & \\cdots & h_{2,N}^{(j,k)} \\\n \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\n h_{M,1}^{(j,k)} & h_{M,2}^{(j,k)} & h_{M,3}^{(j,k)} & \\cdots & h_{M,N}^{(j,k)}\n\\end{bmatrix}\n\\]\n\n的各个元素间 $\\{h_{m,n}^{(j,k)}\\}, m = 1, \\ldots, M, n = 1, \\ldots, N$，也存在关联。\n\n定义矩阵组 $H = \\{H_{j,k}\\}$ 上的一组数学运算，其中间结果 $V = \\{V_{j,k}\\}$ 由如下的公式给出：\n\n\\[\nV_{j,k} = svd\\big(H_{j,k}\\big), \\text{or } H_{j,k} = U_{j,k} S_{j,k} \\widetilde{V}_{j,k}^H, V_{j,k} = \\widetilde{V}_{j,k}^H(:,1:L)\n\\]\n\n\\[\nj = 1, \\ldots, J; \\, k = 1, \\ldots, K\n\\]其中，\\(svd(\\cdot)\\)为矩阵的奇异值分解（即，SVD 分解）中求解右奇异向量的过程，其简要说明可参考附录一；\\(V_{j,k}\\)是由\\(H_{j,k}\\)的前\\(L\\)个右奇异向量构成的矩阵，\\(L\\)个之后的右奇异向量可以忽略，维度为\\(N \\times L\\)。\n\n进一步，为得到最终输出结果\\(W = \\{W_{j,k}\\}\\)，先将不同\\(j\\)下标、相同\\(k\\)下标的\\(V_{j,k}\\)进行横向的拼接，得到维度为\\(N \\times LJ\\)的\\(V_k = [V_{1,k} \\quad \\cdots \\quad V_{j,k} \\quad \\cdots \\quad V_{J,k}]\\)，然后根据如下公式获取\\(W_k\\)：\n\\[\nW_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}\n\\]\n其中，\\(\\sigma^2\\)为固定常数；\\(W_k\\)维度同\\(V_k\\)；\\(I\\)为单位矩阵，维度为\\(LJ \\times LJ\\)。\n\n最后，将各\\(W_k\\)按如下的公式进行拆解：\n\\[\nW_k = [W_{1,k}, \\ldots, W_{j,k}, \\ldots, W_{J,k}]\n\\]\n其中，\\(W_{j,k}\\)是\\(W_k\\)中顺序排列的子矩阵，维度为\\(N \\times L\\)。上述各流程亦可参考附录二中的图示说明。\n\n为了降低计算和储存的复杂度，分析相关矩阵组的关联性，通过数学建模对输出结果\\(W\\)进行估计，建模过程表示为：\n\\[\n\\widehat{W} = f(H)\n\\]\n其中\\(\\widehat{W}\\)即为对输出结果\\(W\\)的建模估计。这一建模过程又可以拆分为2个步骤：\n\\[\n\\widehat{V} = f_1(H), \\quad \\widehat{W} = f_2(\\widehat{V})\n\\]\n其中\\(f_1(\\cdot)\\)表示从输入矩阵组\\(H\\)到中间结果\\(V\\)的建模过程，\\(\\widehat{V}\\)表示中间结果\\(V\\)的建模估计，\\(f_2(\\cdot)\\)表示从中间结果\\(V\\)到最终结果\\(W\\)的建模过程，\\(\\widehat{W}\\)表示最终结果\\(W\\)的建模估计。定义\\(W\\)的建模估计精度为：\n\\[\n\\rho_{l,j,k}(W) = \\frac{\\|\\widehat{W}_{l,j,k}^H W_{l,j,k}\\|_2}{\\|\\widehat{W}_{l,j,k}\\|_2 \\|W_{l,j,k}\\|_2}, l = 1, \\ldots, L\n\\]\n其中，\\(\\|\\cdot\\|_2\\)表示矢量的欧几里得范数（也即2范数，对于列矢量\\(a\\)，\\(\\|a\\|_2 = \\sqrt{a^H a}\\)）；\\(W_{l,j,k}\\)表示\\(W_{j,k}\\)的第\\(l\\)列。上式中，\\(\\widehat{W}_{l,j,k}^H W_{l,j,k}\\)为复数标量，此处取其欧几里得范数即获取其模值。\n\n为描述方便，额外定义 $W$ 的最低建模精度 $\\rho_{\\min}(W)$ 为：\n\\[\n\\rho_{\\min}(W) \\triangleq \\min_{l \\in \\{1,2,\\ldots,L\\}} \\min_{j \\in \\{1,2,\\ldots,n\\}} \\min_{k \\in \\{1,2,\\ldots,K\\}} \\rho_{l,j,k}(W)\n\\]\n其中，$\\min(\\cdot)$ 表示在 $l,j,k$ 三个维度上取最小值。另外，中间结果 $V$ 的建模估计精度 $\\rho_{l,j,k}(V)$ 的定义及最低建模精度 $\\rho_{\\min}(V)$ 的定义与此相同。\n\n下面对建模过程中涉及的 **计算复杂度、存储复杂度** 的定义进行说明：\n\n**计算复杂度** 定义为由矩阵组 $H$ 计算得到结果矩阵组 $W$ 所需要的总计算复杂度。复杂矩阵运算可拆解为基本的复杂运算，而基本的复杂运算又可进一步拆解为基本的实数运算。例如，复数乘法按照\n\\[\n(a+bj)(c+dj)=(ac-bd)+(ad+bc)j\n\\]\n计算的复杂度为 4 次实数乘法和 2 次实数加(减)法。实数基本运算的复杂度按照下表计算，其中，实数的加(减)法运算与乘法运算的计算复杂度对比如参考文献[1]。\n\n\\begin{table}[H]\n\\centering\n\\caption{实数基本运算的计算复杂度}\n\\begin{tabular}{|c|c|}\n\\hline\n运算类型 & 计算复杂度 \\\\\\ \n\\hline\n加(减)法 & $1^*$ \\\\\\ \n乘法 & $3^*$ \\\\\\ \n倒数 & $25^*$ \\\\\\ \n平方根 & $25^*$ \\\\\\ \n自然指数 & $25^*$ \\\\\\ \n自然对数 & $25^*$ \\\\\\ \n正弦 & $25^*$ \\\\\\ \n余弦 & $25^*$ \\\\\\ \n其它 & $100^*$ \\\\\\ \n\\hline\n\\end{tabular}\n\\end{table}\n\n如果使用常规的算法完成本问题中的运算流程，获取输出结果 $W=\\{W_{j,k}\\}$ 的计算复杂度由如下几个部分构成：\n\n- 求解右奇异向量过程中的计算复杂度。当使用文献[2]中使用的方法时，基于双对角化(bi-diagonalization)结合QR分解的操作，对于SVD分解本身可以达到近似 $O(NM^2+M^3)$ 的复杂度，其主要流程可参考附录三。\n\n- 获取逆矩阵 $(V_k^H V_k + \\sigma^2 I)^{-1}$ 过程中 的计算复杂度。当使用高斯消元法时，求解维度 $L \\times L$ 的矩阵的逆矩阵的复杂度近似为 $O((L l)^3)$；当矩阵求逆过程中使用的矩阵乘法使用文献[3]中的 Strassen’s 方法时，可以将上述复杂度降低到 $O((L l)^{2.807})$；进一步地，当求逆过程结合了文献[4]中提出的 Coppersmith–Winograd 方法时，理论上可以将上述复杂度降低到 $O((L l)^{2.376})$，对此部分的说明可参考附录四；\n\n- 求解各个 $W_k$ 过程中 的矩阵乘法的计算复杂度。请注意，将 $W_k$ 拆解为若干子矩阵的过程中并不涉及计算复杂度，一般认为可以通过 $W_k$ 直接获取 $W_{j,k}$。\n\n如果使用以上方法，当矩阵组 \\(H = \\{H_{j,k}\\}\\) 的维度，或者，矩阵组内各个矩阵 \\(H_{j,k}\\) 的维度继续提升时，整个系统将承受愈发巨大的计算负担。为此，需要通过恰当的建模方法，使得在近似获得输出结果的同时明显地降低计算复杂度。\n\n在本题目中，利用相关矩阵组的关联性降低计算复杂度可以从如下基础方向（或你认为其他更合适的方向）中的一个或者多个方向切入完成建模题目：\n\n1) 利用矩阵组 \\(H\\) 内部各个矩阵间的关联性，减少前述一组数学运算的整体计算复杂度。例如，矩阵组 \\(H\\) 中包括存在关联性的 5 个矩阵 \\(\\{H_{j,1}, H_{j,2}, H_{j,3}, H_{j,4}, H_{j,5}\\}\\)，部分情况下可以仅针对 \\(H_{j,1}, H_{j,3}, H_{j,5}\\) 进行相应的运算过程并获取 \\(\\widehat{W}_{j,1}, \\widehat{W}_{j,3}, \\widehat{W}_{j,5}\\)，然后通过恰当的插值操作获取 \\(\\widehat{W}_{j,2}\\) 和 \\(\\widehat{W}_{j,4}\\)，使得 \\(\\rho_{l,j,k}(W)\\) 均满足前述建模估计精度的需求。\n\n2) 利用矩阵 \\(H_{j,k}\\) 内部各个矩阵元素间的关联性，降低奇异值分解过程、矩阵求逆过程的计算复杂度。关于奇异值分解的低计算复杂度实现，方法不做限定。例如，可以参考文献 [5] 中提出的随机奇异值分解 (Randomized SVD) 方法，其简要实现过程可以参考网页 [6]，部分摘录于附录五。\n\n3) 针对计算流程进行合理的构造和转化，避免执行相对复杂的矩阵运算步骤。例如，矩阵求逆的计算复杂度较高，而本问题的最终需求为 \\(W_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}\\)，如果将该步骤转化为 \\((V_k^H V_k + \\sigma^2 I) W_k^H = V_k^H\\) 形式来求解 \\(W_k\\)，则潜在地可以降低整体计算流程的计算复杂度。4) 请注意，在完成本问题时，推荐根据上述表格给出更细化的计算复杂度评估。例如，统计建模过程中复数乘法的使用次数、复数加法的使用次数等，然后分别与复数乘法的计算复杂度（可以为 14）及复数加法的计算复杂度（可以为 2）相乘，累加后得到总体计算复杂度。\n\n存储复杂度定义为矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 占用的存储空间的大小，以比特为单位计算。对于复数矩阵中单个复数元素，其实部和虚部均采用 32 比特单精度浮点表示。因此，整个矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 占用的存储空间分别为 \\(64MNJK\\) 比特和 \\(64NLJK\\) 比特。\n\n为了节省存储开销，考虑对 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 分别进行压缩。独立设计 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 的压缩函数 \\(P_1(\\cdot)\\) 和 \\(P_2(\\cdot)\\)，对压缩后的数据 \\(P_1(\\boldsymbol{H})\\) 和 \\(P_2(\\boldsymbol{W})\\) 进行存储。压缩函数的设计请主要考虑挖掘并利用矩阵内部或矩阵间的关联性，或者，矩阵表达的稀疏性；思路可参考但不限于图像的变换域压缩算法或视频的帧间压缩算法。压缩后的每个元素仍然以 32bit 单精度浮点数存储，不考虑位宽的压缩。\n\n\\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 以压缩的形式存储在存储器中。在进行处理之前，需要从存储器中读出 \\(P_1(\\boldsymbol{H})\\) 和 \\(P_2(\\boldsymbol{W})\\) 进行解压缩处理：\n\\[\n\\widehat{\\boldsymbol{H}} = G_1\\big(P_1(\\boldsymbol{H})\\big), \\ \\widehat{\\boldsymbol{W}} = G_2\\big(P_2(\\boldsymbol{W})\\big)\n\\]\n其中，\\(G_1(\\cdot)\\) 和 \\(G_2(\\cdot)\\) 分别表示矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 的解压缩函数。经过压缩和解压缩之后得到的 \\(\\widehat{\\boldsymbol{H}}\\) 和 \\(\\widehat{\\boldsymbol{W}}\\) 与原始的 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 存在误差，定义为\n\\[\nerr_H = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{H}}_{j,k} - \\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}, \\ err_W = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{W}}_{j,k} - \\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}\n\\]\n其中，\\(\\|\\cdot\\|_F\\) 表示矩阵的 Frobenius 范数；\\(E\\{\\cdot\\}\\) 表示求期望运算，即在所提供矩阵组的所有矩阵求平均。注意：标准输出矩阵组 \\(\\boldsymbol{W}\\) 是 0 相位，即其中矩阵 \\(\\boldsymbol{W}_{j,k}\\) 的每个列向量的首个元素是 0 相位复数（实数）。若建模得到的 \\(\\widehat{\\boldsymbol{W}}_{j,k}\\) 带有随机初始相位，可增加一步相位拉齐处理，将 \\(\\widehat{\\boldsymbol{W}}_{j,k}\\) 拉齐到与 \\(\\boldsymbol{W}_{j,k}\\) 相同的 0 相位，然后再计算误差。\n\n综上所述，相关矩阵组的整体处理流程如下图所示。\n\n\\begin{tikzpicture}[node distance=2cm, auto, thick, main/.style = {draw, rectangle, minimum size=2cm}]\n    \\node[main] (input) {$\\boldsymbol{H} = \\{\\boldsymbol{H}_{j,k}\\}$};\n    \\node[main, right of=input] (compress1) {存储单元};\n    \\node[main, right of=compress1] (decompress1) {计算单元};\n    \\node[main, right of=decompress1] (compress2) {存储单元};\n    \\node[main, right of=compress2] (decompress2) {$\\widehat{\\boldsymbol{W}} = \\{\\widehat{\\boldsymbol{W}}_{j,k}\\}$};\n    \n    \\draw[->] (input) -- node[above] {$P_1(\\cdot)$} (compress1);\n    \\draw[->] (compress1) -- node[above] {$G_1(\\cdot)$} (decompress1);\n    \\draw[->] (decompress1) -- node[above] {$P_2(\\cdot)$} (compress2);\n    \\draw[->] (compress2) -- node[above] {$G_2(\\cdot)$} (decompress2);\n    \n    \\node[above of=compress1, node distance=1cm] {压缩};\n    \\node[above of=decompress1, node distance=1cm] {解压缩};\n    \\node[above of=compress2, node distance=1cm] {压缩};\n    \\node[above of=decompress2, node distance=1cm] {解压缩};\n    \n    \\node[below of=decompress1, node distance=1cm] {$\\widehat{\\boldsymbol{W}} = f(\\boldsymbol{H})$};\n\\end{tikzpicture}\n\n三、建模问题\n\n输入矩阵组 $\\mathbf{H}$、标准中间矩阵组 $\\mathbf{V}$ 和标准输出矩阵组 $\\mathbf{W}$ 的数据及其维度如下，数据采用十进制格式：\n\n\\begin{itemize}\n    \\item 第一组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第二组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第三组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第四组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第五组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第六组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n\\end{itemize}\n\n附件中提供 .mat 及 .csv 文件格式的数据，按需使用其中的一种文件格式即可。\n\n请基于以上提供的数据，采用适当的方法，解决以下相关矩阵组的低复杂度计算和存储建模问题。注意，提交结果及论文需要完成以下问题 1、问题 2 中的至少一题，同时完成两题将适当加分。问题 3 为开放式问题，不作为必选，但鼓励尝试，有新意的算法模型设计将得到加分。\n\n在完成以下问题时，仅需考虑各个问题本身申明的建模需求，不需要考虑其他问题产生的建模需求。例如，在完成问题 3 时，不需要额外考虑问题 1 中 $\\rho_{\\min}(V)$ 的建模估计精度需求。\\section*{问题1：相关矩阵组的低复杂度计算}\n\n1) 基于给定的所有矩阵数据 $H$，分析其数据间的关联性，设计相应的近似分析模型 $\\bar{V} = f_1(H)$，在满足 $\\rho_{\\min}(\\bar{V}) \\geq \\rho_{th} = 0.99$ 的情况下，使得根据表格计算的总计算复杂度最低。\n\\begin{itemize}\n\\item 注1：在本问题中，暂不考虑矩阵数据 $H$ 的压缩与解压缩。\n\\item 注2：参考下述 2)，当采用直接设计分析模型 $W = f(H)$ 的方式时，1) 可以跳过不做。\n\\end{itemize}\n\n2) 基于给定的所有矩阵数据 $H$，分析其数据间的关联性，综合设计相应的近似分析模型 $W = f(H)$，在满足 $\\rho_{\\min}(W) \\geq \\rho_{th} = 0.99$ 的情况下，使得根据表格计算的总计算复杂度最低。\n\\begin{itemize}\n\\item 注1：在本问题中，暂不考虑矩阵数据 $H$ 的压缩与解压缩。\n\\item 注2：在本问题中，可以：\n  \\begin{itemize}\n  \\item 在 1) 的基础上考虑 $W = f_2(\\bar{V})$，因此 $W = f(H) = f_2(f_1(H))$；或者，\n  \\item 不需考虑中间结果 $\\bar{V}$，直接设计分析模型 $W = f(H)$，此时 1) 可以跳过不做。\n  \\end{itemize}\n\\item 注3：如果使用常规数学方法，则考虑矩阵所有运算过程涉及的计算复杂度；如果使用人工智能方法，则优先考虑推理阶段的计算复杂度，但需要充分考虑泛化性。\n\\end{itemize}\n\n\\section*{问题2：相关矩阵组的低复杂度存储}\n\n基于给定的所有矩阵数据 $H$ 和 $W$，分析各自数据间的关联性，分别设计相应的压缩 $P_1(\\cdot)$, $P_2(\\cdot)$ 和解压缩 $G_1(\\cdot)$, $G_2(\\cdot)$ 模型，在满足误差 $err_W \\leq E_{th1} = -30 \\,\\text{dB}$, $err_H \\leq E_{th2} = -30 \\,\\text{dB}$ 的情况下，使得存储复杂度和压缩与解压缩的计算复杂度最低，复杂度计算同问题1。\n\\begin{itemize}\n\\item 注1：压缩与解压缩函数的设计方法不做限定。\n\\item 注2：计算复杂度考虑压缩和解压缩函数的所有运算过程。\n\\item 注3：在本问题中，暂不考虑分析模型 $W = f(H)$ 对输出矩阵组 $W$ 的影响。\n\\item 注4：两个建模优化目标（存储复杂度，压缩与解压缩的计算复杂度）的优先级相同。\n\\end{itemize}\n\n\\section*{问题3：相关矩阵组的低复杂度计算和存储}\n\n基于给定的所有矩阵数据 $H$，分析其数据间的关联性，在满足 $\\rho_{\\min}(W) \\geq \\rho_{th} = 0.99$ 的情况下，设计低复杂度计算和存储的整体方案，完成从矩阵输入信号 $H$ 到近似矩阵输出信号 $W$ 的端到端流程。\n\\begin{itemize}\n\\item 注1：在本问题中，可以考虑从矩阵输入信号 $H$ 到近似矩阵输出信号 $W$ 为一个整体流程，而非依次经过“压缩/解压缩、计算单元、压缩/解压缩”的过程。\n\\item 注2：如果使用人工智能方法，需要考虑人工智能模型的存储复杂度以及推理阶段的计算复杂度。\n\\end{itemize}\nAddendum: \n如果使用以上方法，当矩阵组 $H = \\{H_{j,k}\\}$ 的维度，或者，矩阵组内各个矩阵 $H_{j,k}$ 的维度继续提升时，整个系统将承受愈发巨大的计算负担。为此，需要通过恰当的建模方法，使得在近似获得输出结果的同时明显地降低计算复杂度。\n\n在本题目中，利用相关矩阵组的关联性降低计算复杂度可以从如下基础方向（或你认为其他更合适的方向）中的一个或者多个方向切入完成建模题目：\n\n1) 利用矩阵组 $H$ 内部各个矩阵间的关联性，减少前述一组数学运算的整体计算复杂度。例如，矩阵组 $H$ 中包括存在关联性的 5 个矩阵 $\\{H_{j,1}, H_{j,2}, H_{j,3}, H_{j,4}, H_{j,5}\\}$，部分情况下可以仅针对 $H_{j,1}, H_{j,3}, H_{j,5}$ 进行相应的运算过程并获取 $\\widehat{W}_{j,1}, \\widehat{W}_{j,3}, \\widehat{W}_{j,5}$，然后通过恰当的插值操作获取 $\\widehat{W}_{j,2}$ 和 $\\widehat{W}_{j,4}$，使得 $\\rho_{l,j,k}(W)$ 均满足前述建模估计精度的需求。\n\n2) 利用矩阵 $H_{j,k}$ 内部各个矩阵元素间的关联性，降低奇异值分解过程、矩阵求逆过程的计算复杂度。关于奇异值分解的低计算复杂度实现，方法不做限定。例如，可以参考文献 [5] 中提出的随机奇异值分解 (Randomized SVD) 方法，其简要实现过程可以参考网页 [6]，部分摘录于附录五。\n\n3) 针对计算流程进行合理的构造和转化，避免执行相对复杂的矩阵运算步骤。例如，矩阵求逆的计算复杂度较高，而本问题的最终需求为 $W_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}$，如果将该步骤转化为 $(V_k^H V_k + \\sigma^2 I) W_k^H = V_k^H$ 形式来求解 $W_k$，则潜在地可以降低整体计算流程的计算复杂度。4) 请注意，在完成本问题时，推荐根据上述表格给出更细化的计算复杂度评估。例如，统计建模过程中复数乘法的使用次数、复数加法的使用次数等，然后分别与复数乘法的计算复杂度（可以为 14）及复数加法的计算复杂度（可以为 2）相乘，累加后得到总体计算复杂度。\n\n存储复杂度定义为矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 占用的存储空间的大小，以比特为单位计算。对于复数矩阵中单个复数元素，其实部和虚部均采用 32 比特单精度浮点表示。因此，整个矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 占用的存储空间分别为 $64MNJK$ 比特和 $64NLJK$ 比特。\n\n为了节省存储开销，考虑对 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 分别进行压缩。独立设计 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 的压缩函数 $P_1(\\cdot)$ 和 $P_2(\\cdot)$，对压缩后的数据 $P_1(\\boldsymbol{H})$ 和 $P_2(\\boldsymbol{W})$ 进行存储。压缩函数的设计请主要考虑挖掘并利用矩阵内部或矩阵间的关联性，或者，矩阵表达的稀疏性；思路可参考但不限于图像的变换域压缩算法或视频的帧间压缩算法。压缩后的每个元素仍然以 32bit 单精度浮点数存储，不考虑位宽的压缩。\n\n$\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 以压缩的形式存储在存储器中。在进行处理之前，需要从存储器中读出 $P_1(\\boldsymbol{H})$ 和 $P_2(\\boldsymbol{W})$ 进行解压缩处理：\n\\[\n\\widehat{\\boldsymbol{H}} = G_1\\big(P_1(\\boldsymbol{H})\\big), \\ \\widehat{\\boldsymbol{W}} = G_2\\big(P_2(\\boldsymbol{W})\\big)\n\\]\n其中，$G_1(\\cdot)$ 和 $G_2(\\cdot)$ 分别表示矩阵组 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 的解压缩函数。经过压缩和解压缩之后得到的 $\\widehat{\\boldsymbol{H}}$ 和 $\\widehat{\\boldsymbol{W}}$ 与原始的 $\\boldsymbol{H}$ 和 $\\boldsymbol{W}$ 存在误差，定义为\n\\[\nerr_H = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{H}}_{j,k} - \\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}, \\ err_W = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{W}}_{j,k} - \\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}\n\\]\n其中，$\\|\\cdot\\|_F$ 表示矩阵的 Frobenius 范数；$E\\{\\cdot\\}$ 表示求期望运算，即在所提供矩阵组的所有矩阵求平均。注意：标准输出矩阵组 $\\boldsymbol{W}$ 是 0 相位，即其中矩阵 $\\boldsymbol{W}_{j,k}$ 的每个列向量的首个元素是 0 相位复数（实数）。若建模得到的 $\\widehat{\\boldsymbol{W}}_{j,k}$ 带有随机初始相位，可增加一步相位拉齐处理，将 $\\widehat{\\boldsymbol{W}}_{j,k}$ 拉齐到与 $\\boldsymbol{W}_{j,k}$ 相同的 0 相位，然后再计算误差。\n\n综上所述，相关矩阵组的整体处理流程如下图所示。\n\n\\begin{tikzpicture}[node distance=2cm, auto, thick, main/.style = {draw, rectangle, minimum size=2cm}]\n    \\node[main] (input) {$\\boldsymbol{H} = \\{\\boldsymbol{H}_{j,k}\\}$};\n    \\node[main, right of=input] (compress1) {存储单元};\n    \\node[main, right of=compress1] (decompress1) {计算单元};\n    \\node[main, right of=decompress1] (compress2) {存储单元};\n    \\node[main, right of=compress2] (decompress2) {$\\widehat{\\boldsymbol{W}} = \\{\\widehat{\\boldsymbol{W}}_{j,k}\\}$};\n    \n    \\draw[->] (input) -- node[above] {$P_1(\\cdot)$} (compress1);\n    \\draw[->] (compress1) -- node[above] {$G_1(\\cdot)$} (decompress1);\n    \\draw[->] (decompress1) -- node[above] {$P_2(\\cdot)$} (compress2);\n    \\draw[->] (compress2) -- node[above] {$G_2(\\cdot)$} (decompress2);\n    \n    \\node[above of=compress1, node distance=1cm] {压缩};\n    \\node[above of=decompress1, node distance=1cm] {解压缩};\n    \\node[above of=compress2, node distance=1cm] {压缩};\n    \\node[above of=decompress2, node distance=1cm] {解压缩};\n    \n    \\node[below of=decompress1, node distance=1cm] {$\\widehat{\\boldsymbol{W}} = f(\\boldsymbol{H})$};\n\\end{tikzpicture}\n\n请基于以上提供的数据，采用适当的方法，解决以下相关矩阵组的低复杂度计算和存储建模问题。注意，提交结果及论文需要完成以下问题 1、问题 2 中的至少一题，同时完成两题将适当加分。问题 3 为开放式问题，不作为必选，但鼓励尝试，有新意的算法模型设计将得到加分。\n\n在完成以下问题时，仅需考虑各个问题本身申明的建模需求，不需要考虑其他问题产生的建模需求。例如，在完成问题 3 时，不需要额外考虑问题 1 中 $\\rho_{\\min}(V)$ 的建模估计精度需求。参考文献\nSwartzlander, Earl E., and Hani H. Saleh. \"Floating-point implementation of complex multiplication.\" 2009 Conference Record of the Forty-Third Asilomar Conference on Signals, Systems and Computers. IEEE, 2009.\nGolub, Gene, and William Kahan. \"Calculating the singular values and pseudo-inverse of a matrix.\" Journal of the Society for Industrial and Applied Mathematics, Series B: Numerical Analysis 2.2 (1965): 205-224.\nStrassen, Volker. \"Gaussian elimination is not optimal.\" Numerische mathematik 13.4 (1969): 354-356.\nCoppersmith, Don, and Shmuel Winograd. \"Matrix multiplication via arithmetic progressions.\" Proceedings of the nineteenth annual ACM symposium on Theory of computing. 1987.\nHalko, Nathan, Per-Gunnar Martinsson, and Joel A. Tropp. \"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions.\" SIAM review 53.2 (2011): 217-288.\n网址：https://gregorygundersen.com/blog/2019/01/17/randomized-svd/\nDataset Path:\n['Data1_H.csv', 'Data1_H.mat', 'Data1_V.csv', 'Data1_V.mat', 'Data1_W.csv', 'Data1_W.mat', 'Data2_H.csv', 'Data2_H.mat', 'Data2_V.csv', 'Data2_V.mat', 'Data2_W.csv', 'Data2_W.mat', 'Data3_H.csv', 'Data3_H.mat', 'Data3_V.csv', 'Data3_V.mat', 'Data3_W.csv', 'Data3_W.mat', 'Data4_H.csv', 'Data4_H.mat', 'Data4_V.csv', 'Data4_V.mat', 'Data4_W.csv', 'Data4_W.mat', 'Data5_H.csv', 'Data5_H.mat', 'Data5_V.csv', 'Data5_V.mat', 'Data5_W.csv', 'Data5_W.mat', 'Data6_H.csv', 'Data6_H.mat', 'Data6_V.csv', 'Data6_V.mat', 'Data6_W.csv', 'Data6_W.mat', 'Readme.txt', '附录.docx']\n\nData Description:\n该数据集由多组以CSV（部分为.mat）格式存储的复数矩阵文件构成（主要文件名为Data1_H/V/W … Data6_H/V/W、Data5_H.mat、Readme.txt及附录.docx），每个矩阵元素均为复数形式（实部+虚部i，部分数值显示极小虚部如e-17），CSV文件中复数元素以逗号分隔、矩阵按行/块排列并以换行分隔，整体按约定的多维张量顺序存储：H 集合的理论维度为 M×N×J×K（示例给定 M=4、N=64、J=4、K=384），V 和 W 的维度为 N×L×J×K（示例 L=2），且CSV行通常对应 N 维度、列按{M, J, K}或{L, J, K}顺序排放；各 Data*_H/V/W 文件分别包含不同场景下的复数矩阵集合，元素数值分布多为小幅正负浮点数（示例值如0.059197+0.1187i、-0.06006+0.04340i等），部分 W 文件列字段非常多（如 Data4_W 列举至上百个元素字段），Data5_H 被提供为 .mat 文件但其中的 W 读取失败并记录为无法解析。数据描述反复强调矩阵之间存在结构性相关性，尤其是在同一“行块”内部的 K 个矩阵之间具有显著相关性（不同行块之间通常不考虑相关性），因此适合用于信号处理与通信系统领域的矩阵相关性分析、降维与分解任务；附录.docx 提供了关于奇异值分解（SVD）的理论与实现细节（含双对角化+QR、基于随机SVD的近似方法及降低矩阵乘法复杂度的策略），Readme.txt 则说明了文件的存储格式与维度约定，便于按上述多维索引重构原始矩阵张量并用于后续的矩阵分解、统计分析或模型验证。"
  },
  "problem_background": "计算机视觉、相控阵雷达、声呐、射电天文、无线通信等领域的信号通常呈现为矩阵的形式，这一系列的矩阵间通常在某些维度存在一定的关联性，因此数学上可用相关矩阵组表示。例如，视频信号中的单帧图像可视为一个矩阵，连续的多帧图像组成了相关矩阵组，而相邻图像帧或图像帧内像素间的关联性则反映在矩阵间的相关性上。随着成像传感器数量/雷达阵列/通信阵列的持续扩大，常规处理算法对计算和存储的需求成倍增长，从而对处理器件或算法的实现成本和功耗提出了巨大的挑战。因此，充分挖掘矩阵间关联性，以实现低复杂度的计算和存储，具有十分重要的价值和意义。",
  "problem_requirement": "给定一组复数矩阵 $H = \\{H_{j,k}\\}$，$H_{j,k} \\in \\mathbb{C}^{M \\times N}, j = 1, \\ldots, J, k = 1, \\ldots, K$。其中，矩阵之间以及同一矩阵的元素之间有一定的相关性，包括：相同 $j$ 下标、不同 $k$ 下标的矩阵间存在一定的关联，即 $\\{H_{j,1}, H_{j,2}, H_{j,3}, \\ldots, H_{j,K}\\}$ 间存在关联\\footnote{在本问题中，仅考虑同一行块内部的 $K$ 个矩阵间的相关性，不考虑矩阵组 $H$ 中属于不同行块的矩阵（即，不同 $j$ 下标的矩阵）间的相关性。}；且矩阵\n\n\\[\nH_{j,k} = \\begin{bmatrix}\n h_{1,1}^{(j,k)} & h_{1,2}^{(j,k)} & h_{1,3}^{(j,k)} & \\cdots & h_{1,N}^{(j,k)} \\\n h_{2,1}^{(j,k)} & h_{2,2}^{(j,k)} & h_{2,3}^{(j,k)} & \\cdots & h_{2,N}^{(j,k)} \\\n \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\n h_{M,1}^{(j,k)} & h_{M,2}^{(j,k)} & h_{M,3}^{(j,k)} & \\cdots & h_{M,N}^{(j,k)}\n\\end{bmatrix}\n\\]\n\n的各个元素间 $\\{h_{m,n}^{(j,k)}\\}, m = 1, \\ldots, M, n = 1, \\ldots, N$，也存在关联。\n\n定义矩阵组 $H = \\{H_{j,k}\\}$ 上的一组数学运算，其中间结果 $V = \\{V_{j,k}\\}$ 由如下的公式给出：\n\n\\[\nV_{j,k} = svd\\big(H_{j,k}\\big), \\text{or } H_{j,k} = U_{j,k} S_{j,k} \\widetilde{V}_{j,k}^H, V_{j,k} = \\widetilde{V}_{j,k}^H(:,1:L)\n\\]\n\n\\[\nj = 1, \\ldots, J; \\, k = 1, \\ldots, K\n\\]其中，\\(svd(\\cdot)\\)为矩阵的奇异值分解（即，SVD 分解）中求解右奇异向量的过程，其简要说明可参考附录一；\\(V_{j,k}\\)是由\\(H_{j,k}\\)的前\\(L\\)个右奇异向量构成的矩阵，\\(L\\)个之后的右奇异向量可以忽略，维度为\\(N \\times L\\)。\n\n进一步，为得到最终输出结果\\(W = \\{W_{j,k}\\}\\)，先将不同\\(j\\)下标、相同\\(k\\)下标的\\(V_{j,k}\\)进行横向的拼接，得到维度为\\(N \\times LJ\\)的\\(V_k = [V_{1,k} \\quad \\cdots \\quad V_{j,k} \\quad \\cdots \\quad V_{J,k}]\\)，然后根据如下公式获取\\(W_k\\)：\n\\[\nW_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}\n\\]\n其中，\\(\\sigma^2\\)为固定常数；\\(W_k\\)维度同\\(V_k\\)；\\(I\\)为单位矩阵，维度为\\(LJ \\times LJ\\)。\n\n最后，将各\\(W_k\\)按如下的公式进行拆解：\n\\[\nW_k = [W_{1,k}, \\ldots, W_{j,k}, \\ldots, W_{J,k}]\n\\]\n其中，\\(W_{j,k}\\)是\\(W_k\\)中顺序排列的子矩阵，维度为\\(N \\times L\\)。上述各流程亦可参考附录二中的图示说明。\n\n为了降低计算和储存的复杂度，分析相关矩阵组的关联性，通过数学建模对输出结果\\(W\\)进行估计，建模过程表示为：\n\\[\n\\widehat{W} = f(H)\n\\]\n其中\\(\\widehat{W}\\)即为对输出结果\\(W\\)的建模估计。这一建模过程又可以拆分为2个步骤：\n\\[\n\\widehat{V} = f_1(H), \\quad \\widehat{W} = f_2(\\widehat{V})\n\\]\n其中\\(f_1(\\cdot)\\)表示从输入矩阵组\\(H\\)到中间结果\\(V\\)的建模过程，\\(\\widehat{V}\\)表示中间结果\\(V\\)的建模估计，\\(f_2(\\cdot)\\)表示从中间结果\\(V\\)到最终结果\\(W\\)的建模过程，\\(\\widehat{W}\\)表示最终结果\\(W\\)的建模估计。定义\\(W\\)的建模估计精度为：\n\\[\n\\rho_{l,j,k}(W) = \\frac{\\|\\widehat{W}_{l,j,k}^H W_{l,j,k}\\|_2}{\\|\\widehat{W}_{l,j,k}\\|_2 \\|W_{l,j,k}\\|_2}, l = 1, \\ldots, L\n\\]\n其中，\\(\\|\\cdot\\|_2\\)表示矢量的欧几里得范数（也即2范数，对于列矢量\\(a\\)，\\(\\|a\\|_2 = \\sqrt{a^H a}\\)）；\\(W_{l,j,k}\\)表示\\(W_{j,k}\\)的第\\(l\\)列。上式中，\\(\\widehat{W}_{l,j,k}^H W_{l,j,k}\\)为复数标量，此处取其欧几里得范数即获取其模值。\n\n为描述方便，额外定义 $W$ 的最低建模精度 $\\rho_{\\min}(W)$ 为：\n\\[\n\\rho_{\\min}(W) \\triangleq \\min_{l \\in \\{1,2,\\ldots,L\\}} \\min_{j \\in \\{1,2,\\ldots,n\\}} \\min_{k \\in \\{1,2,\\ldots,K\\}} \\rho_{l,j,k}(W)\n\\]\n其中，$\\min(\\cdot)$ 表示在 $l,j,k$ 三个维度上取最小值。另外，中间结果 $V$ 的建模估计精度 $\\rho_{l,j,k}(V)$ 的定义及最低建模精度 $\\rho_{\\min}(V)$ 的定义与此相同。\n\n下面对建模过程中涉及的 **计算复杂度、存储复杂度** 的定义进行说明：\n\n**计算复杂度** 定义为由矩阵组 $H$ 计算得到结果矩阵组 $W$ 所需要的总计算复杂度。复杂矩阵运算可拆解为基本的复杂运算，而基本的复杂运算又可进一步拆解为基本的实数运算。例如，复数乘法按照\n\\[\n(a+bj)(c+dj)=(ac-bd)+(ad+bc)j\n\\]\n计算的复杂度为 4 次实数乘法和 2 次实数加(减)法。实数基本运算的复杂度按照下表计算，其中，实数的加(减)法运算与乘法运算的计算复杂度对比如参考文献[1]。\n\n\\begin{table}[H]\n\\centering\n\\caption{实数基本运算的计算复杂度}\n\\begin{tabular}{|c|c|}\n\\hline\n运算类型 & 计算复杂度 \\\\\\ \n\\hline\n加(减)法 & $1^*$ \\\\\\ \n乘法 & $3^*$ \\\\\\ \n倒数 & $25^*$ \\\\\\ \n平方根 & $25^*$ \\\\\\ \n自然指数 & $25^*$ \\\\\\ \n自然对数 & $25^*$ \\\\\\ \n正弦 & $25^*$ \\\\\\ \n余弦 & $25^*$ \\\\\\ \n其它 & $100^*$ \\\\\\ \n\\hline\n\\end{tabular}\n\\end{table}\n\n如果使用常规的算法完成本问题中的运算流程，获取输出结果 $W=\\{W_{j,k}\\}$ 的计算复杂度由如下几个部分构成：\n\n- 求解右奇异向量过程中的计算复杂度。当使用文献[2]中使用的方法时，基于双对角化(bi-diagonalization)结合QR分解的操作，对于SVD分解本身可以达到近似 $O(NM^2+M^3)$ 的复杂度，其主要流程可参考附录三。\n\n- 获取逆矩阵 $(V_k^H V_k + \\sigma^2 I)^{-1}$ 过程中 的计算复杂度。当使用高斯消元法时，求解维度 $L \\times L$ 的矩阵的逆矩阵的复杂度近似为 $O((L l)^3)$；当矩阵求逆过程中使用的矩阵乘法使用文献[3]中的 Strassen’s 方法时，可以将上述复杂度降低到 $O((L l)^{2.807})$；进一步地，当求逆过程结合了文献[4]中提出的 Coppersmith–Winograd 方法时，理论上可以将上述复杂度降低到 $O((L l)^{2.376})$，对此部分的说明可参考附录四；\n\n- 求解各个 $W_k$ 过程中 的矩阵乘法的计算复杂度。请注意，将 $W_k$ 拆解为若干子矩阵的过程中并不涉及计算复杂度，一般认为可以通过 $W_k$ 直接获取 $W_{j,k}$。\n\n如果使用以上方法，当矩阵组 \\(H = \\{H_{j,k}\\}\\) 的维度，或者，矩阵组内各个矩阵 \\(H_{j,k}\\) 的维度继续提升时，整个系统将承受愈发巨大的计算负担。为此，需要通过恰当的建模方法，使得在近似获得输出结果的同时明显地降低计算复杂度。\n\n在本题目中，利用相关矩阵组的关联性降低计算复杂度可以从如下基础方向（或你认为其他更合适的方向）中的一个或者多个方向切入完成建模题目：\n\n1) 利用矩阵组 \\(H\\) 内部各个矩阵间的关联性，减少前述一组数学运算的整体计算复杂度。例如，矩阵组 \\(H\\) 中包括存在关联性的 5 个矩阵 \\(\\{H_{j,1}, H_{j,2}, H_{j,3}, H_{j,4}, H_{j,5}\\}\\)，部分情况下可以仅针对 \\(H_{j,1}, H_{j,3}, H_{j,5}\\) 进行相应的运算过程并获取 \\(\\widehat{W}_{j,1}, \\widehat{W}_{j,3}, \\widehat{W}_{j,5}\\)，然后通过恰当的插值操作获取 \\(\\widehat{W}_{j,2}\\) 和 \\(\\widehat{W}_{j,4}\\)，使得 \\(\\rho_{l,j,k}(W)\\) 均满足前述建模估计精度的需求。\n\n2) 利用矩阵 \\(H_{j,k}\\) 内部各个矩阵元素间的关联性，降低奇异值分解过程、矩阵求逆过程的计算复杂度。关于奇异值分解的低计算复杂度实现，方法不做限定。例如，可以参考文献 [5] 中提出的随机奇异值分解 (Randomized SVD) 方法，其简要实现过程可以参考网页 [6]，部分摘录于附录五。\n\n3) 针对计算流程进行合理的构造和转化，避免执行相对复杂的矩阵运算步骤。例如，矩阵求逆的计算复杂度较高，而本问题的最终需求为 \\(W_k = V_k (V_k^H V_k + \\sigma^2 I)^{-1}\\)，如果将该步骤转化为 \\((V_k^H V_k + \\sigma^2 I) W_k^H = V_k^H\\) 形式来求解 \\(W_k\\)，则潜在地可以降低整体计算流程的计算复杂度。4) 请注意，在完成本问题时，推荐根据上述表格给出更细化的计算复杂度评估。例如，统计建模过程中复数乘法的使用次数、复数加法的使用次数等，然后分别与复数乘法的计算复杂度（可以为 14）及复数加法的计算复杂度（可以为 2）相乘，累加后得到总体计算复杂度。\n\n存储复杂度定义为矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 占用的存储空间的大小，以比特为单位计算。对于复数矩阵中单个复数元素，其实部和虚部均采用 32 比特单精度浮点表示。因此，整个矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 占用的存储空间分别为 \\(64MNJK\\) 比特和 \\(64NLJK\\) 比特。\n\n为了节省存储开销，考虑对 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 分别进行压缩。独立设计 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 的压缩函数 \\(P_1(\\cdot)\\) 和 \\(P_2(\\cdot)\\)，对压缩后的数据 \\(P_1(\\boldsymbol{H})\\) 和 \\(P_2(\\boldsymbol{W})\\) 进行存储。压缩函数的设计请主要考虑挖掘并利用矩阵内部或矩阵间的关联性，或者，矩阵表达的稀疏性；思路可参考但不限于图像的变换域压缩算法或视频的帧间压缩算法。压缩后的每个元素仍然以 32bit 单精度浮点数存储，不考虑位宽的压缩。\n\n\\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 以压缩的形式存储在存储器中。在进行处理之前，需要从存储器中读出 \\(P_1(\\boldsymbol{H})\\) 和 \\(P_2(\\boldsymbol{W})\\) 进行解压缩处理：\n\\[\n\\widehat{\\boldsymbol{H}} = G_1\\big(P_1(\\boldsymbol{H})\\big), \\ \\widehat{\\boldsymbol{W}} = G_2\\big(P_2(\\boldsymbol{W})\\big)\n\\]\n其中，\\(G_1(\\cdot)\\) 和 \\(G_2(\\cdot)\\) 分别表示矩阵组 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 的解压缩函数。经过压缩和解压缩之后得到的 \\(\\widehat{\\boldsymbol{H}}\\) 和 \\(\\widehat{\\boldsymbol{W}}\\) 与原始的 \\(\\boldsymbol{H}\\) 和 \\(\\boldsymbol{W}\\) 存在误差，定义为\n\\[\nerr_H = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{H}}_{j,k} - \\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{H}_{j,k}\\|_F^2\\right\\}}, \\ err_W = 10 * \\log_{10} \\frac{E\\left\\{\\|\\widehat{\\boldsymbol{W}}_{j,k} - \\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}{E\\left\\{\\|\\boldsymbol{W}_{j,k}\\|_F^2\\right\\}}\n\\]\n其中，\\(\\|\\cdot\\|_F\\) 表示矩阵的 Frobenius 范数；\\(E\\{\\cdot\\}\\) 表示求期望运算，即在所提供矩阵组的所有矩阵求平均。注意：标准输出矩阵组 \\(\\boldsymbol{W}\\) 是 0 相位，即其中矩阵 \\(\\boldsymbol{W}_{j,k}\\) 的每个列向量的首个元素是 0 相位复数（实数）。若建模得到的 \\(\\widehat{\\boldsymbol{W}}_{j,k}\\) 带有随机初始相位，可增加一步相位拉齐处理，将 \\(\\widehat{\\boldsymbol{W}}_{j,k}\\) 拉齐到与 \\(\\boldsymbol{W}_{j,k}\\) 相同的 0 相位，然后再计算误差。\n\n综上所述，相关矩阵组的整体处理流程如下图所示。\n\n\\begin{tikzpicture}[node distance=2cm, auto, thick, main/.style = {draw, rectangle, minimum size=2cm}]\n    \\node[main] (input) {$\\boldsymbol{H} = \\{\\boldsymbol{H}_{j,k}\\}$};\n    \\node[main, right of=input] (compress1) {存储单元};\n    \\node[main, right of=compress1] (decompress1) {计算单元};\n    \\node[main, right of=decompress1] (compress2) {存储单元};\n    \\node[main, right of=compress2] (decompress2) {$\\widehat{\\boldsymbol{W}} = \\{\\widehat{\\boldsymbol{W}}_{j,k}\\}$};\n    \n    \\draw[->] (input) -- node[above] {$P_1(\\cdot)$} (compress1);\n    \\draw[->] (compress1) -- node[above] {$G_1(\\cdot)$} (decompress1);\n    \\draw[->] (decompress1) -- node[above] {$P_2(\\cdot)$} (compress2);\n    \\draw[->] (compress2) -- node[above] {$G_2(\\cdot)$} (decompress2);\n    \n    \\node[above of=compress1, node distance=1cm] {压缩};\n    \\node[above of=decompress1, node distance=1cm] {解压缩};\n    \\node[above of=compress2, node distance=1cm] {压缩};\n    \\node[above of=decompress2, node distance=1cm] {解压缩};\n    \n    \\node[below of=decompress1, node distance=1cm] {$\\widehat{\\boldsymbol{W}} = f(\\boldsymbol{H})$};\n\\end{tikzpicture}\n\n三、建模问题\n\n输入矩阵组 $\\mathbf{H}$、标准中间矩阵组 $\\mathbf{V}$ 和标准输出矩阵组 $\\mathbf{W}$ 的数据及其维度如下，数据采用十进制格式：\n\n\\begin{itemize}\n    \\item 第一组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第二组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第三组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第四组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第五组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n    \\item 第六组：$M = 4, N = 64, L = 2, J = 4, K = 384, \\sigma^2 = 0.01$，详细数据见附件；\n\\end{itemize}\n\n附件中提供 .mat 及 .csv 文件格式的数据，按需使用其中的一种文件格式即可。\n\n请基于以上提供的数据，采用适当的方法，解决以下相关矩阵组的低复杂度计算和存储建模问题。注意，提交结果及论文需要完成以下问题 1、问题 2 中的至少一题，同时完成两题将适当加分。问题 3 为开放式问题，不作为必选，但鼓励尝试，有新意的算法模型设计将得到加分。\n\n在完成以下问题时，仅需考虑各个问题本身申明的建模需求，不需要考虑其他问题产生的建模需求。例如，在完成问题 3 时，不需要额外考虑问题 1 中 $\\rho_{\\min}(V)$ 的建模估计精度需求。\\section*{问题1：相关矩阵组的低复杂度计算}\n\n1) 基于给定的所有矩阵数据 $H$，分析其数据间的关联性，设计相应的近似分析模型 $\\bar{V} = f_1(H)$，在满足 $\\rho_{\\min}(\\bar{V}) \\geq \\rho_{th} = 0.99$ 的情况下，使得根据表格计算的总计算复杂度最低。\n\\begin{itemize}\n\\item 注1：在本问题中，暂不考虑矩阵数据 $H$ 的压缩与解压缩。\n\\item 注2：参考下述 2)，当采用直接设计分析模型 $W = f(H)$ 的方式时，1) 可以跳过不做。\n\\end{itemize}\n\n2) 基于给定的所有矩阵数据 $H$，分析其数据间的关联性，综合设计相应的近似分析模型 $W = f(H)$，在满足 $\\rho_{\\min}(W) \\geq \\rho_{th} = 0.99$ 的情况下，使得根据表格计算的总计算复杂度最低。\n\\begin{itemize}\n\\item 注1：在本问题中，暂不考虑矩阵数据 $H$ 的压缩与解压缩。\n\\item 注2：在本问题中，可以：\n  \\begin{itemize}\n  \\item 在 1) 的基础上考虑 $W = f_2(\\bar{V})$，因此 $W = f(H) = f_2(f_1(H))$；或者，\n  \\item 不需考虑中间结果 $\\bar{V}$，直接设计分析模型 $W = f(H)$，此时 1) 可以跳过不做。\n  \\end{itemize}\n\\item 注3：如果使用常规数学方法，则考虑矩阵所有运算过程涉及的计算复杂度；如果使用人工智能方法，则优先考虑推理阶段的计算复杂度，但需要充分考虑泛化性。\n\\end{itemize}\n\n\\section*{问题2：相关矩阵组的低复杂度存储}\n\n基于给定的所有矩阵数据 $H$ 和 $W$，分析各自数据间的关联性，分别设计相应的压缩 $P_1(\\cdot)$, $P_2(\\cdot)$ 和解压缩 $G_1(\\cdot)$, $G_2(\\cdot)$ 模型，在满足误差 $err_W \\leq E_{th1} = -30 \\,\\text{dB}$, $err_H \\leq E_{th2} = -30 \\,\\text{dB}$ 的情况下，使得存储复杂度和压缩与解压缩的计算复杂度最低，复杂度计算同问题1。\n\\begin{itemize}\n\\item 注1：压缩与解压缩函数的设计方法不做限定。\n\\item 注2：计算复杂度考虑压缩和解压缩函数的所有运算过程。\n\\item 注3：在本问题中，暂不考虑分析模型 $W = f(H)$ 对输出矩阵组 $W$ 的影响。\n\\item 注4：两个建模优化目标（存储复杂度，压缩与解压缩的计算复杂度）的优先级相同。\n\\end{itemize}\n\n\\section*{问题3：相关矩阵组的低复杂度计算和存储}\n\n基于给定的所有矩阵数据 $H$，分析其数据间的关联性，在满足 $\\rho_{\\min}(W) \\geq \\rho_{th} = 0.99$ 的情况下，设计低复杂度计算和存储的整体方案，完成从矩阵输入信号 $H$ 到近似矩阵输出信号 $W$ 的端到端流程。\n\\begin{itemize}\n\\item 注1：在本问题中，可以考虑从矩阵输入信号 $H$ 到近似矩阵输出信号 $W$ 为一个整体流程，而非依次经过“压缩/解压缩、计算单元、压缩/解压缩”的过程。\n\\item 注2：如果使用人工智能方法，需要考虑人工智能模型的存储复杂度以及推理阶段的计算复杂度。\n\\end{itemize}",
  "problem_analysis": "这是一个典型的高维矩阵群（matrix ensemble）在工程系统中出现的降维、近似计算与压缩问题——核心目标在于在满足可量化精度约束（题目中以ρmin(W) ≥ 0.99、ρmin(V) ≥ 0.99、err_H/err_W ≤ −30 dB 等形式给出）的前提下，尽量降低端到端的计算复杂度与存储开销。这个目标直接塑造了解题思路：必须在“保真度（accuracy）”与“资源（compute+memory）”之间构造良好的折衷策略，既要利用矩阵组的结构化相关性（跨 k 的时间/频率维相关性、矩阵内部的低秩或稀疏性、以及同一 j 区块内部的相似子空间），又要结合数值线性代数、随机化/近似分解、以及压缩编码技术，形成可验证的算法链条（从 H 到 V，再到 W，或直接从 H 到 W），同时严格按题目给定的复数算术计次规则评估运行代价与存储位数。建模的主要目标因此可以分解为三项互相制约的任务：一是结构发现（识别 H 内与 H 组间的低维子空间/平稳模式/稀疏基），二是近似算子设计（用低复杂度近似替代逐个 SVD 与精确求逆的昂贵操作），三是压缩编码（在满足误差门限下最大限度减少存储位）。这些目标共同决定了算法设计空间：例如优先采用基于子空间的共享 SVD、随机化 SVD、子采样+插值、迭代解线性系统（避免直接求逆），或用机器学习模型来直接映射 H→W（需权衡训练/推理开销与泛化能力）。\n\n在问题描述中存在若干显性和隐性假设，这些前提会直接影响模型的可迁移性与解释边界。显性的包括：只考虑同一 j 的 K 个矩阵之间的相关性（不同 j 之间视为不相关），W 的“0 相位”规范（列向量首元素实数化），以及按给定表格把各种实数基本运算计权（加法=1、乘法=3、倒数/开方/指数/对数/三角函数各25 等）。隐性的关键假设是：数据在 k 轴上具有平滑或可预测的演变（使得插值或子空间追踪可行），每个 H_{j,k}（或 H 在某些维度上）是低有效秩的（使得仅需前 L 个右奇异向量即可近似），以及噪声与异常值受控，不会导致子空间快速漂移或奇异结构的频繁变化。这些假设若不成立（比如 H 在某些时间点发生跳变，或矩阵元素分布非平稳、含大量离群值），则任何基于平滑/低秩的加速方法都会失效或需要更频繁的重计算，从而削弱节约效果。题目还隐含了对数值稳定性的期望：例如引入 σ^2 正则项以保证逆算子的良好条件数，但当 V_k^H V_k 接近奇异时，迭代求解或近似求逆的误差传播必须被明确分析。\n\n各要素之间的相互依赖和潜在复杂性体现在多个层面。H 的内部元素相关性决定了单个 SVD 的难度与可压缩性，H 在 k 维的相关性决定了是否可以通过对少量关键 k 采样并对其他 k 插值/投影来重建 V 或 W；而 W 的计算依赖于将 J 个 V_{j,k} 在列方向上拼接后对小维度矩阵求逆（维度为 LJ×LJ），因此 J 和 L 的规模增长会使逆运算成为瓶颈。存在的张力包括“局部精度 vs 全局成本”：对少数 k 精确计算可保证局部 ρ，但若插值策略或共享子空间模型不足以捕捉微观差异，ρmin 可能在某些 l,j,k 点跌破阈值；另一张力是“预处理/训练成本 vs 在线推理成本”：例如使用深度网络直接估计 W = f(H) 可以在推理阶段节省大量矩阵运算，但训练和模型存储开销可能很高，且泛化性（在其他数据场景下的表现）存在不确定性。数值角度的张力还体现在相位不确定性上：右奇异向量的相位/符号不唯一（尤其是复数情形），因此在插值或学习 V 时必须采取相位对齐策略，否则后续拼接并求逆会产生不稳定性或误差。\n\n时间尺度与动态性方面，需要考虑子空间随 k 变化的速度（缓慢漂移允许子空间跟踪算法，如 Oja、PAST、PETRELS，快速跳变则需要重计算或使用更密集采样），以及系统应对非平稳输入的机制（自适应阈值、检测并触发重训练/重计算）。长期稳定性问题包括模型退化（例如离线计算的低秩基随时间对真实数据解释力下降）、累积数值误差（迭代解法在长序列上误差积累）以及压缩后的解压缩误差对后续计算的放大效应。因此设计中应包含检测与自校正机制：周期性评估 ρmin 与 err 值，若不满足则回退到更精确但代价更高的计算（例如重新完整 SVD），或动态调整采样密度与子空间维度。\n\n从多元视角来看，问题可以被等价重构为若干不同数学形式，每一种都会导向不同解法与权衡。一个角度是“低秩矩阵近似 + 插值”：把 H_{j,k} 当作随 k 变化的低秩矩阵序列，先在 k 维做变换（DCT、PCA、核 PCA 或 tensor 分解），表示为基×系数形式，仅保存系数并在需要时恢复 V 或 W；另一个角度是“直接映射模型”：学习一个参数化映射 fθ：H→W（基于卷积/变换或 MLP），优点是在线推理快、可将多个复杂步骤合并，缺点是训练开销与泛化风险；第三个角度是“在线子空间追踪 + 轻量化线性代数”：在每个 k 上用快速近似 SVD（随机化 SVD，少量 power iterations）或增量 SVD，并对逆矩阵使用迭代解法（共轭梯度, LSQR）配合预条件器以避免显式求逆；第四个角度是“稀疏/字典表示与残差编码”：把 H 的每个小块在预定字典上稀疏表示，W 由稀疏系数线性映射得到，存储为字典+稀疏系数，适合强稀疏场景。不同角度的比较应基于明确的度量：运算次数按题目表格折算为实数运算代价、存储以比特计量、并以 ρmin 与 err 为约束。\n\n在模型选择与风险管理上，应当识别关键不确定性：数据的相关性强弱、子空间维度的时间变化、异常/跳变、量化噪声和相位模糊。为应对这些不确定性，建议采用可解释且可回退的混合策略：先用统计分析（谱能量分布、主成分能量随 k 的变化、互相关矩阵）确定是否适合低秩/插值策略；采用交叉验证在训练集外测试 ρmin 与 err；在算法中保留“安全阈值”（当局部误差或检测到跳变时，触发完全精确计算）；把在线部分设计为轻量更新（增量 SVD 或子空间跟踪）而把昂贵的完整SVD留作周期性校准。若采用机器学习方法，必须把训练复杂度、模型大小、以及对未知场景的稳健性纳入总体资源预算，并对随机化方法的误差概率与尾部事件做概率性分析。\n\n建模过程应是迭代和数据驱动的：初始阶段以描述性统计与小样本实验确定可用的低秩近似率与采样策略；中期阶段发展近似算法并在全部六组数据上验证，对不满足约束的点实施策略回退或参数调整；长期阶段引入在线变更检测与自适应维度选择机制。总体而言，最佳实践是结合物理/领域先验（例如当矩阵来自窄带/相控阵场景时，子空间通常随频率缓慢变化）与稳健的统计学习方法，采用分层策略（共享基+局部系数、增量更新、迭代解法替代直接求逆），并把复杂度评估量化到复数乘加次数与函数调用成本，以便在工程实现中做出明晰的性能-成本权衡。上述分析既提供了算法设计的路线图，也明确了关键风险点与评估指标，便于下一步在给定数据集上开展实验验证与参数微调。",
  "modeling_solution": "总体思路与关键假设：为满足题目对精度（ρmin(V) 或 ρmin(W) ≥ 0.99、err_H/err_W ≤ −30 dB）与低复杂度的双重约束，提出一套基于“共享低维子空间 + 小尺度旋转/系数随 k 平滑变化的压缩表示 + 随机化/增量化 SVD 辅助采样”的综合建模框架。核心假设为（A1）每个行块 j 内的矩阵序列 {H_{j,k}, k=1..K} 在右奇异向量空间上具有低维稳定子空间，即對任意 k，排名前 L 的右奇异向量 V_{j,k} 落在同一或少数个共同基（shared basis）附近并仅以小幅度的单元变换（正交旋转和相位变化）变化；（A2）这些旋转/相位随索引 k 是平滑或可用少量基（如 DCT 或多项式）表示的；（A3）矩阵内部在行 m (M 维) 与列 n (N 维) 上的统计结构使得对少数采样 k 做高精度分解后可通过插值/重构得到其它 k 的高精度近似；（A4）噪声与异常点可检测并作为触发重计算的信号（若局部误差超阈值则重采样或局部精确计算）。这些假设在题目给定的信号类（视频帧、阵列测量等）中通常成立，因此能在高效性和可控精度间取得良好折中。\n\n模型表示与基本公式：对固定 j，把 K 个 V_{j,k}（每个为 N×L）视作在一个共同基 V̄_j ∈ C^{N×L} 上的局部旋转与相位调整的结果，即假设存在正交矩阵（单位ary）R_{j,k} ∈ C^{L×L} 使得 V_{j,k} ≈ V̄_j R_{j,k}. 于是对所有 j,k 有近似表示\nV_{j,k} ≈ V̂_{j,k} = V̄_j R̂_{j,k}, 其中 V̄_j^H V̄_j = I_L.\n把 J 个子矩阵按列拼接得到 V_k = [V_{1,k},...,V_{J,k}] ≈ V̂_k = [V̄_1 R̂_{1,k},...,V̄_J R̂_{J,k}] = V̄_R_k, 其中以块结构表示的矩阵由共享基和小矩阵 R̂ 构成。定义 G_{i,j} ≡ V̄_i^H V̄_j (每个为 L×L，可离线预计算)。则\nV_k^H V_k ≈ A_k ≡ block_{(i,j)} (R̂_{i,k}^H G_{i,j} R̂_{j,k}), 其中 A_k 为 (LJ)×(LJ) 的正定矩阵。最终目标量\nW_k = V_k (V_k^H V_k + σ^2 I)^{-1} ≈ Ŵ_k = V̂_k (A_k + σ^2 I)^{-1}.\n由于 V̂_k = [V̄_1,...,V̄_J] · B_k，其中 B_k 为块对角右乘 R̂ 的适配矩阵，因此 Ŵ_k 可写为线性组合 Ŵ_k = [V̄_1,...,V̄_J] · S_k，其中 S_k = block矩阵由 {R̂_{j,k}} 与 (A_k + σ^2 I)^{-1} 构成。因此在线计算只需对小维度的 A_k 进行求逆或解线性方程（维度 LJ×LJ，L和J通常很小），并将小矩阵乘回共享基集合以重构 Ŵ_k，从而把昂贵的 N 维和 M 维大规模操作降到离线大部分预处理与在线少量小矩阵运算。\n\nR̂_{j,k} 的参数化与压缩：当 L=2（示例中的情况），任意 2×2 单位ary矩阵可以用一对实参数（混合角度与相位）表示，因此只需以一维光滑函数 θ_{j}(k)、φ_{j}(k) 来刻画。一般 L 情形下，把每个矩阵元素（或每个独立自由度）在 k 维上用少量基函数展开：对每个 j 与每个 entry (p,q) ∈ [1..L]×[1..L]，令 r_{j,p,q}(k) ≈ Σ_{t=1}^T c_{j,p,q,t} ψ_t(k)，其中 ψ_t(k) 可取离散余弦基（DCT）、多项式基或样条基，T ≪ K。系数 c_{·} 为可压缩的数列，且能通过对若干代表 k 的精确 R_{j,k} 求解得到（见求解策略）。因此 R̂_{j,k} 的存储量由 J·L^2·T 决定（T small），大大低于原来对每个 k 存储完整 V_{j,k}（N·L·K）或 H（M·N·J·K）的开销。\n\n求解与训练/重构流程（离线/在线分段）：离线阶段先对每个 j 按以下步骤进行构造性学习并预计算：1) 在 k 轴上等距离或策略性选择 S 个代表索引 S ≪ K（例如 S = 16~64），对这些 k 用精确或近似但足够精度的 SVD（可用 Randomized SVD，参见 Halko 等人）求出 V_{j,k}（N×L）；Randomized SVD 在矩阵较大时用投影维度 L+p（p 为 oversampling，典型 p=5~10）和少量的 power iterations q（q=0~2）即可获得高精度右奇异子空间，极大降低每次 SVD 的计算成本。2) 将这些样本 V_{j,k} 做列并联，针对 j 执行 SVD 或 QR 分解以提取共享基 V̄_j（N×L），即对 [V_{j,k1},...,V_{j,kS}] 做 SVD 得到前 L 个左奇异向量作为 V̄_j。3) 计算 R_{j,k_s} = V̄_j^H V_{j,k_s}（L×L）为样本 k 的局部旋转矩阵；对每个矩阵元素序列 r_{j,p,q}(k_s) 在 k_s 上做 DCT 或 PCA 得到系数 c_{j,p,q,t}（保留前 T 特征）；同时计算并存储 G_{i,j} = V̄_i^H V̄_j（对所有 i,j，J^2 个 L×L 小矩阵）。至此所有离线数据为 {V̄_j}_{j=1..J}（每个 N×L）、{c_{j,p,q,t]}（压缩的 R 表示）、{G_{i,j]}。在线阶段（对每个 k）重构步骤为：从系数恢复 R̂_{j,k}（通过有限个基的线性组合）；构造 A_k = block_{(i,j)} (R̂_{i,k}^H G_{i,j} R̂_{j,k})（运算规模 O(J^2 L^3)）；通过高效小尺度解法（Cholesky 分解或直接求逆，维度 LJ ≤ e.g. 8）得到 (A_k + σ^2 I)^{-1} 或直接解线性方程 (A_k + σ^2 I) X = I 来获得乘子；再以 Ŵ_k = [V̄_1,...,V̄_J] · S_k 恢复 Ŵ_k（N×LJ）并按块拆解回 {Ŵ_{j,k}}。若需要更严格的数值稳定性，可选用迭代求解器（共轭梯度）与预条件器，但对小矩阵直接求逆或 Cholesky 通常更高效且精确。\n\n误差控制与 ρ 的保证：目标是在重构后满足 ρmin(V) ≥ ρ_th。对单列方向 l 来说，ρ_{l,j,k}(V) = | \\hat v_{l,j,k}^H v_{l,j,k} | / (‖\\hat v_{l,j,k}‖‖v_{l,j,k}‖). 由 V̂_{j,k} = V̄_j R̂_{j,k} 与真实 V_{j,k}，有任意单位列 v 与其在基 V̄ 表示的投影误差可用子空间角度表示。若 ∥V_{j,k} − V̄_j R_{j,k}∥_2 ≤ ε_subspace 且 ∥R̂_{j,k} − R_{j,k}∥_2 ≤ ε_rot，则对每列向量的余弦相似度满足 1 − ρ_{l,j,k} = O(ε_subspace^2 + ε_rot^2)。数值上可通过增加采样 S 或基数 T 来减少 ε_rot，或增加 L（若原始排名高于 L）来降低 ε_subspace。在离线阶段通过交叉验证计算所有样本 k 的真实 ρ 并调参直至满足 ρ_th。关于 W 的 ρ：W 由 V 通过平滑矩阵变换 f_2(·) 得到，f_2 对 V 的小扰动有 Lipschitz 性（受 σ^2 正则项保护），因此能把 V 的近似误差向 W 的误差进行上界传播，实际可通过在样本集合上直接评估 ρmin(W) 并以此为准来调节模型参数。\n\n计算复杂度与存储复杂度分析（符号化表达）：令 C_mul_cpx = 14 为一个复数乘法代价，C_add_cpx = 2 为复数加，且对实数基本操作给定表格中乘法为 3、加为1。原始直接方法的主要成本为对每个 j,k 做 SVD 的代价约 O(N M^2 + M^3)（按实数运算折算），加上每个 k 对 A_k∈C^{LJ×LJ} 求逆代价 O((LJ)^3)。本模型的离线与在线成本分解为：離線：S 次的（可能随机化）SVD，成本约 S · Cost_SVD_sample；非零的矩阵 G_{i,j}、DCT/PCA 系数求解等；在线：对每个 k，重构 R̂ 的代价为 O(J L^2 T)（因每个 R 元素由 T 基线性组合）；构造 A_k 成本为 O(J^2 L^3) 的小型矩阵乘加；对 A_k 求逆或 Cholesky 成本 O((LJ)^3)；将 (A_k + σ^2 I)^{-1} 乘回共享基以形成 Ŵ_k 成本为 O(N J L^2)（即把小矩阵权重线性组合到 N×(JL) 的共享基）。因此总体在线每个 k 的复数乘加次数约为 N·J·L^2 (生成 W) + J^2·L^3 (构造 A) + (LJ)^3 (求逆) 加上 R̂ 重构成本 J·L^2·T。若把具体数值代入示例 M=4,N=64,L=2,J=4，则在线复杂度主项为 N·J·L^2 = 64·4·4 = 1024 复数乘（非常小），A_k 构造为 J^2·L^3 = 16·8 = 128 复数乘（小），求逆 (LJ)^3 = 8^3 = 512 的标量操作（极小）。离线需 S 次 SVD，若 S ≪ K 则总体节约显著。按题目建议把复数乘法和加法分别乘以 14 与 2，可得到最终的实值“代价点数”。因此模型在 K 很大时的加速因子主要来自把昂贵的 N×M 大量 SVD（K 次）下降为仅 S 次，以及把 N 维重构的重复计算换为对 N×L 的共享基线性组合（每个 k 只需少量矩阵向量乘）。\n\n对 H 与 W 的压缩（问题2 的建议实现）：H 的压缩 P_1(H) 采用张量分解或变换域稀疏编码。具体做法为对每个 j，视 H_{j,:,:,:} 为三阶张量 M×N×K，对 K 维做 DCT（或 PCA）以利用 k 维的平滑性，并对 (m,n) 平面做局部 PCA（或二维 DCT）以利用空间相关性。保留每条时序 DCT 前 P_k 的系数与若干局部基向量，存储为浮点数（32bit）。这种分解等价于对 H 做 Tucker 分解 H_j ≈ U_j ×_1 A_j ×_2 B_j，其中核张量尺寸远小于原尺寸。重构代价在解压缩阶段为小矩阵乘法，其复杂度可在压缩设计时与存储目标一并优化，以确保 err_H ≤ −30 dB。对 W 的压缩 P_2(W) 与本模型天然吻合：只存储 V̄_j（N×L，J 个）与 R̂ 系数（J·L^2·T 个）和 G_{i,j}（J^2·L^2 个），这实际上是对 W 的结构化压缩；解压缩仅需按在线重构步骤重建 Ŵ_k。由于 N·L·J + J·L^2·T ≪ 64·N·L·J·K（原始 W 大小），可在满足 err_W ≤ −30 dB 时实现很大压缩率。实际设计时通过交叉验证调整 S 与 T 以兼顾 err 与存储/计算复杂度双目标。\n\n数值算法与实现细节：SVD 的实现建议在离线样本上采用 randomized SVD（随机投影 + QR + 小尺度 SVD），投影维度 L+p（p≈5~10），power iterations q=0~2，以在节省计算的同时获得高保真子空间估计。对 R̂ 的基展开使用 DCT 以保证系数能量集中，从而用少量 T 成分恢复高精度的 R。重构 A_k 与求逆使用复数 Cholesky（因为 A_k+σ^2I 必为 Hermitian positive-definite），数值上既稳定又高效。相位对齐：由于右奇异向量对相位/符号不唯一，V_{j,k} 在构造 R 时需先对列向量做相位规范化（例如把每列首元素强制为实数且为非负），以避免相位跳变导致插值或 DCT 产生大误差。对于 L>2 或更复杂情形，可使用 Procrustes 投影得到最优 R_{j,k} = argmin_{Q∈U(L)} ∥V_{j,k} − V̄_j Q∥_F，解析解为 Q = UV^H（来源于 SVD），并把 Q 的元素序列再进行基展开。\n\n自适应与在线校准策略：为应对子空间随 k 的突变，在线应监测重构误差代理（例如对部分 k 随机抽取一列 H_{j,k} 计算快速投影残差或对部分 W_{j,k} 计算 ρ），当误差超阈值时触发局部重采样并重新做 SVD 或扩展样本集合 S；若检测到长期漂移，可周期性地以新的代表样本重训练 V̄_j 与 DCT 系数。该机制保证在非平稳场景下仍能维持 ρmin≥阈值而不致频繁回退到完全精确（昂贵）模式。参数灵活性：S（代表采样数）、T（R 展开基数）、oversampling p 与 power iter q（随机化 SVD 参数）、以及重采样阈值是可调超参数，通过在六组数据集上的交叉验证调整至满足 ρmin 与 err 要求并最小化总体在线与离线成本。\n\n对机器学习替代方案的评价：可考虑训练轻量网络 fθ: H_local_block → R̂ 或直接预测 W_{j,k} 的小系数，但须注意训练与模型存储成本、泛化性风险与对相位不确定性的鲁棒性问题。若采用 ML，应尽量采用物理先验（共享基结构）作为网络架构的 inductive bias，例如网络输出 R̂ 系数或低维投影系数而非直接预测高维 W。ML 解法的推理成本与模型存储应计入问题 1/2 的复杂度评估，并保留基于统计检验的回退机制。\n\n验证、敏感性分析与扩展：在六组数据上，用留出法验证：先在每组上以 S 代表样本训练生成 V̄_j 与系数，计算恢复的 ρmin(V)、ρmin(W) 与 err_H/err_W，并逐步调整 S、T、p、q 直至满足阈值，同时统计离线总操作次数与在线每个 k 的复数乘加数；用这些结果估算总体加速比（原始全量 SVD 与逐 k 求逆的成本比上本方法总成本）。敏感性分析包括考察噪声幅度、子空间漂移速率、采样间距对 ρ 与 err 的影响；若对某些 k 出现突变，记录触发重采样频率以估计长期平均代价。扩展方向包括把单行块 j 的共享基推广为少量字典基（多个 V̄_{j,α}，α=1..A，以处理多模态子空间）、对 R̂ 的时间序列采用自适应滤波器（卡尔曼/自回归模型）以提高对突变的响应、以及将本框架嵌入在线硬实时系统中利用并行化（对 k 并行、对 j 并行或基向量投影并行）以满足严格延时约束。\n\n结论性陈述：该模型通过将大量重复的高维 SVD 运算替换为少量离线高保真子空间学习（采样 S 次）与在线对共享小基的线性组合重构，实现了从 H 到 W 的端到端低复杂度近似：离线阶段承担一部分计算并学习共享结构，在线阶段每个 k 仅需重构小矩阵 R̂、形成小维 Gram 矩阵 A_k、求解小尺度线性系统并把结果线性组合回 N 维共享基，从而显著降低按 k 的总计算与存储开销。通过参数化 R̂（DCT/PCA 基）与使用 randomized SVD、Procrustes 对齐与 Cholesky 求逆，模型在实现高计算/存储压缩的同时可通过交叉验证与自适应重采样保证 ρmin 与 err 的门限要求。该框架既具解释性（基于子空间与旋转的物理解读），又具工程可行性（明确的复杂度公式与可调超参数），可在给定的六组数据集上实施、验证并优化以达到实际问题要求。",
  "task_descriptions": [
    "子任务一（数据探索与结构性假设验证）目标是以数据驱动的、可复现的流程检验并量化“每个行块 j 内序列 H_{j,k} 在右奇异向量空间上具有低有效秩且随 k 平滑可压缩”的假设，并基于此产出用于后续建模的确定性超参数建议（代表采样数 S、R 展开基数 T、随机化 SVD 参数 p 和 q）、相位规范化规则、异常/跳变检测阈值及一组代表性样本索引；本子任务的输入为提供的数据文件（Data*_H.mat 或 .csv，按 M×N×J×K 重构张量），建议使用 MATLAB 或 Python（numpy/scipy、scipy.fftpack.dct、sklearn.utils.extmath.randomized_svd 或自实现的 Halko 随机化 SVD）完成所有计算，并固定随机种子以保证可重复性。具体步骤：1) 采样策略：对每个 j 在 k 轴上按均匀间隔或基于能量分层选择初始样本集合 {k_s}_{s=1..S0}（建议 S0=32~64，必要时以多轮增量方式扩展）；2) 对每个采样索引 k_s 计算 H_{j,k_s} 的精确或随机化 SVD，记录其前 L 个右奇异向量 V_{j,k_s} 和对应奇异值 σ_i；随机化 SVD 可选参数默认 oversampling p∈{5,10}，power iterations q∈{0,1,2}，并记录重建误差以评估 p,q 的充分性；3) 低秩能量检验：计算每个样本的能量占比 η_{j,k_s} = (Σ_{i=1..L} σ_i^2)/(Σ_{i} σ_i^2) 并汇总为分布，判定 L 对应的能量截留率（建议阈值例如 ≥0.99）；4) 子空间平滑与子空间相似性检验：对样本间两两计算主角角/投影残差（例如通过奇异值分解 V1^H V2 或计算投影矩阵差 ∥P_{V1}-P_{V2}∥_F），并以随 k 的自相关或经 DCT 频谱分析来评估子空间随 k 的平滑性；5) 相位/符号不确定性评估与规范化策略：为消除复右奇异向量的相位模糊，对每列施行标准化（例如将每列第一个元素乘以 e^{-j arg(v[0])}，或强制第一个元素为实非负），并统计规范化前后元素相位跳变频率以验证该策略的稳定性；6) R 元素可压缩性检验：对于每个 j 和样本序列，计算旋转矩阵序列 R_{j,k_s} = V̄_j^H V_{j,k_s}（先用样本拼接的 QR/SVD 得到 V̄_j），对每个标量序列 r_{p,q}(k_s) 做 DCT 或 PCA，绘制累计能量谱并据此确定保留基数 T 使得累积能量达到设定阈值（例如 ≥0.99），并给出 T 的最小值建议；7) 异常/跳变检测规则：基于投影残差或主角角的统计分布设定阈值（例如超过均值+α·std 或绝对残差 > ε），并输出用于在线触发的检测阈值与建议的响应动作（例如局部重采样）；8) 输出与报告：为每个 j 生成一份诊断报告（表格或 JSON）包含样本索引列表、每个样本的能量占比分布、子空间相似性统计、DCT 能量集中度曲线及建议的 S、T、p、q、相位规范化规则和异常检测阈值；同时保存用于后续重复实验的所有中间数据（V_{j,k_s}、σ、R 序列、DCT 系数）以及可复现的脚本或命令。该子任务严格仅做假设验证与超参数建议，不进行后续重构或在线重建步骤，其交付物应足够详细以支持后续模块按推荐参数直接运行并在必要时调整。",
    "子任务 2（离线共享子空间学习与压缩参数构建）旨在从给定的矩阵组 H（按张量格式 M×N×J×K 输入，例如 Data*_H 文件）构建每个行块 j 的共享右奇异向量基 V̄_j 与可压缩的旋转/投影系数表示，并输出用于在线重构的结构化压缩参数集；其范围仅限离线计算与参数存储，不包含在线重构或精度验证步骤。具体任务包括以下严格步骤与实现细节：1) 代表样本选择——为每个 j 在 k 轴选取 S 个代表索引 {k_s}_{s=1..S}（建议 S 范围 16–64，可采用均匀采样或基于能量/变异率的启发式采样），并记录所选索引作为元数据；2) 单样本 SVD 计算——对每个被选的 H_{j,k_s} 求其前 L 个右奇异向量 V_{j,k_s}（N×L），优先使用 randomized SVD 实现以降低离线成本（推荐参数 oversampling p=5–10，power iterations q=0–2），实现可选的精确 SVD 以做对照；为保证可重复性在实现中固定随机种子；3) 共享基提取——将样本 V_{j,k_s} 在列方向拼接并对拼接矩阵做 QR 或小尺度 SVD，取前 L 个左奇异向量作为共享基 V̄_j（N×L），并正则化使 V̄_j^H V̄_j = I_L；4) 相位与列对齐——对每个样本 V_{j,k_s} 与共享基进行列相位规范（例如将每列首元素乘以 e^{-j arg(v[0])} 并强制首元为实非负），然后计算每个样本相对于共享基的最优 unitary 近似 R_{j,k_s}，采用 Procrustes 解（对 V̄_j^H V_{j,k_s} 的 SVD，令 R = U V^H）以保证 R 为近似单元矩阵；5) 旋转矩阵序列压缩——将每个 j 的序列 {R_{j,k_s}(p,q)}（对每个标量条目 p,q ∈ [1..L]）视为随 k 的实/复数序列，用离散余弦变换（DCT）或时序 PCA 在 k 轴上展开并保留前 T 系数（T 通过能量截断阈值，如保留 ≥99% 能量确定），对复数序列可分别对实部与虚部进行变换或采用复数 DCT；6) 计算并存储基间 Gram 矩阵——对所有 i,j 计算并保存小矩阵 G_{i,j} = V̄_i^H V̄_j（共 J^2 个 L×L 的复数小矩阵），以便在线构造 Gram 近似 A_k；7) 元数据与压缩包构造——将最终输出以结构化格式保存：每个 V̄_j（以 complex64 存储，尺寸 N×L）、每个 j 的 DCT/PCA 系数集合 c_{j,p,q,t}（complex64，尺寸 J·L^2·T）、所有 G_{i,j}（complex64，J^2·L^2）、所用样本索引列表、随机化 SVD 参数 p,q、相位规范规则、能量阈值与版本信息；建议保存为 .mat 或 NumPy npz 文件并明确标注数据类型与字节顺序。实现工具建议为 Python（numpy, scipy.linalg, scipy.fftpack.dct, sklearn.utils.extmath.randomized_svd 或 scipy.sparse.linalg）或 MATLAB（含 randomized SVD 实现），并在代码中记录运行日志与中间数据（V_{j,k_s}, singular values, R 样本, DCT 系数）以便溯源。输出必须包含足够信息以在不重访原始 H 的情况下重构任意 k 对应的近似旋转矩阵 R̂_{j,k}（通过基系数线性组合）和共享基 V̄_j，以支持后续在线阶段的低复杂度重构；此外应提供简单的验算接口（仅返回重构系数与 Gram 小矩阵）供后续流程快速调用。",
    "子任务3（在线重构与低复杂度计算实现说明）：本子任务限定为在线阶段的端到端实现：输入为已预先生成并存储的压缩参数包（每个行块 j 的共享右奇异向量基 V̄_j ∈ C^{N×L}，以 complex64 存储；每个 j 的旋转/投影系数在 k 轴上的基展开系数 c_{j,p,q,t}（complex64），用于在任意 k 上重构 R̂_{j,k} ∈ C^{L×L}；以及所有基间 Gram 矩阵 G_{i,j} = V̄_i^H V̄_j ∈ C^{L×L}，并含常数 σ^2 和维度参数 N,L,J,T），目标是在每个时间/频率索引 k 高效、稳定地计算近似输出 Ŵ_k = [Ŵ_{1,k},…,Ŵ_{J,k}]（每个 Ŵ_{j,k} ∈ C^{N×L}），同时精确报告并计数所用复数乘/加次数并保证数值稳定性；实现步骤如下：对于给定 k，先按预定线性组合（例如用 DCT 基或 PCA 基）以成本 O(J·L^2·T) 的复数乘加恢复每个 j 的旋转矩阵元素 R̂_{j,k}(p,q)（对复数序列可分别对实/虚部处理或直接用复数基），随后对每列施行相位规范化（将每列首元素乘以 e^{-j arg(首元)} 并强制为实非负，以避免相位跳变对插值的影响）；然后构造小尺度 Gram 近似矩阵 A_k ∈ C^{(LJ)×(LJ)}，其块元素为 A_k[(i),(j)] = R̂_{i,k}^H G_{i,j} R̂_{j,k}，此步代价约 O(J^2·L^3) 复数乘加；接着形成正规化矩阵 B_k = A_k + σ^2 I 并对其进行数值解法：若 cond(B_k) 小于预设条件阈值（例如 1e6），采用 Cholesky 分解（或 LAPACK zpotrf/zpotrs）直接求逆或解线性系统以得到 S_k = (A_k + σ^2 I)^{-1} 的有效乘子，复杂度约 O((LJ)^3)；如 B_k 条件数过大或 Cholesky 失败，则降级为带预条件器的迭代解法（复数 CG/GMRES，使用对角或近似因子预条件器）并限制迭代次数以控制延迟，同时返回数值诊断标志。得到 S_k 后，以代价 O(N·J·L^2) 的复数乘加将小尺度权重映射回大维空间：Ŵ_k = [V̄_1,...,V̄_J] · S_k，然后按块拆解得到各 Ŵ_{j,k} 并对每列再做相位修正以满足系统的 0 相位约定；在线全过程应计算并记录关键诊断量（cond(B_k)、相对残差 r_k = ‖(A_k+σ^2I)S_k − I‖_F / ‖I‖_F、以及可选的子空间一致性指标 e_k = max_j ‖V̄_j R̂_{j,k}^H V̄_j^H − projected‖_F 的代理），并在若干条件触发下（例如 cond(B_k) > cond_th 或 r_k > resid_th，对应经验阈值可初设为 1e6 与 1e-3）触发本地精确计算/重采样或回退到完整 SVD；为满足题目对复杂度精细计数，在线每个 k 的复数乘加近似总量可表示为 C_k ≈ J·L^2·T + J^2·L^3 + (LJ)^3 + N·J·L^2（复数乘与加按题目给定权重映射为实数代价，且实现时应分别统计乘法与加法次数）；实现细节建议使用高度优化的线性代数库（NumPy/SciPy + MKL/BLAS/LAPACK 或等效 GPU 库），复数运算严格采用 complex64 类型以匹配存储规格，并并行化 k 维的重构以提高吞吐；输出为按 k 的 Ŵ_{j,k}（complex64）、每个 k 的诊断标志与误差代理、以及精确的复数乘/加计数和在退化情形下采取的补救动作记录，以便后续离线校准或自适应策略使用。",
    "子任务4（存储压缩设计、验证与自适应控制）的目标是以独立、可重复且可工程实施的方式，设计并验证对输入矩阵组 H 和输出矩阵组 W 的压缩函数 P1, P2 与解压缩函数 G1, G2，使得在解压后满足 err_H ≤ −30 dB 和 err_W ≤ −30 dB（按题目给定的 Frobenius‑norm 与期望定义计算，并在比较 W 时先对输出列向量做相位拉齐以满足 0 相位约定），同时把压缩后存储位数与压缩/解压算力（按复数乘法、复数加法分别计数并以给定代价权重折算成实数代价）最小化；本任务独立完成、只需以 H 和 W 原始数据为输入并输出压缩包与相应的验证报告。具体要求与方法如下：一是压缩策略候选（至少实现并比较两类）：A. 变换域+局部空间分解——对每个 j 将 H_{j,:,:,:} 视为 M×N×K 张量，在 k 维上做 DCT（或时序 PCA）保留前 P_k 系数，在空间 M×N 上对每帧或若干帧做二维 DCT 或局部 PCA（块级 2D‑DCT）并保留前 P_spatial 分量，从而以少量实系数表示 H 的时空行为；B. 张量分解/Tucker（或高阶 SVD）——对每个 j 对 H_j 做低秩 Tucker 分解 H_j ≈ Core_j ×_1 U_m ×_2 U_n ×_3 U_k，分别保存核张量与因子矩阵；对 W 的压缩优先采用结构感知方案：若 W 显示随 k 的平滑性或可由共享子空间表示（例如存在小组基 V̄_j 与随 k 变化的低维系数），则用基矩阵 + 时间系数（对系数在 k 维再做 DCT/PCA 并保留前 T 系数）来表示；若无明显结构则对 W 做逐元素 DCT/PCA 压缩。二是压缩与解压缩的具体实现与输出格式要求：压缩包须包含所有用于重构的矩阵与系数、尺寸元数据、数据类型说明（所有复数以 complex64 存储即每个复数两项32‑bit 浮点；若系数为实数则以 float32 存储）、以及一个解压缩 API（G1/G2）说明文件；给出存储位数的精确公式（例如若存储 complex64 矩阵 A 大小 a×b，则占用位数 = 64·a·b），并对每种候选方案列出压缩后各组成部分的元素数与比特总和。三是计算复杂度计量与约束：在设计阶段按题目要求精确统计压缩（P）与解压（G）过程中的复数乘法次数与复数加法次数，再以题中建议的复数运算成本权重（例如复数乘法代价=14、复数加法代价=2）或按给定实数基本运算表折算成总实数代价，分别给出压缩与解压的单次矩阵/块操作计数公式（例如 DCT 的成本、基矩阵乘回的成本、张量核展开的成本等），并把这些成本列入优化目标。四是参数选择与验证流程：对每种候选压缩算法以网格搜索/交叉验证自动选择关键超参数（时域系数数 P_k、空间系数数 P_spatial、Tucker 秩、W 的基数与时间基数 T 等），目标函数为在满足 err_H 和 err_W 阈值的前提下最小化“存储位数 + λ·（压缩+解压平均计算代价）”（λ 用于权衡存储与计算，可由使用场景设定）；验证过程中须在全部提供数据组上报告最终 err_H、err_W 的数值、每组压缩包大小、压缩与解压的平均复数乘/加计数及折算后实数代价、以及重构误差在 k、j、l 维度的分布（最小、最大、均值、方差）。五是自适应控制与退化处理规则：定义在线或离线监测的代理指标（例如解压后样本的局部重构 SNR/err、W 的列向量相位一致性检测、或对部分 k 计算的 ρ 估计），并给出阈值与触发动作的明确定义：当代理指标越过阈值时，按优先级依次（i）增加保留系数数目（P_k、P_spatial 或 Tucker 秩），（ii）对受影响的 j 在 k 轴上执行局部完整 SVD 重采样并更新压缩系数，或（iii）回退到不压缩的原始或低压缩级别；同时规定最大允许重训练频率与触发日志格式以便统计长期成本。六是比较与决策：对所有候选方法输出一张对比表（或机器可读 JSON）列出在相同误差约束下的最优压缩包大小、压缩/解压每次的平均复数运算计数及折算代价，以及每种方法在不同数据组上的稳健性指标（误差方差、触发重训练频率）。最后，工具与实现细节：明确推荐使用 Python（numpy, scipy, scipy.fftpack.dct, sklearn.decomposition/PCA, tensorly 或 MATLAB）实现原型；压缩包建议以 .npz 或 .mat 保存 complex64/float32 数据；实现时固定随机种子以保证结果可重复；交付物包括压缩与解压缩代码、参数选择脚本、详细验证报告（含 err/ρ 计算脚本）、以及用于自适应触发的配置文件和日志说明。该子任务要求交付可直接运行的压缩包生成与恢复工具、精确的复杂度与存储统计，以及一套可操作的在线自适应策略与阈值，以便在实际部署中保证误差约束同时最小化存储与计算成本。"
  ]
}