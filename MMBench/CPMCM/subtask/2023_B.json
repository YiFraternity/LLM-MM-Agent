{
  "tasks": [],
  "problem_str": "问题背景：\n离散傅里叶变换（Discrete Fourier Transform, DFT）作为一种基本工具广泛应用于工程、科学以及数学领域。例如，通信信号处理中，常用 DFT 实现信号的正交频分复用（Orthogonal Frequency Division Multiplexing, OFDM）系统的时频域变换（见图 1）。另外在信道估计中，也需要用到逆 DFT（IDFT）和 DFT 以便对信道估计结果进行时域降噪（见图 2）。\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{ofdm_system_flow.png}\n\\caption{OFDM 系统流程}\n\\end{figure}\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{channel_estimation_flow.png}\n\\caption{信道估计处理流程}\n\\end{figure}\n\n在芯片设计中，DFT 计算的硬件复杂度与其算法复杂度和数据元素取值范围相关。算法复杂度越高、数据取值范围越大，其硬件复杂度就越大。目前在实际产品中，一般采用快速傅里叶变换（Fast Fourier Transform, FFT）算法来快速实现 DFT，其利用 DFT 变换的各种性质，可以大幅降低 DFT 的计算复杂度（参见[1][2]）。然而，随着无线通信技术的演进，天线阵面越来越大，通道数越来越多，通信带宽越来越大，对 FFT 的需求也越来越大，从而导致专用芯片上实现 FFT 的硬件开销也越大。为进一步降低芯片资源开销，一种可行的思路是将 DFT 矩阵分解成整数矩阵连乘的形式。\n\n给定 $N$ 点的时域一维复数信号 $x_0, x_1, \\ldots, x_{N-1}$，DFT 后得到的复数信号 $X_k$（$k = 0, 1, \\ldots, N-1$）由下式给出（其中 $j$ 为虚数单位，下同）：\n\\begin{equation}\nX_k = \\sum_{n=0}^{N-1} x_n \\cdot e^{-\\frac{j 2 \\pi n k}{N}}, \\quad k = 0, 1, 2, \\ldots, N-1\n\\tag{1}\n\\end{equation}写成矩阵形式为：\n\\begin{equation}\n\\mathbf{X} = \\mathbf{F}_N \\mathbf{x}\n\\tag{2}\n\\end{equation}\n其中 $\\mathbf{x} = [x_0 \\, x_1 \\, \\cdots \\, x_{N-1}]^{\\mathrm{T}}$ 为时域信号向量，$\\mathbf{X} = [X_0 \\, X_1 \\, \\cdots \\, X_{N-1}]^{\\mathrm{T}}$ 为变换后的频域信号向量，$\\mathbf{F}_N$ 为 DFT 矩阵，形式如下：\n\\begin{equation}\n\\mathbf{F}_N = \\frac{1}{\\sqrt{N}} \\begin{bmatrix}\n1 & 1 & 1 & \\cdots & 1 \\\\n1 & w & w^2 & \\cdots & w^{N-1} \\\\n1 & w^2 & w^4 & \\cdots & w^{2(N-1)} \\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\n1 & w^{N-1} & w^{2(N-1)} & \\cdots & w^{(N-1)(N-1)}\n\\end{bmatrix}, \\, w = e^{-\\frac{j2\\pi}{N}}\n\\tag{3}\n\\end{equation}\n\n由于 DFT 矩阵的特殊结构，存在很多方法加速傅里叶变换的计算，其中，分治的策略以及蝶形计算单元的优化是 DFT 性能的关键。下面分别给出用 FFT 和矩阵连乘拟合近似计算 DFT 的具体思路。\n\nFFT 思路：FFT 采用蝶形运算的思想，以 radix-3 蝶形计算为例，其计算过程可以表示为：\n\\begin{equation}\n\\begin{bmatrix}\nX_0 \\\\nX_1 \\\\nX_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 0 & 0 \\\\n1 & -3 & -1 \\\\n1 & -3 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 1 & 0 \\\\n0 & 1/2 & 0 \\\\n0 & 0 & \\sqrt{3}j/2\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 \\\\n0 & 1 & 1 \\\\n0 & 1 & -1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_0 \\\\nx_1 \\\\nx_2\n\\end{bmatrix}\n\\tag{4}\n\\end{equation}\n可以看到蝶形的设计相对于直接 DFT 矩阵乘积的形式大幅降低了复数乘法运算的次数。\n\n矩阵连乘拟合思路：DFT 可以用传统的蝶形计算方法精确实现，也可以用一种矩阵乘法拟合近似获得，其核心思想是将 DFT 矩阵近似表达为一连串稀疏的、元素取值有限的矩阵连乘形式。以 radix-8 蝶形计算为例（参见 [2]）：\n\\begin{equation}\n\\mathbf{F}_8 \\approx \\mathbf{P} \\mathbf{A}_4 \\mathbf{D} \\mathbf{A}_3 \\mathbf{A}_2 \\mathbf{A}_1\n\\tag{5}\n\\end{equation}\n其中 $\\mathbf{P} = [e_0 \\, e_4 \\, e_2 \\, e_5 \\, e_1 \\, e_7 \\, e_3 \\, e_6]$ 为排列矩阵，$\\mathbf{D} = \\mathrm{diag}([1 \\, 1 \\, 1 \\, j \\, 1 \\, j \\, j \\, 1])$ 为对角阵，$\\mathbf{A}_1 \\sim \\mathbf{A}_4$ 为稀疏矩阵，分别如下：\n\\begin{equation}\n\\mathbf{A}_1 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix},\n\\mathbf{A}_2 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix}\n\\end{equation}\n\\begin{equation}\n\\mathbf{A}_3 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix},\n\\mathbf{A}_4 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix}\n\\end{equation}\n\n可以看到在该方案中，分解后的矩阵元素均为整数，从而降低了每个乘法器的复杂度；另外 $\\mathbf{A}_1 \\sim \\mathbf{A}_4$ 的稀疏特性可以减少乘法运算数量。可以看出，这其实是一种精度与硬件复杂度的折中方案，即损失了一定的计算精度，但是大幅降低了硬件复杂度。在对输出信噪比要求不高的情况下可以优先考虑此类方案。\n\n问题要求：\n本题在不同约束条件下，研究DFT的低复杂度计算方案，目的是对目前芯片中利用FFT计算DFT的方法进行替代，以降低硬件复杂度。给定已知的$N$维DFT矩阵$\\mathbf{F}_N$，设计$K$个矩阵$\\mathcal{A}=\\{\\mathbf{A}_1, \\mathbf{A}_2, \\ldots, \\mathbf{A}_K\\}$，使得矩阵$\\beta\\mathbf{F}_N$和$\\mathbf{A}_1\\mathbf{A}_2\\cdots\\mathbf{A}_K$在Frobenius范数意义下尽可能接近，即：\n\\begin{equation}\n\\min_{\\mathcal{A}, \\beta} \\text{RMSE}(\\mathcal{A}, \\beta) = \\frac{1}{N} \\sqrt{\\|\\beta\\mathbf{F}_N - \\mathbf{A}_1\\mathbf{A}_2\\cdots\\mathbf{A}_K\\|_F^2}\n\\tag{6}\n\\end{equation}\n其中$\\beta$为实值矩阵缩放因子，可根据约束条件不同来设计。\n\n相比于乘法，加法的硬件复杂度小得多，因此本题中只考虑乘法器的硬件复杂度：\n\\begin{equation}\nC = q \\times L\n\\end{equation}\n其中，$q$指示分解后的矩阵$\\mathbf{A}_k$中元素的取值范围。在以下的问题2~5中，我们限制$\\mathbf{A}_k$中元素实部和虚部的取值范围为$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}$。以$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\pm 4\\}$为例，此时$q = 3$。$L$表示复数乘法的次数，其中与$0$、$\\pm 1$、$\\pm j$或$(\\pm 1 \\pm j)$相乘时不计入复数乘法次数。例如：若$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\pm 4\\}$，则下列矩阵乘法的硬件复杂度$C = 6$（$q = 3$，$L = 2$）：\n\\begin{equation}\n\\begin{bmatrix}\n1 & 2 + 4j \\\\n1 + 2j & 0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n0 & 1 \\\\n2 + 4j & 2 - 4j\n\\end{bmatrix}\n\\end{equation}\n\n考虑以下两种约束条件：\n- 约束1：限定$\\mathcal{A}$中每个矩阵$\\mathbf{A}_k$的每行至多只有2个非零元素。\n- 约束2：限定$\\mathcal{A}$中每个矩阵$\\mathbf{A}_k$满足以下要求：\n\\begin{equation}\n\\mathbf{A}_k[l, m] \\in \\{x + jy \\mid x, y \\in \\mathcal{P}\\}, \\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}, k = 1, 2, \\ldots, K; \\, l, m = 1, 2, \\ldots, N\n\\end{equation}\n其中，$\\mathbf{A}_k[l, m]$表示矩阵$\\mathbf{A}_k$第$l$行第$m$列的元素。在问题2, 3, 4中，固定$q = 3$；在问题5中，需要寻找合适的$q$以满足精度要求，并且使得硬件复杂度$C$尽量低。\n\n目前使用FFT进行DFT计算的方案硬件复杂度较高，因为我们希望研究一种替代方案来降低DFT计算的硬件复杂度，但同时我们对精度也有一定要求。请针对以下问题分别设计分解方法，既能最小化RMSE，同时又使得乘法器的数量尽量少。\n\n$\\mathcal{A}$中矩阵的个数$K$的取值并没有限制，也是优化的变量之一。但需要注意，一般情况下，$K$越小，硬件复杂度越低，但是如果增加矩阵的个数可以使得矩阵中包含更多的简单元素（$0$、$\\pm 1$、$\\pm j$或$(\\pm 1 \\pm j)$），硬件复杂度也可能会降低，因此，需要根据硬件复杂度$C$的定义合理的设计$K$。\n\n\\textbf{问题1}：首先通过减少乘法器个数来降低硬件复杂度。由于仅在非零元素相乘时需要使用乘法器，若$\\mathbf{A}_k$矩阵中大部分元素均为$0$，则可减少乘法器的个数，因此希望$\\mathbf{A}_k$为稀疏矩阵。对于$N = 2^t, t = 1, 2, 3, \\ldots$的DFT矩阵$\\mathbf{F}_N$，请在满足约束1的条件下，对最优化问题(6)中的变量$\\mathcal{A}$和$\\beta$进行优化，并计算最小误差（即(6)的目标函数，下同）和方案的硬件复杂度$C$（由于本题中没有限定$\\mathbf{A}_k$元素的取值范围，因此在计算硬件复杂度时可默认$q = 16$）。\\textbf{问题2}：讨论通过限制 $\\mathbf{A}_k$ 中元素实部和虚部取值范围的方式来减少硬件复杂度的方案。对于 $N=2^t, t=1,2,3,4,5$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在满足约束2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题3}：同时限制 $\\mathbf{A}_k$ 的稀疏性和取值范围。对于 $N=2^t, t=1,2,3,4,5$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题4}：进一步研究对其他矩阵的分解方案。考虑矩阵 $\\mathbf{F}_N = \\mathbf{F}_{N_1} \\otimes \\mathbf{F}_{N_2}$，其中 $\\mathbf{F}_{N_1}$ 和 $\\mathbf{F}_{N_2}$ 分别是 $N_1$ 和 $N_2$ 维的 DFT 矩阵，$\\otimes$ 表示 Kronecker 积（注意 $\\mathbf{F}_N$ 非 DFT 矩阵）。当 $N_1=4, N_2=8$ 时，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题5}：在问题3的基础上加上精度的限制来研究矩阵分解方案。要求将精度限制在 0.1 以内，即 RMSE $\\leq 0.1$。对于 $N=2^t, t=1,2,3\\ldots$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta, \\mathcal{P}$ 进行优化，并计算方案的硬件复杂度 $C$。\nAddendum: \n参考文献\n\n[1] James W. Cooley and John W. Tukey, An Algorithm for the Machine Calculation of Complex Fourier Series, Mathematics of Computation, vol. 19, no. 90, pp. 297-301, 1965. DOI:10.2307/2003354.\n\n[2] K. R. Rao, D. N. Kim, and J. J. Hwang, Fast Fourier Transform: Algorithms and Applications, Springer, 2010. (中译本：快速傅里叶变换：算法与应用，万帅，杨付正译，机械工业出版社，2012.)\n\n[3] Viduneth Ariyarathna, Arjuna Madanayake, Xinyao Tang, Diego Coelho, et al, Analog Approximate-FFT 8/16-Beam Algorithms, Architectures and CMOS Circuits for 5G Beamforming MIMO Transceivers, IEEE Journal on Emerging and Selected Topics in Circuits and Systems, vol. 8, no. 3, pp. 466-479, 2018. DOI:10.1109/JETCAS.2018.2832177.\n\n附录一：名词解释\n\n- 复数乘法次数/复乘次数：进行复数乘法的次数，例如 $(1+2j) \\times (2+2j)$ 为一次复乘。\n\n- 硬件复杂度：本题中，仅考虑乘法器带来的硬件复杂度，硬件复杂度仅与乘法器个数和每个乘法器的复杂度相关。\n\n- 乘法器个数：本题中，乘法器个数即为复乘次数。\n\n- 单个乘法器的复杂度：单个乘法器的复杂度与乘法器的设计方法和输入数据的位宽等因素相关。在本题中，将乘法器的复杂度简化为仅与输入数据的取值范围相关。对于复数 $g \\in \\{x + jy \\mid x, y \\in \\mathcal{P}\\}$，$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}$，其与任意复数 $z$ 相乘的复杂度为 $q$。",
  "problem": {
    "background": "离散傅里叶变换（Discrete Fourier Transform, DFT）作为一种基本工具广泛应用于工程、科学以及数学领域。例如，通信信号处理中，常用 DFT 实现信号的正交频分复用（Orthogonal Frequency Division Multiplexing, OFDM）系统的时频域变换（见图 1）。另外在信道估计中，也需要用到逆 DFT（IDFT）和 DFT 以便对信道估计结果进行时域降噪（见图 2）。\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{ofdm_system_flow.png}\n\\caption{OFDM 系统流程}\n\\end{figure}\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{channel_estimation_flow.png}\n\\caption{信道估计处理流程}\n\\end{figure}\n\n在芯片设计中，DFT 计算的硬件复杂度与其算法复杂度和数据元素取值范围相关。算法复杂度越高、数据取值范围越大，其硬件复杂度就越大。目前在实际产品中，一般采用快速傅里叶变换（Fast Fourier Transform, FFT）算法来快速实现 DFT，其利用 DFT 变换的各种性质，可以大幅降低 DFT 的计算复杂度（参见[1][2]）。然而，随着无线通信技术的演进，天线阵面越来越大，通道数越来越多，通信带宽越来越大，对 FFT 的需求也越来越大，从而导致专用芯片上实现 FFT 的硬件开销也越大。为进一步降低芯片资源开销，一种可行的思路是将 DFT 矩阵分解成整数矩阵连乘的形式。\n\n给定 $N$ 点的时域一维复数信号 $x_0, x_1, \\ldots, x_{N-1}$，DFT 后得到的复数信号 $X_k$（$k = 0, 1, \\ldots, N-1$）由下式给出（其中 $j$ 为虚数单位，下同）：\n\\begin{equation}\nX_k = \\sum_{n=0}^{N-1} x_n \\cdot e^{-\\frac{j 2 \\pi n k}{N}}, \\quad k = 0, 1, 2, \\ldots, N-1\n\\tag{1}\n\\end{equation}写成矩阵形式为：\n\\begin{equation}\n\\mathbf{X} = \\mathbf{F}_N \\mathbf{x}\n\\tag{2}\n\\end{equation}\n其中 $\\mathbf{x} = [x_0 \\, x_1 \\, \\cdots \\, x_{N-1}]^{\\mathrm{T}}$ 为时域信号向量，$\\mathbf{X} = [X_0 \\, X_1 \\, \\cdots \\, X_{N-1}]^{\\mathrm{T}}$ 为变换后的频域信号向量，$\\mathbf{F}_N$ 为 DFT 矩阵，形式如下：\n\\begin{equation}\n\\mathbf{F}_N = \\frac{1}{\\sqrt{N}} \\begin{bmatrix}\n1 & 1 & 1 & \\cdots & 1 \\\\n1 & w & w^2 & \\cdots & w^{N-1} \\\\n1 & w^2 & w^4 & \\cdots & w^{2(N-1)} \\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\n1 & w^{N-1} & w^{2(N-1)} & \\cdots & w^{(N-1)(N-1)}\n\\end{bmatrix}, \\, w = e^{-\\frac{j2\\pi}{N}}\n\\tag{3}\n\\end{equation}\n\n由于 DFT 矩阵的特殊结构，存在很多方法加速傅里叶变换的计算，其中，分治的策略以及蝶形计算单元的优化是 DFT 性能的关键。下面分别给出用 FFT 和矩阵连乘拟合近似计算 DFT 的具体思路。\n\nFFT 思路：FFT 采用蝶形运算的思想，以 radix-3 蝶形计算为例，其计算过程可以表示为：\n\\begin{equation}\n\\begin{bmatrix}\nX_0 \\\\nX_1 \\\\nX_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 0 & 0 \\\\n1 & -3 & -1 \\\\n1 & -3 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 1 & 0 \\\\n0 & 1/2 & 0 \\\\n0 & 0 & \\sqrt{3}j/2\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 \\\\n0 & 1 & 1 \\\\n0 & 1 & -1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_0 \\\\nx_1 \\\\nx_2\n\\end{bmatrix}\n\\tag{4}\n\\end{equation}\n可以看到蝶形的设计相对于直接 DFT 矩阵乘积的形式大幅降低了复数乘法运算的次数。\n\n矩阵连乘拟合思路：DFT 可以用传统的蝶形计算方法精确实现，也可以用一种矩阵乘法拟合近似获得，其核心思想是将 DFT 矩阵近似表达为一连串稀疏的、元素取值有限的矩阵连乘形式。以 radix-8 蝶形计算为例（参见 [2]）：\n\\begin{equation}\n\\mathbf{F}_8 \\approx \\mathbf{P} \\mathbf{A}_4 \\mathbf{D} \\mathbf{A}_3 \\mathbf{A}_2 \\mathbf{A}_1\n\\tag{5}\n\\end{equation}\n其中 $\\mathbf{P} = [e_0 \\, e_4 \\, e_2 \\, e_5 \\, e_1 \\, e_7 \\, e_3 \\, e_6]$ 为排列矩阵，$\\mathbf{D} = \\mathrm{diag}([1 \\, 1 \\, 1 \\, j \\, 1 \\, j \\, j \\, 1])$ 为对角阵，$\\mathbf{A}_1 \\sim \\mathbf{A}_4$ 为稀疏矩阵，分别如下：\n\\begin{equation}\n\\mathbf{A}_1 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix},\n\\mathbf{A}_2 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix}\n\\end{equation}\n\\begin{equation}\n\\mathbf{A}_3 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix},\n\\mathbf{A}_4 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix}\n\\end{equation}\n\n可以看到在该方案中，分解后的矩阵元素均为整数，从而降低了每个乘法器的复杂度；另外 $\\mathbf{A}_1 \\sim \\mathbf{A}_4$ 的稀疏特性可以减少乘法运算数量。可以看出，这其实是一种精度与硬件复杂度的折中方案，即损失了一定的计算精度，但是大幅降低了硬件复杂度。在对输出信噪比要求不高的情况下可以优先考虑此类方案。",
    "problem_requirement": "本题在不同约束条件下，研究DFT的低复杂度计算方案，目的是对目前芯片中利用FFT计算DFT的方法进行替代，以降低硬件复杂度。给定已知的$N$维DFT矩阵$\\mathbf{F}_N$，设计$K$个矩阵$\\mathcal{A}=\\{\\mathbf{A}_1, \\mathbf{A}_2, \\ldots, \\mathbf{A}_K\\}$，使得矩阵$\\beta\\mathbf{F}_N$和$\\mathbf{A}_1\\mathbf{A}_2\\cdots\\mathbf{A}_K$在Frobenius范数意义下尽可能接近，即：\n\\begin{equation}\n\\min_{\\mathcal{A}, \\beta} \\text{RMSE}(\\mathcal{A}, \\beta) = \\frac{1}{N} \\sqrt{\\|\\beta\\mathbf{F}_N - \\mathbf{A}_1\\mathbf{A}_2\\cdots\\mathbf{A}_K\\|_F^2}\n\\tag{6}\n\\end{equation}\n其中$\\beta$为实值矩阵缩放因子，可根据约束条件不同来设计。\n\n相比于乘法，加法的硬件复杂度小得多，因此本题中只考虑乘法器的硬件复杂度：\n\\begin{equation}\nC = q \\times L\n\\end{equation}\n其中，$q$指示分解后的矩阵$\\mathbf{A}_k$中元素的取值范围。在以下的问题2~5中，我们限制$\\mathbf{A}_k$中元素实部和虚部的取值范围为$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}$。以$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\pm 4\\}$为例，此时$q = 3$。$L$表示复数乘法的次数，其中与$0$、$\\pm 1$、$\\pm j$或$(\\pm 1 \\pm j)$相乘时不计入复数乘法次数。例如：若$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\pm 4\\}$，则下列矩阵乘法的硬件复杂度$C = 6$（$q = 3$，$L = 2$）：\n\\begin{equation}\n\\begin{bmatrix}\n1 & 2 + 4j \\\\n1 + 2j & 0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n0 & 1 \\\\n2 + 4j & 2 - 4j\n\\end{bmatrix}\n\\end{equation}\n\n考虑以下两种约束条件：\n- 约束1：限定$\\mathcal{A}$中每个矩阵$\\mathbf{A}_k$的每行至多只有2个非零元素。\n- 约束2：限定$\\mathcal{A}$中每个矩阵$\\mathbf{A}_k$满足以下要求：\n\\begin{equation}\n\\mathbf{A}_k[l, m] \\in \\{x + jy \\mid x, y \\in \\mathcal{P}\\}, \\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}, k = 1, 2, \\ldots, K; \\, l, m = 1, 2, \\ldots, N\n\\end{equation}\n其中，$\\mathbf{A}_k[l, m]$表示矩阵$\\mathbf{A}_k$第$l$行第$m$列的元素。在问题2, 3, 4中，固定$q = 3$；在问题5中，需要寻找合适的$q$以满足精度要求，并且使得硬件复杂度$C$尽量低。\n\n目前使用FFT进行DFT计算的方案硬件复杂度较高，因为我们希望研究一种替代方案来降低DFT计算的硬件复杂度，但同时我们对精度也有一定要求。请针对以下问题分别设计分解方法，既能最小化RMSE，同时又使得乘法器的数量尽量少。\n\n$\\mathcal{A}$中矩阵的个数$K$的取值并没有限制，也是优化的变量之一。但需要注意，一般情况下，$K$越小，硬件复杂度越低，但是如果增加矩阵的个数可以使得矩阵中包含更多的简单元素（$0$、$\\pm 1$、$\\pm j$或$(\\pm 1 \\pm j)$），硬件复杂度也可能会降低，因此，需要根据硬件复杂度$C$的定义合理的设计$K$。\n\n\\textbf{问题1}：首先通过减少乘法器个数来降低硬件复杂度。由于仅在非零元素相乘时需要使用乘法器，若$\\mathbf{A}_k$矩阵中大部分元素均为$0$，则可减少乘法器的个数，因此希望$\\mathbf{A}_k$为稀疏矩阵。对于$N = 2^t, t = 1, 2, 3, \\ldots$的DFT矩阵$\\mathbf{F}_N$，请在满足约束1的条件下，对最优化问题(6)中的变量$\\mathcal{A}$和$\\beta$进行优化，并计算最小误差（即(6)的目标函数，下同）和方案的硬件复杂度$C$（由于本题中没有限定$\\mathbf{A}_k$元素的取值范围，因此在计算硬件复杂度时可默认$q = 16$）。\\textbf{问题2}：讨论通过限制 $\\mathbf{A}_k$ 中元素实部和虚部取值范围的方式来减少硬件复杂度的方案。对于 $N=2^t, t=1,2,3,4,5$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在满足约束2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题3}：同时限制 $\\mathbf{A}_k$ 的稀疏性和取值范围。对于 $N=2^t, t=1,2,3,4,5$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题4}：进一步研究对其他矩阵的分解方案。考虑矩阵 $\\mathbf{F}_N = \\mathbf{F}_{N_1} \\otimes \\mathbf{F}_{N_2}$，其中 $\\mathbf{F}_{N_1}$ 和 $\\mathbf{F}_{N_2}$ 分别是 $N_1$ 和 $N_2$ 维的 DFT 矩阵，$\\otimes$ 表示 Kronecker 积（注意 $\\mathbf{F}_N$ 非 DFT 矩阵）。当 $N_1=4, N_2=8$ 时，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题5}：在问题3的基础上加上精度的限制来研究矩阵分解方案。要求将精度限制在 0.1 以内，即 RMSE $\\leq 0.1$。对于 $N=2^t, t=1,2,3\\ldots$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta, \\mathcal{P}$ 进行优化，并计算方案的硬件复杂度 $C$。",
    "dataset_path": [],
    "dataset_description": {},
    "variable_description": [],
    "addendum": "参考文献\n\n[1] James W. Cooley and John W. Tukey, An Algorithm for the Machine Calculation of Complex Fourier Series, Mathematics of Computation, vol. 19, no. 90, pp. 297-301, 1965. DOI:10.2307/2003354.\n\n[2] K. R. Rao, D. N. Kim, and J. J. Hwang, Fast Fourier Transform: Algorithms and Applications, Springer, 2010. (中译本：快速傅里叶变换：算法与应用，万帅，杨付正译，机械工业出版社，2012.)\n\n[3] Viduneth Ariyarathna, Arjuna Madanayake, Xinyao Tang, Diego Coelho, et al, Analog Approximate-FFT 8/16-Beam Algorithms, Architectures and CMOS Circuits for 5G Beamforming MIMO Transceivers, IEEE Journal on Emerging and Selected Topics in Circuits and Systems, vol. 8, no. 3, pp. 466-479, 2018. DOI:10.1109/JETCAS.2018.2832177.\n\n附录一：名词解释\n\n- 复数乘法次数/复乘次数：进行复数乘法的次数，例如 $(1+2j) \\times (2+2j)$ 为一次复乘。\n\n- 硬件复杂度：本题中，仅考虑乘法器带来的硬件复杂度，硬件复杂度仅与乘法器个数和每个乘法器的复杂度相关。\n\n- 乘法器个数：本题中，乘法器个数即为复乘次数。\n\n- 单个乘法器的复杂度：单个乘法器的复杂度与乘法器的设计方法和输入数据的位宽等因素相关。在本题中，将乘法器的复杂度简化为仅与输入数据的取值范围相关。对于复数 $g \\in \\{x + jy \\mid x, y \\in \\mathcal{P}\\}$，$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}$，其与任意复数 $z$ 相乘的复杂度为 $q$。",
    "data_summary": "",
    "data_description": {},
    "problem_str": "问题背景：\n离散傅里叶变换（Discrete Fourier Transform, DFT）作为一种基本工具广泛应用于工程、科学以及数学领域。例如，通信信号处理中，常用 DFT 实现信号的正交频分复用（Orthogonal Frequency Division Multiplexing, OFDM）系统的时频域变换（见图 1）。另外在信道估计中，也需要用到逆 DFT（IDFT）和 DFT 以便对信道估计结果进行时域降噪（见图 2）。\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{ofdm_system_flow.png}\n\\caption{OFDM 系统流程}\n\\end{figure}\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{channel_estimation_flow.png}\n\\caption{信道估计处理流程}\n\\end{figure}\n\n在芯片设计中，DFT 计算的硬件复杂度与其算法复杂度和数据元素取值范围相关。算法复杂度越高、数据取值范围越大，其硬件复杂度就越大。目前在实际产品中，一般采用快速傅里叶变换（Fast Fourier Transform, FFT）算法来快速实现 DFT，其利用 DFT 变换的各种性质，可以大幅降低 DFT 的计算复杂度（参见[1][2]）。然而，随着无线通信技术的演进，天线阵面越来越大，通道数越来越多，通信带宽越来越大，对 FFT 的需求也越来越大，从而导致专用芯片上实现 FFT 的硬件开销也越大。为进一步降低芯片资源开销，一种可行的思路是将 DFT 矩阵分解成整数矩阵连乘的形式。\n\n给定 $N$ 点的时域一维复数信号 $x_0, x_1, \\ldots, x_{N-1}$，DFT 后得到的复数信号 $X_k$（$k = 0, 1, \\ldots, N-1$）由下式给出（其中 $j$ 为虚数单位，下同）：\n\\begin{equation}\nX_k = \\sum_{n=0}^{N-1} x_n \\cdot e^{-\\frac{j 2 \\pi n k}{N}}, \\quad k = 0, 1, 2, \\ldots, N-1\n\\tag{1}\n\\end{equation}写成矩阵形式为：\n\\begin{equation}\n\\mathbf{X} = \\mathbf{F}_N \\mathbf{x}\n\\tag{2}\n\\end{equation}\n其中 $\\mathbf{x} = [x_0 \\, x_1 \\, \\cdots \\, x_{N-1}]^{\\mathrm{T}}$ 为时域信号向量，$\\mathbf{X} = [X_0 \\, X_1 \\, \\cdots \\, X_{N-1}]^{\\mathrm{T}}$ 为变换后的频域信号向量，$\\mathbf{F}_N$ 为 DFT 矩阵，形式如下：\n\\begin{equation}\n\\mathbf{F}_N = \\frac{1}{\\sqrt{N}} \\begin{bmatrix}\n1 & 1 & 1 & \\cdots & 1 \\\\n1 & w & w^2 & \\cdots & w^{N-1} \\\\n1 & w^2 & w^4 & \\cdots & w^{2(N-1)} \\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\n1 & w^{N-1} & w^{2(N-1)} & \\cdots & w^{(N-1)(N-1)}\n\\end{bmatrix}, \\, w = e^{-\\frac{j2\\pi}{N}}\n\\tag{3}\n\\end{equation}\n\n由于 DFT 矩阵的特殊结构，存在很多方法加速傅里叶变换的计算，其中，分治的策略以及蝶形计算单元的优化是 DFT 性能的关键。下面分别给出用 FFT 和矩阵连乘拟合近似计算 DFT 的具体思路。\n\nFFT 思路：FFT 采用蝶形运算的思想，以 radix-3 蝶形计算为例，其计算过程可以表示为：\n\\begin{equation}\n\\begin{bmatrix}\nX_0 \\\\nX_1 \\\\nX_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 0 & 0 \\\\n1 & -3 & -1 \\\\n1 & -3 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 1 & 0 \\\\n0 & 1/2 & 0 \\\\n0 & 0 & \\sqrt{3}j/2\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 \\\\n0 & 1 & 1 \\\\n0 & 1 & -1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_0 \\\\nx_1 \\\\nx_2\n\\end{bmatrix}\n\\tag{4}\n\\end{equation}\n可以看到蝶形的设计相对于直接 DFT 矩阵乘积的形式大幅降低了复数乘法运算的次数。\n\n矩阵连乘拟合思路：DFT 可以用传统的蝶形计算方法精确实现，也可以用一种矩阵乘法拟合近似获得，其核心思想是将 DFT 矩阵近似表达为一连串稀疏的、元素取值有限的矩阵连乘形式。以 radix-8 蝶形计算为例（参见 [2]）：\n\\begin{equation}\n\\mathbf{F}_8 \\approx \\mathbf{P} \\mathbf{A}_4 \\mathbf{D} \\mathbf{A}_3 \\mathbf{A}_2 \\mathbf{A}_1\n\\tag{5}\n\\end{equation}\n其中 $\\mathbf{P} = [e_0 \\, e_4 \\, e_2 \\, e_5 \\, e_1 \\, e_7 \\, e_3 \\, e_6]$ 为排列矩阵，$\\mathbf{D} = \\mathrm{diag}([1 \\, 1 \\, 1 \\, j \\, 1 \\, j \\, j \\, 1])$ 为对角阵，$\\mathbf{A}_1 \\sim \\mathbf{A}_4$ 为稀疏矩阵，分别如下：\n\\begin{equation}\n\\mathbf{A}_1 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix},\n\\mathbf{A}_2 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix}\n\\end{equation}\n\\begin{equation}\n\\mathbf{A}_3 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix},\n\\mathbf{A}_4 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix}\n\\end{equation}\n\n可以看到在该方案中，分解后的矩阵元素均为整数，从而降低了每个乘法器的复杂度；另外 $\\mathbf{A}_1 \\sim \\mathbf{A}_4$ 的稀疏特性可以减少乘法运算数量。可以看出，这其实是一种精度与硬件复杂度的折中方案，即损失了一定的计算精度，但是大幅降低了硬件复杂度。在对输出信噪比要求不高的情况下可以优先考虑此类方案。\n\n问题要求：\n本题在不同约束条件下，研究DFT的低复杂度计算方案，目的是对目前芯片中利用FFT计算DFT的方法进行替代，以降低硬件复杂度。给定已知的$N$维DFT矩阵$\\mathbf{F}_N$，设计$K$个矩阵$\\mathcal{A}=\\{\\mathbf{A}_1, \\mathbf{A}_2, \\ldots, \\mathbf{A}_K\\}$，使得矩阵$\\beta\\mathbf{F}_N$和$\\mathbf{A}_1\\mathbf{A}_2\\cdots\\mathbf{A}_K$在Frobenius范数意义下尽可能接近，即：\n\\begin{equation}\n\\min_{\\mathcal{A}, \\beta} \\text{RMSE}(\\mathcal{A}, \\beta) = \\frac{1}{N} \\sqrt{\\|\\beta\\mathbf{F}_N - \\mathbf{A}_1\\mathbf{A}_2\\cdots\\mathbf{A}_K\\|_F^2}\n\\tag{6}\n\\end{equation}\n其中$\\beta$为实值矩阵缩放因子，可根据约束条件不同来设计。\n\n相比于乘法，加法的硬件复杂度小得多，因此本题中只考虑乘法器的硬件复杂度：\n\\begin{equation}\nC = q \\times L\n\\end{equation}\n其中，$q$指示分解后的矩阵$\\mathbf{A}_k$中元素的取值范围。在以下的问题2~5中，我们限制$\\mathbf{A}_k$中元素实部和虚部的取值范围为$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}$。以$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\pm 4\\}$为例，此时$q = 3$。$L$表示复数乘法的次数，其中与$0$、$\\pm 1$、$\\pm j$或$(\\pm 1 \\pm j)$相乘时不计入复数乘法次数。例如：若$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\pm 4\\}$，则下列矩阵乘法的硬件复杂度$C = 6$（$q = 3$，$L = 2$）：\n\\begin{equation}\n\\begin{bmatrix}\n1 & 2 + 4j \\\\n1 + 2j & 0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n0 & 1 \\\\n2 + 4j & 2 - 4j\n\\end{bmatrix}\n\\end{equation}\n\n考虑以下两种约束条件：\n- 约束1：限定$\\mathcal{A}$中每个矩阵$\\mathbf{A}_k$的每行至多只有2个非零元素。\n- 约束2：限定$\\mathcal{A}$中每个矩阵$\\mathbf{A}_k$满足以下要求：\n\\begin{equation}\n\\mathbf{A}_k[l, m] \\in \\{x + jy \\mid x, y \\in \\mathcal{P}\\}, \\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}, k = 1, 2, \\ldots, K; \\, l, m = 1, 2, \\ldots, N\n\\end{equation}\n其中，$\\mathbf{A}_k[l, m]$表示矩阵$\\mathbf{A}_k$第$l$行第$m$列的元素。在问题2, 3, 4中，固定$q = 3$；在问题5中，需要寻找合适的$q$以满足精度要求，并且使得硬件复杂度$C$尽量低。\n\n目前使用FFT进行DFT计算的方案硬件复杂度较高，因为我们希望研究一种替代方案来降低DFT计算的硬件复杂度，但同时我们对精度也有一定要求。请针对以下问题分别设计分解方法，既能最小化RMSE，同时又使得乘法器的数量尽量少。\n\n$\\mathcal{A}$中矩阵的个数$K$的取值并没有限制，也是优化的变量之一。但需要注意，一般情况下，$K$越小，硬件复杂度越低，但是如果增加矩阵的个数可以使得矩阵中包含更多的简单元素（$0$、$\\pm 1$、$\\pm j$或$(\\pm 1 \\pm j)$），硬件复杂度也可能会降低，因此，需要根据硬件复杂度$C$的定义合理的设计$K$。\n\n\\textbf{问题1}：首先通过减少乘法器个数来降低硬件复杂度。由于仅在非零元素相乘时需要使用乘法器，若$\\mathbf{A}_k$矩阵中大部分元素均为$0$，则可减少乘法器的个数，因此希望$\\mathbf{A}_k$为稀疏矩阵。对于$N = 2^t, t = 1, 2, 3, \\ldots$的DFT矩阵$\\mathbf{F}_N$，请在满足约束1的条件下，对最优化问题(6)中的变量$\\mathcal{A}$和$\\beta$进行优化，并计算最小误差（即(6)的目标函数，下同）和方案的硬件复杂度$C$（由于本题中没有限定$\\mathbf{A}_k$元素的取值范围，因此在计算硬件复杂度时可默认$q = 16$）。\\textbf{问题2}：讨论通过限制 $\\mathbf{A}_k$ 中元素实部和虚部取值范围的方式来减少硬件复杂度的方案。对于 $N=2^t, t=1,2,3,4,5$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在满足约束2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题3}：同时限制 $\\mathbf{A}_k$ 的稀疏性和取值范围。对于 $N=2^t, t=1,2,3,4,5$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题4}：进一步研究对其他矩阵的分解方案。考虑矩阵 $\\mathbf{F}_N = \\mathbf{F}_{N_1} \\otimes \\mathbf{F}_{N_2}$，其中 $\\mathbf{F}_{N_1}$ 和 $\\mathbf{F}_{N_2}$ 分别是 $N_1$ 和 $N_2$ 维的 DFT 矩阵，$\\otimes$ 表示 Kronecker 积（注意 $\\mathbf{F}_N$ 非 DFT 矩阵）。当 $N_1=4, N_2=8$ 时，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题5}：在问题3的基础上加上精度的限制来研究矩阵分解方案。要求将精度限制在 0.1 以内，即 RMSE $\\leq 0.1$。对于 $N=2^t, t=1,2,3\\ldots$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta, \\mathcal{P}$ 进行优化，并计算方案的硬件复杂度 $C$。\nAddendum: \n参考文献\n\n[1] James W. Cooley and John W. Tukey, An Algorithm for the Machine Calculation of Complex Fourier Series, Mathematics of Computation, vol. 19, no. 90, pp. 297-301, 1965. DOI:10.2307/2003354.\n\n[2] K. R. Rao, D. N. Kim, and J. J. Hwang, Fast Fourier Transform: Algorithms and Applications, Springer, 2010. (中译本：快速傅里叶变换：算法与应用，万帅，杨付正译，机械工业出版社，2012.)\n\n[3] Viduneth Ariyarathna, Arjuna Madanayake, Xinyao Tang, Diego Coelho, et al, Analog Approximate-FFT 8/16-Beam Algorithms, Architectures and CMOS Circuits for 5G Beamforming MIMO Transceivers, IEEE Journal on Emerging and Selected Topics in Circuits and Systems, vol. 8, no. 3, pp. 466-479, 2018. DOI:10.1109/JETCAS.2018.2832177.\n\n附录一：名词解释\n\n- 复数乘法次数/复乘次数：进行复数乘法的次数，例如 $(1+2j) \\times (2+2j)$ 为一次复乘。\n\n- 硬件复杂度：本题中，仅考虑乘法器带来的硬件复杂度，硬件复杂度仅与乘法器个数和每个乘法器的复杂度相关。\n\n- 乘法器个数：本题中，乘法器个数即为复乘次数。\n\n- 单个乘法器的复杂度：单个乘法器的复杂度与乘法器的设计方法和输入数据的位宽等因素相关。在本题中，将乘法器的复杂度简化为仅与输入数据的取值范围相关。对于复数 $g \\in \\{x + jy \\mid x, y \\in \\mathcal{P}\\}$，$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}$，其与任意复数 $z$ 相乘的复杂度为 $q$。"
  },
  "problem_background": "离散傅里叶变换（Discrete Fourier Transform, DFT）作为一种基本工具广泛应用于工程、科学以及数学领域。例如，通信信号处理中，常用 DFT 实现信号的正交频分复用（Orthogonal Frequency Division Multiplexing, OFDM）系统的时频域变换（见图 1）。另外在信道估计中，也需要用到逆 DFT（IDFT）和 DFT 以便对信道估计结果进行时域降噪（见图 2）。\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{ofdm_system_flow.png}\n\\caption{OFDM 系统流程}\n\\end{figure}\n\n\\begin{figure}[h]\n\\centering\n\\includegraphics[width=0.8\\textwidth]{channel_estimation_flow.png}\n\\caption{信道估计处理流程}\n\\end{figure}\n\n在芯片设计中，DFT 计算的硬件复杂度与其算法复杂度和数据元素取值范围相关。算法复杂度越高、数据取值范围越大，其硬件复杂度就越大。目前在实际产品中，一般采用快速傅里叶变换（Fast Fourier Transform, FFT）算法来快速实现 DFT，其利用 DFT 变换的各种性质，可以大幅降低 DFT 的计算复杂度（参见[1][2]）。然而，随着无线通信技术的演进，天线阵面越来越大，通道数越来越多，通信带宽越来越大，对 FFT 的需求也越来越大，从而导致专用芯片上实现 FFT 的硬件开销也越大。为进一步降低芯片资源开销，一种可行的思路是将 DFT 矩阵分解成整数矩阵连乘的形式。\n\n给定 $N$ 点的时域一维复数信号 $x_0, x_1, \\ldots, x_{N-1}$，DFT 后得到的复数信号 $X_k$（$k = 0, 1, \\ldots, N-1$）由下式给出（其中 $j$ 为虚数单位，下同）：\n\\begin{equation}\nX_k = \\sum_{n=0}^{N-1} x_n \\cdot e^{-\\frac{j 2 \\pi n k}{N}}, \\quad k = 0, 1, 2, \\ldots, N-1\n\\tag{1}\n\\end{equation}写成矩阵形式为：\n\\begin{equation}\n\\mathbf{X} = \\mathbf{F}_N \\mathbf{x}\n\\tag{2}\n\\end{equation}\n其中 $\\mathbf{x} = [x_0 \\, x_1 \\, \\cdots \\, x_{N-1}]^{\\mathrm{T}}$ 为时域信号向量，$\\mathbf{X} = [X_0 \\, X_1 \\, \\cdots \\, X_{N-1}]^{\\mathrm{T}}$ 为变换后的频域信号向量，$\\mathbf{F}_N$ 为 DFT 矩阵，形式如下：\n\\begin{equation}\n\\mathbf{F}_N = \\frac{1}{\\sqrt{N}} \\begin{bmatrix}\n1 & 1 & 1 & \\cdots & 1 \\\\n1 & w & w^2 & \\cdots & w^{N-1} \\\\n1 & w^2 & w^4 & \\cdots & w^{2(N-1)} \\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\n1 & w^{N-1} & w^{2(N-1)} & \\cdots & w^{(N-1)(N-1)}\n\\end{bmatrix}, \\, w = e^{-\\frac{j2\\pi}{N}}\n\\tag{3}\n\\end{equation}\n\n由于 DFT 矩阵的特殊结构，存在很多方法加速傅里叶变换的计算，其中，分治的策略以及蝶形计算单元的优化是 DFT 性能的关键。下面分别给出用 FFT 和矩阵连乘拟合近似计算 DFT 的具体思路。\n\nFFT 思路：FFT 采用蝶形运算的思想，以 radix-3 蝶形计算为例，其计算过程可以表示为：\n\\begin{equation}\n\\begin{bmatrix}\nX_0 \\\\nX_1 \\\\nX_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 0 & 0 \\\\n1 & -3 & -1 \\\\n1 & -3 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 1 & 0 \\\\n0 & 1/2 & 0 \\\\n0 & 0 & \\sqrt{3}j/2\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 \\\\n0 & 1 & 1 \\\\n0 & 1 & -1\n\\end{bmatrix}\n\\begin{bmatrix}\nx_0 \\\\nx_1 \\\\nx_2\n\\end{bmatrix}\n\\tag{4}\n\\end{equation}\n可以看到蝶形的设计相对于直接 DFT 矩阵乘积的形式大幅降低了复数乘法运算的次数。\n\n矩阵连乘拟合思路：DFT 可以用传统的蝶形计算方法精确实现，也可以用一种矩阵乘法拟合近似获得，其核心思想是将 DFT 矩阵近似表达为一连串稀疏的、元素取值有限的矩阵连乘形式。以 radix-8 蝶形计算为例（参见 [2]）：\n\\begin{equation}\n\\mathbf{F}_8 \\approx \\mathbf{P} \\mathbf{A}_4 \\mathbf{D} \\mathbf{A}_3 \\mathbf{A}_2 \\mathbf{A}_1\n\\tag{5}\n\\end{equation}\n其中 $\\mathbf{P} = [e_0 \\, e_4 \\, e_2 \\, e_5 \\, e_1 \\, e_7 \\, e_3 \\, e_6]$ 为排列矩阵，$\\mathbf{D} = \\mathrm{diag}([1 \\, 1 \\, 1 \\, j \\, 1 \\, j \\, j \\, 1])$ 为对角阵，$\\mathbf{A}_1 \\sim \\mathbf{A}_4$ 为稀疏矩阵，分别如下：\n\\begin{equation}\n\\mathbf{A}_1 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix},\n\\mathbf{A}_2 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix}\n\\end{equation}\n\\begin{equation}\n\\mathbf{A}_3 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix},\n\\mathbf{A}_4 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\n1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\\\n1 & 1 & -1 & -1 & -1 & -1 & 1 & 1\n\\end{bmatrix}\n\\end{equation}\n\n可以看到在该方案中，分解后的矩阵元素均为整数，从而降低了每个乘法器的复杂度；另外 $\\mathbf{A}_1 \\sim \\mathbf{A}_4$ 的稀疏特性可以减少乘法运算数量。可以看出，这其实是一种精度与硬件复杂度的折中方案，即损失了一定的计算精度，但是大幅降低了硬件复杂度。在对输出信噪比要求不高的情况下可以优先考虑此类方案。",
  "problem_requirement": "本题在不同约束条件下，研究DFT的低复杂度计算方案，目的是对目前芯片中利用FFT计算DFT的方法进行替代，以降低硬件复杂度。给定已知的$N$维DFT矩阵$\\mathbf{F}_N$，设计$K$个矩阵$\\mathcal{A}=\\{\\mathbf{A}_1, \\mathbf{A}_2, \\ldots, \\mathbf{A}_K\\}$，使得矩阵$\\beta\\mathbf{F}_N$和$\\mathbf{A}_1\\mathbf{A}_2\\cdots\\mathbf{A}_K$在Frobenius范数意义下尽可能接近，即：\n\\begin{equation}\n\\min_{\\mathcal{A}, \\beta} \\text{RMSE}(\\mathcal{A}, \\beta) = \\frac{1}{N} \\sqrt{\\|\\beta\\mathbf{F}_N - \\mathbf{A}_1\\mathbf{A}_2\\cdots\\mathbf{A}_K\\|_F^2}\n\\tag{6}\n\\end{equation}\n其中$\\beta$为实值矩阵缩放因子，可根据约束条件不同来设计。\n\n相比于乘法，加法的硬件复杂度小得多，因此本题中只考虑乘法器的硬件复杂度：\n\\begin{equation}\nC = q \\times L\n\\end{equation}\n其中，$q$指示分解后的矩阵$\\mathbf{A}_k$中元素的取值范围。在以下的问题2~5中，我们限制$\\mathbf{A}_k$中元素实部和虚部的取值范围为$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}$。以$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\pm 4\\}$为例，此时$q = 3$。$L$表示复数乘法的次数，其中与$0$、$\\pm 1$、$\\pm j$或$(\\pm 1 \\pm j)$相乘时不计入复数乘法次数。例如：若$\\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\pm 4\\}$，则下列矩阵乘法的硬件复杂度$C = 6$（$q = 3$，$L = 2$）：\n\\begin{equation}\n\\begin{bmatrix}\n1 & 2 + 4j \\\\n1 + 2j & 0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n0 & 1 \\\\n2 + 4j & 2 - 4j\n\\end{bmatrix}\n\\end{equation}\n\n考虑以下两种约束条件：\n- 约束1：限定$\\mathcal{A}$中每个矩阵$\\mathbf{A}_k$的每行至多只有2个非零元素。\n- 约束2：限定$\\mathcal{A}$中每个矩阵$\\mathbf{A}_k$满足以下要求：\n\\begin{equation}\n\\mathbf{A}_k[l, m] \\in \\{x + jy \\mid x, y \\in \\mathcal{P}\\}, \\mathcal{P} = \\{0, \\pm 1, \\pm 2, \\ldots, \\pm 2^{q-1}\\}, k = 1, 2, \\ldots, K; \\, l, m = 1, 2, \\ldots, N\n\\end{equation}\n其中，$\\mathbf{A}_k[l, m]$表示矩阵$\\mathbf{A}_k$第$l$行第$m$列的元素。在问题2, 3, 4中，固定$q = 3$；在问题5中，需要寻找合适的$q$以满足精度要求，并且使得硬件复杂度$C$尽量低。\n\n目前使用FFT进行DFT计算的方案硬件复杂度较高，因为我们希望研究一种替代方案来降低DFT计算的硬件复杂度，但同时我们对精度也有一定要求。请针对以下问题分别设计分解方法，既能最小化RMSE，同时又使得乘法器的数量尽量少。\n\n$\\mathcal{A}$中矩阵的个数$K$的取值并没有限制，也是优化的变量之一。但需要注意，一般情况下，$K$越小，硬件复杂度越低，但是如果增加矩阵的个数可以使得矩阵中包含更多的简单元素（$0$、$\\pm 1$、$\\pm j$或$(\\pm 1 \\pm j)$），硬件复杂度也可能会降低，因此，需要根据硬件复杂度$C$的定义合理的设计$K$。\n\n\\textbf{问题1}：首先通过减少乘法器个数来降低硬件复杂度。由于仅在非零元素相乘时需要使用乘法器，若$\\mathbf{A}_k$矩阵中大部分元素均为$0$，则可减少乘法器的个数，因此希望$\\mathbf{A}_k$为稀疏矩阵。对于$N = 2^t, t = 1, 2, 3, \\ldots$的DFT矩阵$\\mathbf{F}_N$，请在满足约束1的条件下，对最优化问题(6)中的变量$\\mathcal{A}$和$\\beta$进行优化，并计算最小误差（即(6)的目标函数，下同）和方案的硬件复杂度$C$（由于本题中没有限定$\\mathbf{A}_k$元素的取值范围，因此在计算硬件复杂度时可默认$q = 16$）。\\textbf{问题2}：讨论通过限制 $\\mathbf{A}_k$ 中元素实部和虚部取值范围的方式来减少硬件复杂度的方案。对于 $N=2^t, t=1,2,3,4,5$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在满足约束2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题3}：同时限制 $\\mathbf{A}_k$ 的稀疏性和取值范围。对于 $N=2^t, t=1,2,3,4,5$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题4}：进一步研究对其他矩阵的分解方案。考虑矩阵 $\\mathbf{F}_N = \\mathbf{F}_{N_1} \\otimes \\mathbf{F}_{N_2}$，其中 $\\mathbf{F}_{N_1}$ 和 $\\mathbf{F}_{N_2}$ 分别是 $N_1$ 和 $N_2$ 维的 DFT 矩阵，$\\otimes$ 表示 Kronecker 积（注意 $\\mathbf{F}_N$ 非 DFT 矩阵）。当 $N_1=4, N_2=8$ 时，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta$ 进行优化，并计算最小误差和方案的硬件复杂度 $C$。\n\n\\textbf{问题5}：在问题3的基础上加上精度的限制来研究矩阵分解方案。要求将精度限制在 0.1 以内，即 RMSE $\\leq 0.1$。对于 $N=2^t, t=1,2,3\\ldots$ 的 DFT 矩阵 $\\mathbf{F}_N$，请在同时满足约束1和2的条件下，对 $\\mathcal{A}$ 和 $\\beta, \\mathcal{P}$ 进行优化，并计算方案的硬件复杂度 $C$。",
  "problem_analysis": "这组题目把工程目标（在硬件上以更低成本实现近似 DFT）明确地转化为一个带有结构性与离散性约束的矩阵分解优化问题，其本质是一个在“精度（RMSE）—硬件成本（乘法器数量与单个乘法器复杂度）”两者之间的权衡问题。宏观上看，问题目标既不是找到数学上精确的等式分解（FFT 已有精确的蝶形分解），也不是单纯的函数逼近，而是要在硬件实现的可操作约束下，设计一组稀疏且元素受限的常数矩阵，使得这些矩阵的连乘在 Frobenius 范数意义下近似原始 DFT 矩阵（允许一个全局实数缩放因子 β），同时以最小化乘法硬件复杂度 C = q × L 为目标或评价指标之一。这个目标直接塑造了解题路径：既要关注代数和数值逼近（如何用有限选择的常数与稀疏结构去近似单位根矩阵），也要关注离散/组合优化（矩阵元素必须来自有限集合、每行非零元素受限），并须兼顾硬件映射层面的细节（例如用 2 的幂次实现乘法可变成移位和加法，从而显著降低实际乘法器开销）。\n\n在构建和分析模型时需显式认识到若干重要假设和内含约束，它们会深刻影响结论的可解释性与工程可行性。首先问题用 Frobenius 范数来衡量近似误差，这是一个自然且对称的矩阵级度量，但它并不总能直接反映在特定应用（例如 OFDM 解调或信道估计）中的性能损失；因此仅以 RMSE 为目标可能忽略了对关键频点误差容忍度或相位误差对系统 SNR/BER 的不同影响。其次允许一个全局实数 β 缩放能补偿总体能量偏差——对于固定的 A = A1·A2·…·AK，最优 β 有解析解，可由对 β 求导得到 β = Re(trace(F^H A)) / ||F||_F^2（在 F 为已给的 1/√N 归一化形式时 ||F||_F^2 = N），这在实际优化中应当被利用以避免额外变量带来的搜索复杂度。但另一方面，单一的β 并不能补偿不同频率分量的非均匀误差或相位偏差，因此其实际效能受限。再者，题目把硬件复杂度简化为依赖于 q（元素取值范围）和 L（需要真正复乘的次数）的乘积，这是便于比较的抽象化度量，但它忽略了加法器的面积/延迟、布线复杂度、寄存器/缓存、控制逻辑、流水线与并发等工程重要指标；此外，L 的计数方式在题目中文档存在一定歧义，需要澄清：实际变换过程中我们要实现的是一系列常数稀疏矩阵与输入向量的乘积（矩阵-向量乘法），因此每个非零常数与对应输入分量所引起的一次（或零次，当常数为 ±1, ±j 等无乘法代价时）复乘应被计入 L。因此对“每行最多 2 个非零元素”的约束实际上在运行时限制了每个变换层的每个输出元素最多需做两次乘法，从而限制了 L 的上界，但需要注意矩阵连乘的乘法数并不是简单地等于单矩阵非零计数之和，因为连续层之间的稀疏结构可以导致中间向量长度/非零模式变化；同时事先把所有 Ak 的连乘先算出 A 总矩阵再与 x 相乘在硬件实现中并不可行（系数由产品得到并固定），运行时仍然按层对输入向量做稀疏矩阵乘法，代价是对流水线和存储有不同影响。再补充一点，题目限定元素取自对称有限集合 P（通常选取以 2 的幂为模底的集合）是很有工程针对性的假设，因为乘以 2^n 可以用移位实现，乘以 ±1 或 ±j 仅需符号/实虚交换操作，而乘以 ±1±j 也可用少量加减完成，这样的取值集合意味着乘法器的“真实”硬件实现可以被大幅简化，但这同时把优化问题变为混合整数组合优化，难以通过单纯的线性或凸优化求解。\n\n从内在结构与相互依赖看，这个问题存在多个互相制约的要素。首先是稀疏度（通过约束1控制）与因子数量 K 的权衡：更少的非零元每层降低了当层的乘法需求，但为了得到足够逼近精度通常需要增加层数 K，使得最终产品能实现复杂的线性映射；增加 K 则可能导致总体非零乘法次数 L 的增加或减少取决于每层稀疏度与可被转化为低成本系数（±1、±j、2^n 等）的比例。因此 K 并非越小越好，优化目标应在 K、每层稀疏度、元素集合大小 q 之间寻找 Pareto 前沿。其次是元素离散范围 q 与 RMSE 的关系：更大的 q（更大取值集合）允许更精细逼近，但同时每次非平凡乘法的单元复杂度增大；工程上 q 既可以映射为系数编码位宽，也可能影响精度与动态范围控制（系数与中间结果可能需额外位扩展以避免溢出）。第三，约束2 的离散性与约束1 的稀疏性共同使得优化问题具高度非凸、离散和组合特征，导致标准的解析解不可行，必须采用启发式或混合整数方法；但可利用 DFT 自身的代数对称性（循环性、共轭对称、二进制重排、Kronecker/Cooley-Tukey 分解等）作为强先验，减小搜索空间并保证在小 K 值下仍能取得较好逼近。\n\n在算法与求解策略层面，应当结合连续松弛与离散投影、交替优化和启发式搜索。一个常见可行的路线是先从连续空间出发，寻找若干稀疏因子（例如利用交替最小二乘、稀疏字典学习或矩阵近似的因子分解），得到 A1...AK 的浮点近似，然后对每个矩阵元素做量化与稀疏化（投影到允许集合并同时强制行稀疏性），再做迭代微调；在每次固定其他因子时，对单个因子的每一行求解一个小规模的离散最小二乘问题（因每行最多两个非零的限制意味着组合数目可控），可以通过枚举非零位置和有限取值集合来获得近似最优解。对于 N 较小或因子较少的情形，可以用整数规划或分支定界精确求解；对于较大 N，需要依赖启发式方法如贪心匹配、模拟退火、遗传算法或基于梯度的量化感知训练（可将每个矩阵层视为一层“神经网络”，通过反向传播优化浮点参数并在训练过程中施加量化投影以获得低误差的离散因子）。利用 FFT 的既有蝶形拓扑作为初始结构（即把排列矩阵、少量对角 twiddle 近似为 P、D 这样的可实现矩阵，而把乘法昂贵的位置映射为可近似的移位-加结构）通常能显著提升搜索效率并得到工程上可接受的折中方案；文献中类似“approximate FFT”或“analog approximate-FFT”的研究正是对此思路的具体化。\n\n关于复杂性与可扩展性，随着 N 指数增长（N = 2^t），问题难度迅速增加。矩阵 F_N 大小为 N×N，直接在矩阵元素层面优化意味着变量数量为 O(K N^2)，这是不可接受的；然而问题的实际实现中只关心矩阵对向量的作用，因此可以聚焦于每层的稀疏行结构（每行最多两个非零），使参数总数降为 O(K N) 量级，从而使得规模增长可控。尽管如此，连乘后的整体逼近能力会随 N 的增大而变差（在同等 K 和相同 P 下），因此必须允许 K 随 N 增长或 q 增大以维持给定的 RMSE 目标。这一事实揭示了长期演化与稳定性考量：若希望方法对未来更大规模天线或带宽适用，需要审慎选择 K 与 q 的增长策略，并评估随之增加的延迟、布线和累加器资源开销，这些在本题的 C 度量中未体现。\n\n还有若干工程与建模风险需要明确。首先，RMSE 基于矩阵元素的均方误差，而实际 OFDM 系统对相位错位和幅度偏差的灵敏度并不均匀，某些频点的错误可能对 BER 有显著影响，但在 Frobenius 范数中被稀释；因此最终的“可接受误差阈值（如问题5 的 RMSE ≤ 0.1）”应由系统级仿真（例如链路级 BER、MSE of channel estimates）来验证，而非仅凭矩阵范数。其次，设计中忽略加法器成本、延时和并行度会导致实际芯片实现与估计成本有显著偏差；例如将大量乘法替换为移位-加会减少乘法器，但会增加加法器与布线，影响时钟频率与面积。第三，量化误差在多层累积会产生动态范围增长或精度丢失，需要在设计中加入尺度控制（例如每层的归一化或缩放 β 的层内分配）以避免溢出或降低信噪比；题中只允许一个全局 β，这在多层级误差管理上存在局限。\n\n关于替代表述与拓展思路，问题可以从多种角度重新表述以引导不同解法。一个角度是把问题视为一种稀疏编码/字典学习问题：目标是找到若干“基本算子”（Ak 的行定义的作用）作为字典，使得 DFT 的每一行可以用这些算子以低成本线性组合近似。另一个角度是把问题当成网络剪枝/量化问题：从标准 FFT 架构出发，剪去或量化某些 twiddle 乘法以降低乘法器数，分析误差传播并做补偿。还可以把问题映射为近似代数设计，例如使用 Winograd 小变换或 lifting scheme 来替代常规乘法密集的 twiddle 操作，或探索非正交基（如 Hadamard 与小旋转）组合以减少乘法。不同表述会导出不同的启发式和求解器：字典学习启发稀疏分解，剪枝量化启发基于已有 FFT 的局部优化，代数方法则偏重构造性证明和可证界。\n\n最后强调建模的动态性与迭代性。初始假设（例如忽略加法成本、以 Frobenius 为唯一误差度量、只允许单全局 β、只计乘法器为硬件成本）是为问题陈述简化而必需的，但后续设计过程应保持开放性：在第一轮优化后应对候选方案做系统级仿真并评估实际性能（BER、链路可靠性、功耗、延迟），然后据此更新成本函数（把加法/布线/延迟等纳入），并在下一轮中重新优化 K、q、稀疏模式和元素集合 P，逐步逼近工程可实现且性能接受的设计点。实务上建议采用多目标优化框架来同时权衡 RMSE 与 C（以及必要时的加法与延迟成本），并用启发式搜索与结构化先验（FFT 的蝶形、Kronecker 分解、Permutation/diag 因子）来显著缩小搜索空间，使得对于不同 N 的实例可以构造一条清晰的 Pareto 前沿，供芯片设计者依据系统级约束作最终选择。总结而言，该建模问题既富含有利于工程实现的结构性约束，也因离散和非凸特性带来了实质性的优化挑战；成功的解决方案需要把数学逼近、离散优化、硬件实现知识与系统级验证相结合，并以迭代、分层的方式推进设计。",
  "modeling_solution": "下面给出一个综合且工程可操作的数学建模与求解框架，旨在统一地刻画并求解题目所述的“用若干稀疏、元素受限的常数矩阵连乘近似 DFT 矩阵（并允许一个全局实数缩放因子 β），同时在精准度（RMSE）与乘法硬件复杂度 C = q × L 之间取得折中”这一问题。模型在数学上尽量保持严谨，同时引入有利于数值求解与硬件映射的结构化参数化，包含明确假设、变量定义、目标/约束方程、求解策略、离散化/量化方法、复杂度计数规则和验证/敏感性分析建议，并提出可扩展的改进方向。\n\n一、假设与符号定义（模型基础）  \n为使问题在可控的搜索空间内可解，做如下建模假设：原始 N×N DFT 矩阵记为 F_N（已归一化因子 1/√N），我们试图构造 K 个常数复矩阵 A_k ∈ C^{N×N}，使得 A_total := A_1 A_2 ··· A_K ≈ β F_N，其中 β ∈ R 为可调的全局缩放因子。为便于硬件实现并减小搜索空间，强制每个 A_k 满足每行最多 r 非零条目（题中约束1 即 r = 2），并且矩阵元素来自有限集合 P_complex := {x + j y | x, y ∈ P}, P = {0, ±1, ±2, …, ±2^{q-1}}（题中约束2）。为了降低问题规模并与硬件实际映射一致，我们对每一层 A_k 采用“分对（pairwise）混合块”参数化：每个 A_k 可以表示为若干 2×2 或 1×1 的局部线性变换的直和（embedded 2×2 blocks），并通过行/列置换实现不同元素间的耦合。这种参数化与 FFT 的 butterfly 拓扑一致并使每行最多两个非零成为天然约束。记 CheapSet 为“不需要复乘（或乘法代价可忽略）”的常数值集合（如 0, ±1, ±j, ±1±j, ±2^n 等，实际取决于 P），任何不在 CheapSet 的常数乘法都计入复乘次数 L 的统计。采用该块化参数化后，模型的自由度降至 O(K N)，而非 O(K N^2)，便于大 N 的数值优化。\n\n二、目标函数与约束的数学表述  \n最小化的主要度量为 RMSE( A_set, β ) = (1/N) sqrt( || β F_N − A_total ||_F^2 ). 为兼顾硬件复杂度，提出两类等价的数学优化问题供选择并能生成 Pareto 前沿：一是带约束的二次问题（精度约束下最小化成本），即 minimize C subject to RMSE ≤ ε; 二是加权和形式的多目标松弛，即 minimize J := RMSE^2 + γ C，其中 γ ≥ 0 为权衡参数（γ 可用来扫出不同的折中点）。在实际求解中倾向先使用第二种形式做连续优化并分层探索，再以第一类形式作精确约束检验（例如问题5 中 RMSE ≤ 0.1 的限定）。在这两种目标中，C = q × L，其中 q 为每个复数乘法单元的复杂度（由元素值集合 P 决定），而 L 是在运行时的复乘次数。为便于优化与剪枝，我们定义一个上界和精确计数两种 L 评价：保守上界 L_up = ∑_{k=1}^K nnz_noncheap(A_k) ，即把每层中不在 CheapSet 的非零条目都计一次；更精确的运行时计数 L_exact 可以通过对每一层进行符号/零传播（symbolic sparsity propagation）：初始化向量 v^{(0)} 为一般输入符号，按层迭代 v^{(t)} = A_t v^{(t-1)}，记录每次与非 CheapSet 常数发生的复数乘法；该计数可以通过布尔传播或稀疏模式跟踪精确得到（在大小可控的 N 下可计算）。在优化过程中 L_up 可用作可扩展的松弛目标，L_exact 用于最终的精确评估。\n\n三、β 的解析表达与利用  \n对于任意给定的 A_total，最优的实数缩放因子 β* 能解析写出为最小二乘解：β* = Re( trace( F_N^H A_total ) ) / ||F_N||_F^2. 因为 F_N 的 Frobenius 范数已知（||F_N||_F^2 = N 由于归一化 1/√N），可将 β 在每一步优化中闭式更新，从而将 RMSE 关于 β 的变量消去，提高数值效率与稳定性。\n\n四、结构化参数化：分对 2×2 块模型（核心创新）  \n为把“每行最多 2 个非零”这一稀疏约束转化为可搜索的结构，我们把每层 A_k 表示为对若干不重叠索引对 (i, j) 应用 2×2 复矩阵 M_{k,p}，即 A_k = P_k ( ⊕_{p=1}^{m_k} M_{k,p} ) Q_k ，其中 ⊕ 表示块对角嵌入，P_k、Q_k 为行/列置换（可表示为稀疏置换矩阵或直接通过索引对选择），m_k ≤ N/2，且每个嵌入的 M_{k,p} 为一个 2×2 复矩阵，行稀疏性自然保证为 2（若有单独不与任何其它坐标相混的元素可用 1×1 块）。该模型在表达能力上既能包含标准 butterfly 层（通过适当选择置换和 M_{k,p}），又能表示更加自由的不对称混合。每个 M_{k,p} 的元素受约束来自 P_complex。参数化后，设计任务变成了选择每层的配对模式（pairing pattern）及每个 2×2 块的 4 个复数常数值。This reduces design variables to O(K N) and makes per-block discrete enumeration feasible for moderate set sizes because每个单独2×2块的搜索空间远小于整个 N×N 矩阵的笛卡尔积。\n\n五、优化策略：连续松弛 + 交替逐块离散化（可实现的算法）  \n整体求解采用多阶段、逐层/逐块的交替最小化算法，结合连续松弛、量化投影、分支限界或启发式搜索以应对离散非凸性。算法框架如下。首先初始化配对拓扑：可以采用 FFT 的标准蝶形置换序列、或随机/贪心生成的配对序列作为候选。然后进行连续松弛：允许所有 M_{k,p} 的复数元素自由为实数或复数（不限制到 P_complex），用交替最小二乘（ALS）或块坐标下降（BCD）求解最小化 || β F_N − A_total ||_F^2，其中在每一轮中固定除一个块外的所有变量，求解该块的连续最小二乘问题。该局部问题是线性的：利用矢量化（vec）与 Kronecker 技巧，给定左右两侧乘积矩阵，A_total 对该块的依赖是线性的，故可直接用正规方程或带 Tikhonov 正则化的最小二乘解求得块的连续最优值。交替更新到收敛后得到一组连续解（floating-point），此解通常比随机初始化更接近全局最优。\n\n在得到连续解后进行量化与稀疏化：对每个 2×2 块，先对其 4 个复元进行独立的最近邻量化（将每个实部与虚部各自投影到 P）；但由于独立量化可能导致组合不佳，故对每个块应采用小规模搜索：枚举该块的所有可能值组合或利用分支限界搜索以得到在该块上 RMSE 的最优离散替代（将在周围固定其余块时评估真实目标），当 P 较大或枚举不可行时使用启发式近似（如按照连续解排序取若干候选并逐一评估）。为避免离散化后目标大幅退化，建议在量化后再进行若干轮“离散感知微调”：在保持所有块取值在 P_complex 内的前提下，针对每个块用局部枚举或模拟退火微调其 4 个系数，或通过“straight-through estimator” 的量化感知训练（把量化操作视为前向的不连续映射但在反向传播时使用连续梯度）对连续解做微调并周期性投影到离散集合。整个过程中可对 L_up 或 L_exact 引入惩罚项（例如 λ L_up）以鼓励更多值落在 CheapSet，以降低复乘次数。\n\n六、离散化搜索的可行性优化与剪枝策略  \n为了在离散化阶段加速搜索，提出以下剪枝/加速策略：对每块建立松弛下界与近似解的误差上界，若某一候选组合的下界已大于当前最优，则剪去；利用连乘结构的局部灵敏度信息（计算目标对某块系数的局部雅可比或二阶信息）来决定哪些块需要精细枚举，哪些块可粗量化；对等价方案（通过全局置换或行/列重排等群对称性）做同构合并以去除冗余搜索；采用多起点并行策略：从 FFT 拓扑的若干变体、随机拓扑、以及在连续解周围采样的拓扑同时启动离散优化，最终挑选 RMSE 与 C 的 Pareto 最优解。对于 q 固定但 P 较大时，可以优先尝试将元素逼近到 2 的幂（移位友好）或 ±1/±j（无乘法），这些优先候选能极大降低 L_exact，从而在较小代价下换取显著误差下降。\n\n七、复杂度计数与硬件映射说明（L 与 C 的计算规则）  \n在实际硬件中 L 即复乘次数，C = q × L。为保证计数的可重复性与可比性，建议采用两级计数方法：设计期采用保守上界 L_up 估算硬件复杂度（可快速计算且易于剪枝）；实现验收阶段采用精确运算跟踪得到 L_exact（通过对稀疏模式和特定输入通用性分析得到，例如对最坏/平均输入模式评估）。在 2×2 块模型中，若某块的某个条目属于 CheapSet，则对应乘法不计入 L；若块中存在多个相同系数与输入共享，可以利用共用乘法（乘法结果复用）进一步减少真实乘法次数，此优化可在最终实现阶段通过合并公共乘法进行优化并在 L_exact 中体现。\n\n八、数值求解实现细节与计算资源估计  \n连续松弛与 ALS 阶段主要涉及线性最小二乘问题，且参数规模 O(K N)（每个块 4 个复参数），可用常规线性代数库（LAPACK、Eigen）或稀疏线性代数加速；在量化与枚举阶段，单块枚举与评估为计算热点，但每次仅需重计算涉及该块的 A_total 与目标差异，可用增量更新或左/右乘预计算来加速。对 N ≤ 32、K ≤ 10 的典型实例，该算法在单机 CPU/GPU 上可在数小时内给出高质量解；对更大规模实例可并行化：按块并行评估候选、按不同初始化并行搜索、利用 GPU 进行大规模矩阵乘法和反向传播加速。若采用神经网络风格的量化感知训练（将每层视为一层线性层、固定拓扑、权重量化并用 straight-through estimator 优化），则可在 GPU 上进行大规模并行训练，适合 N 较大而搜索空间巨大时使用。\n\n九、面向题目子问题的具体应用与策略建议  \n对于问题1（仅满足约束1，q 默认大可近似视为连续），采用分对 2×2 块模型并以连续 ALS 为主，最终评估 L_up 即可。对问题2（仅约束2，固定 q=3），可采用 FFT 拓扑初始化并用量化感知训练将 twiddle 因子替换为 P_complex 的近似值；对问题3（同时约束1与2），直接使用本模型的 2×2 区块参数化并按上文的连续-量化-枚举流程求解；对问题4（F_N = F_{N1} ⊗ F_{N2} 的情形且 N1=4,N2=8），利用 Kronecker 结构将设计问题降维：把目标矩阵写为 kronecker_product(F_{N1}, F_{N2})，并对每个子矩阵应用相同或相关的分对分解，可复用在 F_{N1},F_{N2} 上得出的离散块集合，从而减少设计变量并利用直积性质构建 A_k 的块状结构；对问题5（在问题3 基础上要求 RMSE ≤ 0.1 并选择 q 最小化 C），推荐逐层增大 K（先固定较小 q 尝试增加 K，看能否满足精度），若 K 增加成本不可接受则逐步提升 q 并重启优化；通过扫描 (K, q) 网格并对每对 (K,q) 运行上述优化流程，可绘制 RMSE 与 C 的 Pareto 前沿并在满足 RMSE ≤ 0.1 条件下选取最小 C 的配置。\n\n十、模型验证、不确定性与敏感性分析  \n对所得到的每个候选方案，应进行三层验证：矩阵层面的 RMSE 与 β 校验；系统级仿真（例如在 OFDM 或信道估计流程中用近似 DFT 替换真实 DFT，评估 BER、MSE、系统吞吐或链路级性能损失）；实现级预估（综合乘法器数、加法器数、位宽与时序后对面积/功耗进行粗估）。敏感性分析建议对关键参数（q、K、块系数微扰、量化偏差）做蒙特卡洛仿真以评估误差传播与系统性能鲁棒性。为量化不确定性，可将系数视为随机变量并计算输出矩阵的均方差（基于一阶或二阶泰勒近似以节省计算量），从而得到误差对 BER 的置信区间估计。\n\n十一、扩展与改进方向  \n未来可将模型扩展为联合优化乘法与加法的真实硬件成本模型（把加法器、寄存器、布线与延迟纳入代价函数）；可把单一全局 β 拓展为每层缩放因子或分块缩放以增强数值稳定性并控制中间数值范围；可引入稳健优化（min-max）或正则化使得解对输入统计分布更稳健；可把神经网络训练与量化感知方法进一步融合（例如在目标函数中直接加入 BER 级联仿真结果作为损失项，以获得更好的链路级性能）；对极大 N，可探索分布式/流式实现、递归 Kronecker 结构与 Winograd 类型的小规模精确变换的组合以减少总体乘法负担。长期来看，将该离散矩阵分解问题与自动硬件综合工具链相结合（自动把离散矩阵映射为硬件流水线、合并公共乘法、布线友好排布）会把数学近似的收益转化为真实芯片实现的面积与功耗节约。\n\n总结性陈述：本模型的关键创新在于把“每行最多两个非零”的稀疏性自然地映射为“以若干 2×2 嵌入块和置换构成”的分对结构，从而把原本 O(N^2) 的离散组合设计空间降至 O(N K) 的可控规模；采用连续松弛与交替逐块最小二乘得到高质量浮点解，再通过块级枚举/量化感知训练与精细化搜索得到满足 P_complex 的离散解；通过将硬件成本 C 明确写入目标或作为约束，配合 CheapSet 概念和符号传播得到可实施的复乘计数，最终能在 RMSE 与硬件复杂度之间得到工程可接受的 Pareto 折中，并可用于求解题中各子问题（问题1~5）。该框架既具有理论严谨性，又针对工程实现做了必要的结构化约束与数值策略，便于在实际芯片设计流程中迭代验证与部署。",
  "task_descriptions": [
    "子任务 1（建模与符号定义）目标是在数学上精确定义用于后续优化的问题变量、度量、约束与硬件成本评价，并给出可直接用于数值实现的解析表达式和输入/输出数据接口；其范围仅限于符号、假设与公式定义以及必要的计算步骤（不包括求解算法或实验结果）。 具体要求如下：给定归一化的 N×N DFT 矩阵 F_N（按题意包含 1/√N 归一化因子）和变换层数上界 K（K 可作为变量），引入 K 个常数复矩阵 A_k ∈ C^{N×N}（k=1..K），并定义连乘结果 A_total := A_1 A_2 ··· A_K；引入全局实缩放因子 β ∈ R，并以矩阵 Frobenius 范数度量近似误差，定义 RMSE(A_set,β) := (1/N) * sqrt( || β F_N − A_total ||_F^2 )，其中 ||·||_F 表示 Frobenius 范数（元素平方和的平方根）。 明确问题的等价数学目标形式：可表述为最小化 RMSE over {A_k,β} 或作为带约束的形式（例如在给定精度阈值下最小化硬件代价），并指出对任意固定 A_total 最优实数缩放因子有解析解 β* = Re( trace( F_N^H A_total ) ) / ||F_N||_F^2（利用 ||F_N||_F^2 = N 可直接计算），因此在数值优化中可将 β 明确消去以降低变量维度。 对元素域与稀疏性给出精确定义：每个矩阵 A_k 需满足每行最多 r 个非零元素（题中 r=2）；元素取值受限于集合 P_complex := { x + j y | x,y ∈ P }，其中 P := { 0, ±1, ±2, …, ±2^{q−1} }，并明确定义参数 q（表示元素幅值位宽/取值范围）；在需要对硬件成本建模时，定义单个复数乘法复杂度与 q 的关系。 对硬件复杂度给出清晰计量：硬件复杂度 C := q × L，其中 L 表示需要执行的复数乘法次数（复乘次数），并给出两种在建模阶段可用的 L 计数方式以适应不同精度/可计算性需求——保守计数 L_up := Σ_k count_noncheap_nonzero(A_k)（把所有不属于“低成本常数”集合的非零条目计为一次复乘；低成本常数示例可列为 CheapSet = {0, ±1, ±j, ±1±j, ±2^n}，但 CheapSet 的确切定义作为模型输入参数明确），以及更精确的运行时计数 L_exact，通过符号/稀疏模式传播或仿真跟踪中间向量在每层与非 CheapSet 常数相乘的真实次数；在建模阶段须明确使用哪一种计数用于搜索与评价。 明确输入与输出接口：输入包括 F_N (复矩阵), N (维度), 可选的上界 K 或层数搜索范围, 稀疏度 r, 元素集合参数 q（及由其派生的 P 和 P_complex）、CheapSet 的精确定义；输出为用于优化器的数学对象和值：目标函数 RMSE(·) 的可评估函数句柄、β 的闭式更新式、稀疏性约束的可执行谓词（每行非零计数 ≤ r）、以及硬件成本计算函数 C(A_set,q)（依照所选的 L_up 或 L_exact 规则）。 最后列出为保证可实现性应完成的必要小步骤：验证 F_N 的归一化常数（||F_N||_F^2 = N）、实现高效的 Frobenius 与 trace 计算例程、实现对每 A_k 的行稀疏性检测例程、实现 P_complex 的投影/最近邻映射子程序（用于后续离散化阶段）、以及实现 L_up 和一个可扩展的 L_exact 计数器（基于布尔稀疏传播或逐层仿真）；这些函数/例程与明确的输入输出契约构成子任务 1 的全部交付物，且足以被后续算法模块直接调用以开展离散化或优化工作。",
    "子任务 2（结构化参数化与稀疏拓扑设计）的目标是把“每行至多两个非零”这一稀疏性约束系统化地转化为可参数化、可存储、可搜索且硬件友好的矩阵层结构，使得后续数值优化或离散搜索仅需在 O(NK) 的参数空间内进行；为此，本子任务需完成以下工作并交付明确的接口与数据结构：输入为归一化的目标维度 N、层数上界或候选层集合 K（可为空以供后续选择）、每层每行非零上限 r（题中为 2）、元素位宽参数 q 及由其定义的实/虚取值集合 P={0,±1,±2,…,±2^{q−1}} 与复值集合 P_complex={x+jy | x,y∈P}，以及用于低成本乘法的 CheapSet（例如 {0,±1,±j,±2^n,±1±j}）；输出为每层 A_k 的结构化参数化描述：置换矩阵对 P_k（行置换）和 Q_k（列置换）的索引形式，以及不重叠的配对集合 {(i_p, j_p)}_{p=1..m_k}（m_k ≤ ⌊N/2⌋）和对应的 2×2 块模板 M_{k,p}（或者對於孤立未配對行的 1×1 值），满足 A_k = P_k · diag_block(M_{k,1},…,M_{k,m_k},可能的1×1块) · Q_k 且每行最多两个非零条目；具体技术步骤包括：明确并实现置换与配对的数据表示（例如以长度-N 的索引数组表示 P_k、Q_k，以 m_k×2 的索引对数组表示配对），实现配对合法性检测例程（检查配对互不重叠、每行非零计数 ≤ r、奇数 N 情况下 1×1 块的安排），实现块值域约束校验（保证每个 M_{k,p} 的 4 个元素落在 P_complex 中或留作占位以供后续离散化），并提供用于将该结构展开为稀疏矩阵 A_k 的转换函数（返回稀疏矩阵格式或行压缩存储）。在配对/置换生成策略上，需要实现并暴露若干可选算法以供上层优化器调用： (a) 标准 FFT 蝶形生成器（按 radix-2 radix-4 等生成经典层间置换与配对），(b) 贪心配对器（基于目标行/列重要性或先验误差指标对高影响行优先配对），(c) 最大匹配或二分图匹配方法（将行与列视为二分图节点、按权重匹配以生成最优配对拓扑），(d) 随机/多起点配对生成以支持并行多起点搜索；每种策略应输出 P_k、Q_k、配对列表及 m_k。对于存在 Kronecker 结构的情形（目标矩阵为 F_{N1} ⊗ F_{N2} 或已知可分解为子块直积），必须提供专门的构造规则：允许在较小维度 N1、N2 上设计配对/2×2 块模板并通过 Kronecker 展开规则生成大维度层（例如将每层 A_k 表示为相应子层的 Kronecker 或块对角拼接，从而复用子矩阵设计以减少搜索空间），并给出如何将子层置换 P_k^{(1)},P_k^{(2)} 合成到全局置换 P_k 的映射函数。为支持后续的离散化与成本估计，要求该子任务同时实现：块到乘法代价的映射函数（基于 P_complex 与 CheapSet 判断每个块元素是否需要复乘并统计保守上界 L_up）、以及用于并行枚举/局部搜索的块级接口（能够提取单个 M_{k,p} 的当前连续值、尝试候选离散值集合并快速评估由此对 A_total 结构影响的增量函数）。为便于集成与实验，建议使用标准数值/组合工具：线性代数与稀疏矩阵表示用 NumPy/SciPy（或等效的数值库），配对与匹配算法可用 NetworkX 或二分图最大匹配实现，组合枚举与并行可采用 itertools 与多线程/并行计算框架；所有函数应定义清晰的 API（输入：N,K,r,q,P_complex,CheapSet,生成策略参数；输出：每层的 P_k、Q_k、配对列表、m_k、块模板占位与展开稀疏矩阵），并附带验证例程以确保结构满足“每行至多两个非零”的硬性约束及与 Kronecker 结构的一致性；该子任务不包含块系数的数值优化或量化求解，仅负责产生、存储并验证满足稀疏性与硬件友好性约束的层结构与配对拓扑，供后续优化模块使用。",
    "子任务 3（数值求解流程与离散化策略）应独立承担把给定的结构化层描述（每层的置换/配对模式与各 2×2/1×1 块位置）和目标矩阵 F_N 映射为满足元素取值集合 P_complex 的具体矩阵因子 A_k 的数值求解工作，其目标是以最小化 RMSE( A_set, β ) 为主指标并同时可选地引入乘法代价惩罚项以控制 L_up：输入为 F_N、已确定的层结构（每层块索引与拓扑）、允许的取值集合 P_complex、CheapSet、稀疏度上限 r、初始层数 K（或可变 K 的范围）、以及算法超参数（正则化 λ_reg、成本权重 λ_cost、最大迭代次数、收敛阈值等）；输出为离散化后的 A_k（元素 ∈ P_complex）、对应全局缩放 β（用解析式闭式更新）、最终 RMSE 及成本估计（L_up，并可计算或返回用于后续精确跟踪的稀疏模式以便测得 L_exact）。方法按三阶段组织并明确实现细节：第一阶段（连续松弛与交替最小二乘 ALS）：固定层拓扑与其他块参数，逐块将待求块的 4 个复系数视作连续变量，用 vec/Kronecker 展开并解线性最小二乘问题（可加入 Tikhonov 正则化以保障数值稳定）来最小化 ||β F_N − A_total||_F^2，更新时同步用解析式 β = Re(trace(F_N^H A_total)) / N 以消去 β 的影响；以相对目标下降或参数范数变化小于阈值或达到最大迭代次数作为停止准则，并支持多起点初始化以缓解局部极小值。第二阶段（块级最近邻量化与局部枚举）：对每个 2×2 块先对其实部与虚部分别做最近邻投影到 P（产生初始离散解），然后对仍有显著误差的块执行受限的局部组合搜索/分支限界：为每块限定候选值集合（例如连续解四周的若干值或 CheapSet 优先值），枚举这些候选组合并用增量更新（缓存左/右乘积以 O(N^2) 或更低代价快速评估目标变化）评估全局目标，采用错误下界剪枝与对称性合并以裁剪搜索树，枚举深度由用户设置或按误差收益递减原则自适应缩减。第三阶段（量化感知微调 / 全局启发式搜索）：在无法通过局部枚举获得满意解时，启动基于梯度的量化感知训练（将每层视为可训练线性层、在前向传播中使用离散化投影而在反向传播时用 straight-through estimator 近似梯度）或基于模拟退火/遗传算法的全局启发式搜索以在离散域内进一步降低 RMSE 与/或成本；量化感知训练以小学习率在 GPU 上运行时应固定拓扑、不放开原子块结构，并在损失函数中同时包括 RMSE^2 与 λ_cost×L_up 的近似惩罚项以引导系数落在 CheapSet。实现细节与加速手段：所有阶段应实现增量目标评估（缓存并更新 A_prefix·block·A_suffix 以避免每次完全重乘）、并行化块级候选评估（多线程或分布式任务池）、数值稳定措施（每层归一化/缩放限制、正则化参数调整）、以及枚举复杂度控制（束宽/候选集大小/最大枚举节点数）；提供精确计数接口以在完成离散化后基于布尔稀疏传播或实际向量仿真计算 L_exact。交付的软件接口至少应包括：continuous_optimize(structured_layers, F_N, params) → continuous_blocks; block_quantize(continuous_blocks, P_complex) → discrete_blocks_init; block_enumerate(discrete_blocks_init, F_N, budget, λ_cost) → discrete_blocks_refined; quant_aware_train(discrete_blocks_refined, F_N, training_params) → discrete_blocks_final; evaluate_solution(discrete_blocks_final, F_N) → {β, RMSE, L_up, L_exact, diagnostics}；并应记录中间日志（每次迭代 RMSE、β、估计 L_up）以便调参和多起点比较。该子任务只负责数值优化与离散化流程的实现与接口契约，不涉及拓扑生成或最终硬件综合的其他步骤。",
    "子任务 4 的目标是为给定的一组常数矩阵因子（A_1,…,A_K）及其元素取值集合（由位宽参数 q 和 CheapSet 定义）精确且可重复地计算并最小化与实现关联的“复数乘法”硬件复杂度 C，并将该计数结果映射为可用于后续硬件合成与决策的规范化度量；其工作范围包括（1）定义并实现两级乘法计数接口：快速保守估计函数 compute_L_up(A_set, CheapSet)（逐层扫描矩阵元素，凡非零且系数不在 CheapSet 的条目即计为一次复乘）与精确运行时计数函数 compute_L_exact(A_set, CheapSet, InputModel, ReuseOptions)，其中 InputModel 可选为“最坏情形”（例如所有可能非零符号/单位基向量集合）、“平均/统计样本”（随机或典型输入集合）或用户提供的代表性向量集合，以支持不同的设计决策；（2）实现符号/稀疏传播算法以高效计算 L_exact：以布尔稀疏模式与系数成本标注为基础逐层传播“可能为非零的输入项”并记录在每层与非 CheapSet 常数相乘的次数，支持两种模式——静态可达模式（基于稀疏模式推断所有可能非零路径以得到上界或最坏情形计数）和动态仿真模式（对若干输入向量实际数值计算并统计真实乘法事件以得平均/分布）；（3）提供乘法复用与实现层优化工具链接口 optimize_multiplier_sharing(A_set, CheapSet)，其通过构建“常数—输入”乘法图（将相同常数/相同常数比例的多个乘法识别为可复用子表达式）、执行公共子表达式消除（CSE）、合并相同因子乘法并重用乘法结果以减少实际复乘次数，并能够识别并折算可用移位-加替代（当系数为 ±2^n）或无需乘法的交换/符号操作（当系数 ∈ {±1, ±j, ±1±j}）以在 L_exact 中反映实现优化；（4）定义并实现从乘法次数到硬件复杂度的映射 compute_C(L, q, Weights)，其中默认映射为 C = q × L，但允许更细粒度权重函数 w(c)（根据系数是否为移位友好或位宽不同给出不同权重）以支持更真实的面积/功耗估计；（5）提供用于决策的报告与验证输出，包括按层/按块的乘法事件分布、不同 InputModel 下的最坏/平均/样本 L_exact、通过乘法复用后可节省的乘法数、对应的 C 值以及建议的实现替代（如将某些常数替换为邻近的移位友好值以换取显著 C 降低）；（6）实现可插拔的软件模块接口与建议的技术栈：稀疏矩阵与布尔传播采用 SciPy/NumPy 或等效库，图分析与 CSE 用 NetworkX 或自定义哈希表，动态仿真与样本输入分布可用向量化 BLAS/GPU 加速，模块应暴露 compute_L_up、compute_L_exact、optimize_multiplier_sharing、compute_C 与导出详细诊断的 evaluate_mapping 接口；（7）规定运行策略与使用建议：在早期设计迭代中优先使用 compute_L_up 做快速筛选与剪枝，在候选方案进入实现评估时用 compute_L_exact（选择最坏情形与若干典型输入）并执行 optimize_multiplier_sharing 得到可实现的复乘下限并用于最终 C 报告。该子任务不涉及系数优化或 RMSE 计算，其唯一交付物是以上定义完备、可运行的计数与映射工具、对应 API 规格、示例输入/输出格式说明及一组验证用例（包含静态稀疏模式示例与动态仿真样本）以保证计数结果在设计流程中可复用与可追溯。"
  ]
}